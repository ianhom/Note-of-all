# Unclassified

## 编程语言
### C
- C语言是我的编程基础，如果说我能对编程理解更为深入，很可能是在c语言的基础上有的精进。
- C语言是面相过程的语言，解决的问题都是比较微观，流程细节类问题，所以适合单片机和操作系统类对资源或效率要求很高的场合。
#### stack 
- 栈是c语言中非常重要的一个结构，函数的调用会使用到栈，将当前函数执行的上下文压入栈中。
- 通过指针寻找函数内不可间的全局变量及上层函数的局部变量，该方法比较危险，容易造成死机，原理上是通过局部函数内可见的局部变量或静态局部变量来搜索外部变量
```c

#include<stdio.h>
static int sa=234;

void test(void)
{
    static int sb;
    int *p=(int*)&p; // Get SP value
    int i;
    for(i=0;i<20;i++)
        if(*(p+i)==123)
            *(p+i)=456;
    p=&sb;           // Get address of static sb
    for(i=-20;i<20;i++)
        if(*(p+i)==234)
            *(p+i)=789;
}

void main(void)
{
    int a=123;
    test();
    printf("a is %d\n",a);   // you get 456
    printf("sa is %d\n",sa); // you get 789
}
```

#### 全局区
- c语言中定义的顺序不一定是内存空间的排放顺序，编译器往往数据的值和size，还有对齐等要素来安排。
- 非零全局变量的初值是通过ROM的数据保存的。其变量排序在RAM和ROM区内相同。在初始化时自动将ROM数据整体搬移到RAM区域。
- 为零全局变量的初值则是通过整体赋值0来初始化。

#### heap
- 堆是一块固定的静态数据区，一般通过malloc，free等内存管理函数来管理。
- 堆可以是完整的一块空间，也可以是多块不连续空间，具体是否支持要看malloc和free的实现。
- 堆属于全局数据，所以生命周期在malloc到free之间，所以heap数据一定要由开发者管理好，如果没有合适地free会造成内存泄漏。

#### 指针
- 指针是个好东西，也很危险。
- 指针有两个概念，地址和所指向地址的数据的类型。
- 刚开始学指针的时候很多人会说指针就是地址，确实指针的值是一个地址，但指针变量同时表征了所指向空间的数据类型，这一点可以通过指针变量的加减运算可以看出。
- 例如在32位系统中，int类型占4个字节，一个指向int类型的指针在＋1之后，其值就是增加4，这里的＋1指的是指向下一个int类型，所以偏移就是一个int类型的数据长度（32位机器上就是4个字节），如果是char类型，＋1操作则偏移一个字节的长度。
- 指针数组是一个数组，里面全是指针，`int *a[10]`;`a[0]`是个指针。a＋1偏移量是一个int类型的长度。
- 数组指针是个指针，指向一个数组。`int (*a)[10]`;`a`是个指向`int *[10]`数组的指针。a＋1偏移量是十个int类型的长度

#### Queue实现
```c
#include <stdio.h>
#include <stdlib.h>
#if(!MARCO_QUEUE)
typedef struct _q
{
    int h,t,c,s,*d[0];
}Q;

Q* q_init(int n)
{
    if(!n)return NULL;
    Q *q=(Q*)malloc(sizeof(Q)+sizeof(int*)*n);
    if(NULL == q)return NULL;
    q->h=q->t=q->c=0;
    q->s=n;
    return q;
}

int q_in(Q *q, int* n)
{
    if((!q)||(q->c >= q->s))
        return 0;
    q->d[q–>t]=n;
    q->t=(++q->t)%q->s;
    q->c++;
    return 1;
}

int* q_out(Q *q)
{
    int *t = NULL;
    if((!q)||(q->c <= 0))
        return t;
    t = q->d[q–>h];
    q->h=(++q->h)%q->s;
    q->c--;
    return t;
}

int q_cnt(Q *q)
{
    if(!q)return -1;
    return q->c;
}

int q_deinit(Q *q)
{
    if(!q)return 0;
    free(q);
    return 1;
}

int q_full(Q *q)
{
    if(!q)return 0;
    return (q->c == q->s);
}

int q_empty(Q *q)
{
    if(!q)return 0;
    return (q->c == 0);
}
#else
#include <stdio.h>
#include <stdlib.h>

typedef struct _q{int h,t,c,s,*d[0];}Q;
#define Q_INIT(n)       ({Q *_q=0;if(n)if(_q=(Q*)malloc(sizeof(Q)+sizeof(int*)*n)){_q->h=_q->t=_q->c=0;_q->s=n;}_q;})
#define Q_IN(q,n)       ({int _ret=0;if(q)if(q->c<q->s){q->d[q->t]=(int*)n;q->t=(++q->t)%q->s;q->c++;_ret=1;}_ret;})
#define Q_OUT(q)        ({int *_ret=0;if(q)if(q->c>0){_ret=q->d[q->h];q->h=(++q->h)%q->s;q->c--;}_ret;})
#define Q_CNT(q)        (q->c)
#define Q_EMPTY(q)      (q->c==0)
#define Q_FULL(q)       (q->c==q->s)

// Example
void main(int argc, char **argv)
{
    char *a[10]= {"Aa","Bb","Cc","Dd","Ee","Ff","Gg","Hh","Ii","Jj"};
    char *s=argv[1];
    int i,*temp,max=0;
    Q *q;

    while(*s>='0'&&*s<='9')max=max*10+*s++-'0';
    if(!(q=Q_INIT(max)))
        printf("Failed to init queue!\n");
    for(i=0;i<max+1;i++) 
        if(!Q_IN(q,a[i]))
            printf("Queue is full\n");
    for(i=0;i<max+1;i++)
    {
        if(temp=Q_OUT(q))
            printf("%s\n",(char*)temp);
        else 
            printf("Queue is empty\n");
    }
}

```
#### container_of
```c
#define container_of(p,t,m) ({const typeof(((t*)0)->m) *_p=(p);(t*)((char*)_p-((size_t)&((t*)0)->m));})
#define container_of_s(p,t,m) ((t*)((char*)p-((size_t)&((t*)0)->m)))
```


#### printf格式
- %d 十进制整型
- %x 十六进制整型
- %2d 2位对齐整型
- %03d 3位补零对齐整型 
- %lld 长整型
- %f 浮点型
- %.2f 小数点后保留两位浮点型
- %s 字符串型
- %c 字符型
- %p 指针类型

#### 豆知识
- vprintf是用于在变参函数中传递变参时所使用的printf。
- sprintf是讲printf的内容输出指定的内存空间中。

### C++
- Cpp是在C语言基础之上发展出来的面向对象的编程语言。
- Cpp具有现代高级语言的很多特性，面向对象，继承，多态等等。
- 类是对象的模型，可以使用类来创建一个或多个对象实例。
- getinstance可以获得单实例。单例模式下，通过进程才能实现多例。
- Cpp中有string类型，可以直接进行＋操作来实现字符串拼接，但string对象不同于c语言中的char* 无法进行指针操作。
- Cpp在c语言的基础之上增加了许多现在高级语言具备的特性，可以说很多高级语言的特性，也是在不断使用c的过程中，一步步发展而来：
    - 继承，一个子类可以继承父类的成员和操作。
    - 重载，子类可以重写父类的某些功能以实现定制化需求
    - 多态，同一个函数，通过参数的不同来执行不同的操作。

### Python
- Python是一种易学强大的脚本语言。
- 应用范围：网络爬虫，人工智能，自动化测试，嵌入式等等。
- Python的强大有两点∶容易学，应用范围广，有丰富的库支持。
- Python对格式有非常严格的要求，错误的空格缩进也会导致程序无法运行；程序的层级关系也是通过代码缩进来实现的。
- 代码的层级是通过“:”号和代码缩进来表示
- 同c语言的include，Python有强大的import，例如curl就有对应的pycurl模块，具有高开发效率和执行效率。
- Python同样有高级语言的很多特性，如面向对象等。
- Python更像是编程的本质提炼，用简洁的语言重新组织了一下，专注实现本身，而非语法。
- Python的多线程也非常方便，同时一个线程的意外crash不会影响其他线程。
#### micropython
- micropython是运行在mcu上Python，具有丰富的库和良好的实时性。
- 特色库为machine，操作底层的硬件模块。

### Java
- Java的class的构造函数与类名同名，可以有多个构造函数，通过不同的参数来识别不同的构造入口。
- Java是强类型的编程语言，使用变量前要申明变量类型。
- Java编译完成后变成字节码，字节码可以运行在所有Java到位虚拟机上，即实现了一次编译，多处运行的效果
- Java没有指针，所以不会像c那样有指针类的危险操作。
- Java是完全面向对象，所以只有一个方法的函数也需要类进行封装。

### JavaScript
- JS是一种类似c和Java的脚本语言，在前端web开发非常流行，也有用于后端服务器开发的nodejs。
- 其实JavaScript和Java关系不大，Java是编译型语言，而JavaScript是脚本语言。

### Groovy   
- Groovy是用于Java虚拟机的一种敏捷的动态语言，它是一种成熟的面向对象编程语言，既可以用于面向对象编程，又可以用作纯粹的脚本语言。使用该种语言不必编写过多的代码，同时又具有闭包和动态语言中的其他特性。Groovy是JVM的一个替代语言（替代是指可以用 Groovy 在Java平台上进行 Java 编程），使用方式基本与使用 Java代码的方式相同，该语言特别适合与Spring的动态语言支持一起使用，设计时充分考虑了Java集成，这使 Groovy 与 Java 代码的互操作很容易。（注意：不是指Groovy替代java，而是指Groovy和java很好的结合编程  ---- by 百度百科
- Groovy很多语法源自各种语言，可以使用强类型，也可以使用def关键字动态定义。

### shell
- shell是linux开发基础，只有基于linux开发基本都绕不开shell命令或脚本。
- shift命令是用于切换参数位置，例如原参数为 1 2 3，shift命令后就是2 3。
- grep命令是常用的搜索命令，可以过滤出log中的关键信息。
- find命令同样也是搜索命令，可以以文件名来全局查找。
- diff命令可以对比两个文件的不同，注意这里是逐行对比。
- pushd 将路径压栈方式保存起来和popd配合使用。
- pwd 输出当前路径。

#### git
- git clone 克隆仓库
- git status 检查状态
- git add 增加修改记录
- git commit 在本地提交修改
- git push 提交到远端服务器
- git pull 将远端服务器同步到本地
- git branch 检查分支
- git checkout 切换分支，也可以用于撤销某个文件的修改
- git log 输出修改记录
- git shortlog 输出修改记录简要
- git merge 合并分支
- git reset 版本回退
- git diff 比较修改内容
- git config 配置git仓库
- git apply 应用patch
- git am 打patch
- git init 初始化git仓库
- git submodule 子模块操作
- git show 显示已经commit后的修改内容
- git blame 显示文件的修改记录。
- git rm 删除文件在git中的管理。
- git rebase 将其他分支内容作为基础拉进当前分支。
- git rebase -i 修改commit记录。
   - drop 可删除commit。
   - reword 修改commit message
   - edit 修改commit
   - pick 选择该commit
- git fetch 同步远程分支。
- git clean 清除分支修改。
- git grep 搜索内容。
- git mv git管理内的移动。
- git cherry-pick 选择一个commit合入。
- git reflog git相关操作记录
- gitk 可视化管理。

#### Makefile
- Makefile是一种编译脚本，通过目标文件和依赖文件的关系来执行相对于操作，以实现构建完整应用的功能。
- 基本原则是，指定目标，检查依赖文件，执行指定命令（shell命令）
- 目标一半为要生成的文件，也可以是伪目标。
- 目标可以是编译好的obj文件，也可以是最终的可执行文件；
- 伪目标则不需要有实际的文件生成，但借助为目标可以执行一些特定的命令，如clean。
- 规则推导是Makefile一个重要功能，`a.o : a.c ; cc -c a.c` 这样a.c会重复出现两次，且与a.o同名，所以可以简化为`a.o:` 
- Makefile中可以使用变量，`SRC=main.c test.c`,通过`$(SRC)`来使用变量，效果类似于c语言中的宏定义。
- Makefile中可以使用include来加载其他makefile文件，类似于c语言中的include
- Makefile中可以使用foreach来变量列表中成员，取出每个成员做相同的操作。

#### scons
- scons是一种基于Python的代码编译系统。

#### vim
- vim是linux中的常用编辑工具
- vim分为编辑模式和命令模式，一般通过i进入编辑模式，通过ESC返回命令模式
- 命令模式下有多重功能:
    - dd 剪切该行
    - (n)dd 剪切n行
    - yy 复制该行
    - (n)yy 复制n行
    - p  粘贴已复制/剪切的内容
    - /xxx 搜索xxx内容，n键找下一个，N键找上一个
    - ：nnn 跳到nnn行
    - set number 显示行号
    - :%s/old/new 用new替换old
    - x/del 删除该字符
    - home 跳到行首
    - end 跳到行尾
    - s 删除单字符
    - u 撤销上一步操作
    - ctrl+r 重做上一步操作
------------------------------
## 算法
### 基本
- 设计数据结构的时候，可以从每个个体的视角将数据组织起来，然后充分利用这些数据进行处理，然后再除去无用到位视角。
- 使用数组模拟链表结构时，可以先不考虑释放回收的问题，算法题中考的重点不是malloc的算法，而是题目主题的解题思路，比如数据储存的优化，数据结构设计，搜索效率等问题。
- bfs实际是对状态的搜索，要将题目转化为明确的状态，即可使用bfs解题。这里需要充分理解状态的概念，划分出子状态，明确状态见的转换条件。
- dfs和bfs都是查询状态的方法，不同于bfs的步步为营，dfs偏向于不撞南墙不回头。
- 二分法很基础，但写好不容易，先识别出输出的瓶颈，然后找出方法double输出。
### 哈希
- 哈希是一种大数映射成小数的方法。
- 大数可以通过哈希算法计算出哈希值，但哈希值很难推导回原来的大数。


------

## 通讯协议
### BLE
- Bluetooth Low Energy是蓝牙4.0之后的低功耗蓝牙版本，极大扩展了iot应用。
- 因为其低功耗特性，再加上手机到位支持，非常适合可穿戴产品。
- att是基础，上层为gatt定义了访问规范，在这层有服务器和客户端这两个角色，gap使用了gatt实现设备access的规则，在这层定义了广播者，观察者，中心设备（一般为手机）和外围设备（一般为sensor）。
- att是属性协议，定义了数据存放的形式，att中包含了uuid，handle，value和permission。。
- uuid是属性的类型 通过类型可知道数据的含义。
- handle是数据在服务器的唯一地址，类似于指针。
- value就是属性中的数值，比如温度值，电流值或者是字符，亦可以是另一个uuid的值，这需要看本att的uuid含义是什么。
- permission收数值的可读可写权限，向外展示如何操作。
- 多条att组合成service，完成一个具体功能。
- 一个service的开端是一个值uuid为0x2800的att来表示的，其att的值就为服务类型值；uuid为0x2803就表示一个特性声明。
- 用户可以定义自己的service和特性，但这样就没有互操作性，除非向外告知service细节。
- 一个或多个service组成一个profile，表明一个产品提供的能力，定义了角色，发现流程，详细服务等。
- mesh了属于网络层规范。
- mesh的一大特点是报文通过节点中继来扩大通讯范围。
- mesh中有两种承载层，广播承载层和GATT承载层，GATT承载层主要用于proxy应用，广播承载层怎为数据收发应用。。
- mesh规范中provisioner作为网络管理者负责将设备变成网络中的节点。
- Proxy作为代理可以将手机接入到mesh网络中
- Friend node作为低功耗节点的缓存。friend和低功耗节点链接建立的大致流程为，低功耗节点寻找附近friend，friend回应请求，建立连接。
- DFU基于GATT进行数据交换，利用通知和写入来传递固件，暂时没有官方profile，各芯片厂家有自己的方案。
- supervision_timeout是在数据链路层上决定了两个设备最小需要有成功连接的超时时间，若在这个时间内没有有效的数据交互，则会断开连接。
#### le audio
- 助听器，音频广播，真无线耳机等应用。
#### 蓝牙技术相关产品畅想
- 耳机式对讲机
- 助听器，翻译机
- 寻路雷达

### CoAP
- 简化版，二进制版的http
- 具有get，put，post，delete等方法

### MQTT
- MQTT是基于订阅发布机制的适用于物联网的通讯协议
- 报文结构包括固定头，可变头和payload
- 固定头中的格式是固定的，长度是2到5个字节。第一个字节用以表示mqtt包类型，第二到五个字节是表示剩余数据的长度，这个表示长度的域是可变的。
- 可变头则是根据报文类型有各自规定的格式，内容也要依据具体报文类型来判断。

### socket编程
- socket可以实现进程间通讯。
- 一个socket绑定一个ip＋port号，多个socket不能绑定同一个地址，所以socket有时会作为共享资源，而无法再进程间同时使用。因此socket属于全局资源，在进程间可以做同步使用。
- 基于Python的socket模块可以通过setopt设置定制参数如超时时间等。

-----------------------------------------------


## 人工智能
### math
- 函数是变量x到因变量y之间的映射关系。
 

### 机器学习
- 神经网络（NN）是通过模拟神经元传递信息的过程而发展出来的。
- 神经元的基本工作原理如下，多个输入拥有不用的权重，所有输入乘以权重的和如果超过了神经元阈值，则神经元被激活然后产生输出；反之怎不被激活不产生输出。
- 在基本的规则之上，由多个神经元形成多层的结构，这个结构就是神经网络。众多微小的输入通过该网络形成一个整体的输入。
- 上一层单元与下一层单元之间的链接是有权重系数的，而训练学习就是一个自动调整这个系数的过程。

------------------------------------------------

## 操作系统
### 调度
- 如果说把成为操作系统的代码裁剪到最小，那最后剩下的就是调度。调度是操作系统的关键。
- 操作系统的关键是特供服务，核心服务就是调度。
- 为了更好的调度，会逐渐出现相关辅助的机制，如ipc
- 调度的对象是一段串行的流程，在rtos中称之为任务，在大型系统中称之为线程
- 程序的运行有上下文环境，调度就是切换上下文。举个例子，小时候的网吧电脑里安装了各种各样单机游戏（还没啥网络游戏），电脑有限，时间有限（四元一小时）所以一个游戏总是不能一玩到底（仙剑奇侠传）这时不得不保存下机，然后下一个偷偷摸摸来玩的小伙伴上机玩其他游戏打开他之前的金庸奇侠传记录，然后继续玩。而我等攒够了钱，我再来继续独挡。
### 进程间通讯IPC
- 调度的对象是任务，而任务之间免不了有数据交换或流程同步，这时就需要ipc。
- 在RTOS中没有虚拟内存，虽然每个任务都有自己独立的栈，但是内存地址对大家而言是一致的，即所有任务所涉及到的地址空间是同一个0~4G(32为机)，在这种情况下，最简单的数据交换方式就是使用一个全局变量。
- 既然全局变量这么简单，为什么在rtos中很少见呢?其实不光rtos，在裸机程序中对全局变量的使用都是有限制的。
- 说到这里我们用裸机中的主程序和中断来类比，有一个全局变量a，主程序中修改其值为0，紧接着打印这个值；同时中断中没1ms修改这个a的值为1，我们打印的结果是永远为0吗?从打印结果会发现，结果中会出现1，因为在打印之前总有机会被中断打断，然后被修改1并打印出来。其实还有更微观的原理。
- 裸机中的主程序和中断就属于两个任务，在rtos中多个任务之间也有类似的关系，所以多任务对共享资源都要特别注意，这时就需要ipc介入。
- 在RTOS中，没有虚拟地址，所有的地址都是实际地址，所有可以直接通过指针找到具体的内存。那么任务之间的通讯，只需要通过系统管理好数据的位置信息共享，即可完成信息的交换。
- IPC的功能不仅仅是在任务之间交换“数据”，“交换”这个行为本身就是一个可以被充分利用的“事件”，称之为“同步”
- IPC中有个叫“事件”和“信号量”的机制，实现的就是“同步”的效果。
- 交换数据的方式可以有邮箱，消息buffer。
- 邮箱传递指针，消息buffer传递数据。

### 定时服务
- 如果说裸机和有操作系统最直接的差别，那就是操作系统可以实现无堵塞的延时操作。
- 定时器机制是实现无阻塞延时的基础，可以理解为软件定时器（只用了一个硬件定时器），以一个硬件定时器为基础，在改硬件定时器中断中维护一个系统时间，然后通过该系统时间来维护多个软件软件定时器，这些软件定时器由系统本身和各个任务所使用。
- 定时结束本身属于一种事件，在结束时刻可以一般会触发回调函数或线程切换。
- 定时器的时钟在硬件定时中断中维护，以确保系统定时器可靠准确运行。
- 采用rtos定时服务同时也可以采用轮询发生检查是否计时结束。
### 中断
- 中断是硬件系统自带的机制，触发本身就操作线程调度，如果理解了中断处理机制，也就很容易理解多线程。
- 中断发生时，硬件会自动将当前运行线程的上下文压栈保存，然后切换到中断处理程序中。当执行完中断服务程序，原有的压栈内容出栈继续执行之前的主程序。
- 中断属于硬件层面，优先级高于rtos的任务优先级。
### 任务操作
- createTask为任务分配堆栈，建立任务实体。在os初始化后，在任何位置都可以创建任务，但被创建的任务不一定立即调度。这里要取决于调度器是否启动，和当前任务与被创建任务之间的优先级关系。是否有必要设计一个一次性任务，运行结束后自动删除?如果没有创建任务就开启调度器，就可能陷死在idle任务中。
- delTask则删除当前任务，将该任务从调度列表中删除，稍后删除相应的堆栈空间。
- pauseTask暂停该任务的调度，但不删除上下文，仅不占用cpu的时间资源，但占用内存空间资源。
- copyTask复制自身任务。
### 消息机制
- 消息是重要的ipc之一，可以在任务之间传递更多的信息内容
- 消息的生产者负责消息的封装，封装的空间一般也由消息的生产者提供或主动申请，消息的消费者负责消息的解包和使用。
- 消息可以为系统预定义类型消息，有固定的格式，有可以采用自定义格式，用于用户扩展应用。
### 硬件映射
- 将应用从设备中剥离，应用部署到云端，底层只留通讯和硬件展现。应用完全在云端编写
- 例如简单的灯应用，云端呈现的硬件接口就是产品内部控制灯亮灭的管脚，本地收到管脚控制命令后控驱动灯亮灭。
### 中间件 
- os提供服务是本质，不仅提供硬件抽象出来的服务，还要有上层应用服务。
- 网络连接服务，实现基本的网络通讯，如TCP/IP，wifi，蓝牙等
- 安全服务，网络安全组件，数据加密。
- 文件系统，fatfs等
- 各大云平台接口，安全认证，注册登录，设备管理，控制及反馈接口。
### RT-Thtead
- 分为rtt和rtt nano（简化版）
- rtt具有丰富的组建网络文件系统，支持众多平台，脚本引擎做的很不错。
- 基于scons编译系统，同时支持keil，IAR和自产的rtt studio。
### AliOS Thing
- 链接阿里云平台，包含定义的数据模型
### liteos
### Tencentos tiny
------------------------------------------------
## 杂
### 很杂
- 有时候坚持也是件很痛苦的事。但遇到瓶颈，也要想办法突破。
- 35岁，莫名的门槛，怎么破怎么过。
- 专或广还是专和广，价值体现在专?是否有这样的体力和脑力?
- 深度，思考的深度很重要，you have been there before!找到根源，抽象到不能再抽，不论是编程还是其他问题。
- 人一定要有目标，目标一定要达成，刷新自己的认知，拥有更高的平台。

### i.mxrt系列
- i.mxrt1050/1020/1010/1060/1170
- RT1052是nxp推出的一款跨界mcu，600mhz主频的m7架构。
- RT1170是nxp首款1GHz的mcu。

### MOE(Minds Of Embedded system)
- 决定重写moe，重点在于各种组件的支持，服务编程者。
- 新版moe将支持各种云平台，从底层到安全到应用。
- 新版moe将支持coap，mqtt等网络中间件和ocf，hilink，阿里上层标准
- 新版moe将支持各种编程语言。
- 更多新框架，面向开发者的过往经历。
- 支持可抢占式调度内核，与协程。
- moe的设计要包含每个模块的test case，助学型os的feature不能少。
- 给自己留一个思考，在如今成熟的os一大堆，大厂也在出自己的自主os，开发者都在开发自己的os的今天，我写os是为什么。
- 大厂的os为自己的云，自己的生态服务，我的os服务谁。
- 面向开发者，背向云，让开发者仅关注应用，OS是一项整理。
- os不在是炫技的存在，内核的存在应该弱化，服务应该有很强的呈现。
- how about an ai容器?!值得考虑一下。
- 众多os中，问自己一个核心问题，OS是什么，核心技术是什么。
- 操作系统会根据时代背景加入自己的特性，从实时操作系统，到iot操作系统，下一个是什么，ai操作系统
- 提供无线化交互接口，硬件产品没有外置接口用于交互。
- 开发工具支持gcc和常用IDE，图形化配置工具，代码组建选择，硬件配置等。

### 框架
- 底层到顶层，统一标准的成本越来越高。
- 回调机制不是将操作注册到远端，而是远端对本地有若干输入后被触发的手段。
- 远端和本地端都需要有合适的异步通信功能才能保证实时性，或一方对数据实时性要求已知，比如在特定事件发生时请求数据。

### iot
- iot的意义不在于thing能建立网络，而是thing背后所交互的物理世界。thing和thing之间的关系可以有更多关联，更多意义。
- 低功耗是iot一个关键词，因为传感器是iot一个主要部分，而很大一部分传感器是电池供电，所以低功耗被提到了一个关键的位置。
#### iot云服务器
- 在云端定义一类设备能力，管理每个设备的上下行数据。
- 设备在云端的定义一般称为profile，描述了设备类型，名称，属性，能力等信息。
- 在整体结构上是一个大星型网络

### 程序
- 进程是在内存空间上看似独享实际共享的角度
- 线程是在运行时间上看似独享实际共享的角度
- 上述概念同百兆宽带，在使用的人不多的时候，确实是专享，但实际上市资源共享的，在用户很多的情况下，仍然会遇到资源不足的问题。
- 思考：程序描述的数据的流向，是动态的，如果是静态的呢？一个程序中往往保留了完整的分支，但如果应用只有一个小小的子集，程序会塌陷成什么样？这里要考虑运行态的需求，如果一个应用分支在运行中可能运行，这个分支会保留；时序也是一个重要的因素。

### 小红花计划
- 快速迭代一个产品，用于给孩子平日良好表现记上小红花
- 2019年8月30日，v0.01版本，显示小红花，按键控制图显图消
- 其实在此项目中，家长是客户，孩子是用户，如何同时讨好客户和用户，是个难题
- 一点对这个项目的思考，产品形态没有定型，确切的说我不想让以往经验限制思路，但也希望在擅长的领域中摸索，有些矛盾，但可以尝试找到平衡。其次有一定可以确定，这不是一个APP或一个单品，这里会有很多有趣的嵌入式相关的产品，比如可解锁的盒子，检测坐姿的传感器等。
- 利用小爱同学平台通过语音给宝宝记小红花。
- 整体方案音箱拾音，云端解析，命令给私云，再给网关，进而终端显示。
- 该方案可以将终端存储问题解决，小红花的数量又云端服务器统一管理，终端实时从云端获取最新数量，做到数据统一。
- 把功能打散，从系统的角度重新分配合适的位置，再定义最终的产品形态。
- 他山之石可以攻玉，一个无处安放的功能点在其他产品上却意想不到地合适。
- 机器视觉不能少，作为判定工具最合适。

### 阿骰思的故事
- 大家好，我是一个阿骰思，我的名字叫墨意
- 我开一家小店，为过往的旅客提供些便利。
- 有的需要闹钟，有的需要房间，这个我有很多，在力所能及的情况下尽力提供；
- 有的需要很多奇怪的工具，这些工具也很多，但是没法两人共用一个；
- 他们都需要一个工作室，可惜我只有一个，他们需要按规则排队使用。
- 规则简单来讲，地位高的先用，地位相同的轮流用。
- 入驻的旅客一般会在前台登个记，说明一下想要多大的房间，自己的地位。
#### 闹钟篇
- 基本所有的旅客都会需要闹钟服务，他们会事前告诉我再过多久叫其他起来去工作室工作，但也有旅客比较任性，直接给了我一个工作单，让我在规定的时间去干这些工作单上的内容。我对这类工作，简单的我就立即做了，复杂点的我会让我的助手来做，不过排队规则和旅客们一样。
- 我把每个闹钟按剩余计时由小到大顺序拍好 这样我每次检查第一个闹钟有没有到点就可以了。
- 安排闹钟的时候我会进行分组，小于1秒的，小于1分钟的和其他的，因为大多旅客喜欢这三类时间。
#### 工作室安排篇
- 
#### 旅客协作篇
-
#### 旅客留言篇
- 旅客虽然只管自己的旅程，但他们直接往往需要一些信息和信号来完成一个完整的事业。
- 我留给旅客们一些储物柜，每个柜子都有一个编号，不论旅客们之间想留言多少内容，都可以放到这个柜子里，然后仅需告诉对方柜子的编号即可。
- 我也会给他们发留言本，如果有人想把信息直接给旅客，直接在留言本下写下留言即可，每次只能写一张纸，留言本有很多页。纸的大小和页数可以和我定制。
