# 学习笔记
## 找假币
- **题目：用天平从12枚硬币中找出重量不一致的一枚假币，最少需要几次才能称出假币**
- 先平分成三堆记作A1,A2,A3，任取两堆做第一次称量，若平衡，则假币在第三堆中（情况S1-1）；若不平衡，则假币在当前的两堆中（情况S1-2）
- **S1-1：** 从真币堆中任取两枚，从假币堆中任取两枚，进行称量，若平衡，则假币在未取的两枚中（S2-1-1）;若不平衡，则假币在取出的两枚中，此时也清楚假币是重还是轻。（S2-1-2）。
- **S2-1-1：** 从已知的真币堆中取出一枚真币，在未取的两枚硬币中任取一枚进行称量，若平衡，则未取的是假币（S3-1-1-1）;若不平衡，则取用的是假币（S3-1-1-2）
- **S2-1-2：** 剩下的两枚中任取一枚，与真币称量，若平衡，则假币为未取得一枚（S3-1-2-1）; 若不平衡，则假币为取出的一枚（S3-1-2-2）

- **S1-2：** 假设不平衡的两堆为A1,A2，重量A1>A2，从A1中任取三枚A1a，A1b，A1c作为一堆，从A2中任取A2a，A2b外加A1d作为一堆进行称量，若平衡，则假币在A2c和A2d中（S2-2-1）;若第一堆>第二堆，假币在A1a，A1b，A1c中（S2-2-2）;若第一堆<第二堆，假币为A1d（S2-2-3）


- **S2-2-1：** 取一枚真币，从A2c和A2d中任取一枚进行称量，若平衡，则假币为未取的一枚（S3-2-1-1）;若不平衡，则假币为取出的一枚（S3-2-1-2）;


- **S2-2-2：** A1a，A1b，A1c中任取两枚硬币进行称量，若平衡，则假币为未取得一枚（S3-2-2-1）；若不平衡，重量重的为假币（S3-2-2-2）

- **结果：**
- S3-1-1-1
- S3-1-1-2
- S2-2-3
- S3-2-1-1
- S3-2-1-2
- S3-2-2-1
- S3-2-2-2

## 取硬币
- **题目：有20枚银币，甲乙两人依次取1~3枚硬币，取最后一枚硬币的人输，请问甲如何可以胜利**
- 取最后一枚失败，至少需要取一枚硬币，所以关键在于一定要取到倒数第二枚硬币。双方依次取，最多取三枚，两人都取一次的范围是2~6枚，其中总数为4枚是可以固定的，甲1乙3，甲2乙2，甲3乙1，这样可以确定，如果还有5枚硬币，此时留给乙来取，就可以确保最后一枚留个乙来取，不论乙怎么取，甲凑4即可。同理，只需要5+4+4+4=17，可以推导出，如果还有17个硬币，此时乙来取，甲就可以赢，这样20个硬币，甲先取，只需要取三个，这样以后乙取n个，甲只需要取4-n即可胜利。

## 排序
### 冒泡排序
- 从左至右，两两对比，小的数放左边，大的数放右边，通过比较，最终最大的数会放到最右边，每次都可以把未排序的最大数“冒泡”到最右。
- 这种排序方式原理最为简单，但流程相对繁琐，每次都需要比较，即使数据是整齐的，还是需要依次比较。
- C语言实现：
```c
int bubble_sort(int *a, int n)
{
    int i,j,temp;
    if((n <= 0)||(NULL == a))
    {
        return -1;
    }
    for(i = 0; j < n - 1; i++)
    {
        for(j = 0; j < n - 1 - i; j++)
        {
            if(a[j]>a[j+1])
            {
                temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
            }
        }
    }
    return 0;
}
```

## DFS(Deep First Search)
- 基本原则：判断边界，若达边界则退出，若不达边界则递归尝试每一种可能。
- DFS是以深度优先探索，在到达符合条件的情况下，将继续尝试以一次可行的方案，而不是将该点周围先探索一遍。
