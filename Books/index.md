# 《Python网络编程攻略》
## 第1章 套接字、IPv4和简单的客户端／服务器编程1
- 1.1 简介1 
- 1.2 打印设备名和IPv4地址2 
- 1.3 获取远程设备的IP地址4 
- 1.4 将IPv4地址转换成不同的格式5 
- 1.5 通过指定的端口和协议找到服务名6 
- 1.6 主机字节序和网络字节序之间相互转换7 
- 1.7 设定并获取默认的套接字超时时间8 
- 1.8 优雅地处理套接字错误9 
- 1.9 修改套接字发送和接收的缓冲区大小12 
- 1.10 把套接字改成阻塞或非阻塞模式13 
- 1.11 重用套接字地址14 
- 1.12 从网络时间服务器获取并打印当前时间16 
- 1.13 编写一个SNTP客户端17 
- 1.14 编写一个简单的回显客户端／服务器应用18  
## 第2章 使用多路复用套接字I／O提升性能22 
- 2.1 简介22 
- 2.2 在套接字服务器程序中使用ForkingMixIn23 
- 2.3 在套接字服务器程序中使用ThreadingMixIn25 
- 2.4 使用select.select编写一个聊天室服务器28 
- 2.5 使用select.epoll多路复用Web服务器34 
- 2.6 使用并发库Diesel多路复用回显服务器37 
## 第3章 IPv6、Unix域套接字和网络接口40 
- 3.1 简介40 
- 3.2 把本地端口转发到远程主机41 
- 3.3 通过ICMP查验网络中的主机44 
- 3.4 等待远程网络服务上线48 
- 3.5 枚举设备中的接口51 
- 3.6 找出设备中某个接口的IP地址52 
- 3.7 探测设备中的接口是否开启53 
- 3.8 检测网络中未开启的设备55 
- 3.9 使用相连的套接字执行基本的进程间通信57 
- 3.10 使用Unix域套接字执行进程间通信58 
- 3.11 确认你使用的Python是否支持IPv6套接字61 
- 3.12 从IPv6地址中提取IPv6前缀63 
- 3.13 编写一个IPv6回显客户端／服务器64 
## 第4章 HTTP协议网络编程68 
- 4.1 简介68 
- 4.2 从HTTP服务器下载数据68 
- 4.3 在你的设备中伺服HTTP请求70 
- 4.4 访问网站后提取cookie信息72 
- 4.5 提交网页表单75 
- 4.6 通过代理服务器发送Web请求77 
- 4.7 使用HEAD请求检查网页是否存在78 
- 4.8 把客户端伪装成Mozilla Firefox79  
- 4.9 使用HTTP压缩节省Web请求消耗的带宽80 
- 4.10 编写一个支持断点续传功能的HTTP容错客户端82 
- 4.11 使用Python和OpenSSL编写一个简单的HTTPS服务器84 
## 第5章 电子邮件协议、FTP和CGI编程87 
- 5.1 简介87 
- 5.2 列出FTP远程服务器中的文件87 
- 5.3 把本地文件上传到远程FTP服务器中89 
- 5.4 把当前工作目录中的内容压缩成ZIP文件后通过电子邮件发送91 
- 5.5 通过POP3协议下载谷歌电子邮件94 
- 5.6 通过IMAP协议查收远程服务器中的电子邮件95 
- 5.7 通过Gmail的SMTP服务器发送带有附件的电子邮件97 
- 5.8 使用CGI为基于Python的Web服务器编写一个留言板 99  
## 第6章 屏幕抓取和其他实用程序103 
- 6.1 简介103 
- 6.2 使用谷歌地图API搜索公司地址103 
- 6.3 使用谷歌地图URL搜索地理坐标105 
- 6.4 搜索维基百科中的文章106 
- 6.5 使用谷歌搜索股价110 
- 6.6 搜索GitHub中的源代码仓库111 
- 6.7 读取BBC的新闻订阅源114 
- 6.8 爬取网页中的链接116 
## 第7章 跨设备编程119 
- 7.1 简介119 
- 7.2 使用telnet在远程主机中执行shell命令119 
- 7.3 通过SFTP把文件复制到远程设备中121 
- 7.4 打印远程设备的CPU信息123 
- 7.5 在远程主机中安装Python包126 
- 7.6 在远程主机中运行My

--------
# 《嵌入式网络那些事》
## 前言 
## 第1章 实验平台背后的故事 1 
- 1.1 嵌入式网络技术一统江湖 1 
- 1.1.1 嵌入式网络的发展现状 1 
- 1.1.2 嵌入式LwIP协议栈 4 
- 1.2 基于STM32的实验平台浅析 6 
- 1.2.1 STM32处理器的兴起 6 
- 1.2.2 实验平台简介 9 
- 1.2.3 网卡连接情况 11 
- 1.3 本书主要内容 12 
## 第2章 LwIP协议栈初体验 15 
- 2.1 庐山真面目之LwIP代码结构 15 
- 2.1.1 LwIP简介 15 
- 2.1.2 源代码结构 17 
- 2.2 怎样用SI阅读源代码 22 
- 2.3 千里之行从LwIP框架做起 27 
- 2.3.1 协议栈分层思想 27 
- 2.3.2 进程模型 30 
- 2.3.3 协议栈编程接口 31 
## 第3章 LwIP移植初探——无操作系统模拟层 35 
- 3.1 移植说明 35 
- 3.2 移植头文件 37 
- 3.3 网卡驱动编写 40 
- 3.4 安装系统时钟 47 
- 3.5 协议栈初始化 47 
- 3.6 查询接收数据包 49 
- 3.7 数据包中断接收 51 
- 3.8 如何定位Ping问题 53 
## 第4章 内核动力之源——内存管理 55 
- 4.1 内存管理背后的故事 55 
- 4.1.1 内存管理概述 55 
- 4.1.2 常见内存分配策略 57 
- 4.2 以不变应万变——动态内存池 59 
- 4.2.1 数据结构描述 59 
- 4.2.2 函数实现 65 
- 4.3 见招拆招——动态内存堆 67 
- 4.3.1 数据结构描述 67 
- 4.3.2 函数实现 69 
- 4.4 其他内存分配策略 74 
## 第5章 网络数据包——内核血液 78 
- 5.1 数据包管理的必要性 78 
- 5.1.1 LwIP的分层特点 78 
- 5.1.2 协议进程模型 80 
- 5.2 数据包管理原理大揭密 80 
- 5.2.1 数据包结构pbuf 81 
- 5.2.2 pbuf的类型 82 
- 5.2.3 数据包申请函数 85 
- 5.2.4 数据包释放函数 88 
- 5.2.5 其他数据包操作函数 90 
## 第6章 网络抽水机——网络接口管理 92 
- 6.1 引言 92 
- 6.2 接口管理的始与末 93 
- 6.2.1 数据结构 93 
- 6.2.2 函数实现 96 
- 6.3 特殊的网络接口——环回 99 
- 6.3.1 实现原理 99 
- 6.3.2 应用程序环回通信实战 102 
- 6.4 如何动态更改IP地址 109 
- 6.4.1 重要函数 109 
- 6.4.2 实战程序 110 
## 第7章 漫漫鹊桥路——ARP协议 113 
- 7.1 ARP协议之扫盲篇 113 
- 7.1.1 物理地址与网络地址 113 
- 7.1.2 ARP协议的本质 115 
- 7.2 关键数据结构 117 
- 7.2.1 ARP表 117 
- 7.2.2 ARP报文 121 
- 7.3 ARP之数据包引进来 126 
- 7.3.1 以太网数据包递交 126 
- 7.3.2 ARP数据包处理 129 
- 7.3.3 ARP攻击 131 
- 7.3.4 ARP缓存表的更新 132 
- 7.4 ARP之数据包走出去 137 
- 7.4.1 ARP层数据处理总流程 138 
- 7.4.2 广播包与多播包的发送 138 
- 7.4.3 单播包的发送 140 
## 第8章 互联网身份证——网际协议（IP） 144 
- 8.1 IP协议之扫盲班 144 
- 8.1.1 概述 144 
- 8.1.2 IP地址 145 
- 8.1.3 特殊IP地址 147 
- 8.1.4 子网划分与子网掩码 148 
- 8.1.5 网络地址转换（NAT） 150 
- 8.1.6 单播、多播与广播 151 
- 8.2 什么是IP数据报 153 
- 8.2.1 数据报组成结构 153 
- 8.2.2 数据结构 158 
- 8.3 IP数据报之走出去 159 
- 8.3.1 发送数据报 159 
- 8.3.2 数据报分片 162 
- 8.4 IP数据报之引进来 166 
- 8.4.1 数据报接收 166 
- 8.4.2 分片重装数据结构 171 
- 8.4.3 分片重装函数 174 
- 8.4.4 分片插入与检查 178 
## 第9章 互联网医生——ICMP协议 182 
- 9.1 ICMP扫盲班 182 
- 9.1.1 ICMP协议 182 
- 9.1.2 报文交付 183 
- 9.1.3 报文类型 184 
- 9.1.4 报文格式 185 
- 9.1.5 差错报文 185 
- 9.1.6 查询报文 188 
- 9.2 ICMP实现大起底 189 
- 9.2.1 数据结构 189 
- 9.2.2 发送差错报文 191 
- 9.2.3 ICMP报文的处理 192 
- 9.2.4 ping命令 196 
- 9.2.5 ICMP洪水 197 
- 9.3 如何发送Ping请求 198 
- 9.3.1 实现原理——raw_pcb 199 
- 9.3.2 发送ping请求 200 
- 9.3.3 测试结果 203 
## 第10章 Raw API无招胜有招之UDP篇 205 
- 10.1 UDP协议扫盲班 205 
- 10.1.1 传输层协议 205 
- 10.1.2 UDP协议 206 
- 10.1.3 端口号 207 
- 10.1.4 UDP报文的交付 208 
- 10.1.5 UDP报文格式 209 
- 10.1.6 UDP伪首部与校验和 210 
- 10.2 UDP数据结构详解 212 
- 10.2.1 报文首部结构 212 
- 10.2.2 控制块 212 
- 10.3 UDP RAW编程秘籍 216 
- 10.3.1 使用UDP编程 216 
- 10.3.2 新建控制块 216 
- 10.3.3 绑定控制块 217 
- 10.3.4 连接控制块 218 
- 10.3.5 其他控制块操作函数 219 
- 10.4 UDP RAW编程初体验 220 
- 10.4.1 UDP编程秘诀 220 
- 10.4.2 回送程序 221 
- 10.4.3 测试结果 222 
- 10.4.4 回调编程的缺陷 224 
- 10.5 内核报文处理细节 224 
- 10.5.1 报文的发送 224 
- 10.5.2 报文接收与递交 228 
- 10.6 挑战更复杂的UDP应用 231 
- 10.6.1 使用TFTP传送文件 231 
- 10.6.2 应用程序实现 234 
- 10.6.3 TFTP测试结果 242 
## 第11章 Raw API无招胜有招之TCP篇 244 
- 11.1 TCP协议大揭秘 244 
- 11.1.1 TCP的必要性 244 
- 11.1.2 TCP的特性 245 
- 11.1.3 连接的定义 247 
- 11.1.4 数据流编号 248 
- 11.1.5 滑动窗口 248 
- 11.2 TCP入门——报文 249 
- 11.2.1 报文格式 249 
- 11.2.2 TCP选项 251 
- 11.2.3 紧急数据 252 
- 11.2.4 强迫数据交互 253 
- 11.2.5 报文首部数据结构 253 
- 11.3 TCP基础——连接 254 
- 11.3.1 建立连接 254 
- 11.3.2 断开连接 255 
- 11.3.3 复位连接 256 
- 11.3.4 TCP状态转换图 257 
- 11.3.5 特殊的状态转换 259 
- 11.4 TCP核心——控制块 260 
- 11.4.1 控制块数据结构 260 
- 11.4.2 控制块链表 263 
- 11.4.3 接收窗口 264 
- 11.4.4 发送窗口 264 
- 11.5 TCP RAW编程秘诀 265 
- 11.5.1 控制块新建 265 
- 11.5.2 控制块绑定 267 
- 11.5.3 控制块侦听 267 
- 11.5.4 控制块连接 268 
- 11.5.5 发送数据 270 
- 11.5.6 关闭连接 270 
- 11.5.7 其他函数 272 
- 11.6 TCP RAW编程初体验 272 
- 11.6.1 TCP编程本质 272 
- 11.6.2 HTTP服务器 278 
- 11.6.3 打不死的客户端 280 
- 11.7 TCP输出处理细节放送 283 
- 11.7.1 报文段缓冲 283 
- 11.7.2 报文段构建 285 
- 11.7.3 报文段发送 287 
- 11.8 TCP输入处理细节放送 289 
- 11.8.1 TCP层函数调用流程 289 
- 11.8.2 报文输入 291 
- 11.8.3 TIME_WAIT状态的报文处理 294 
- 11.8.4 LISTEN状态的报文处理 294 
- 11.8.5 SYN攻击 296 
- 11.8.6 TCP状态机函数 297 
- 11.8.7 TCP数据输入 301 
- 11.9 可靠的传输服务 305 
- 11.9.1 超时重传与RTT估计 306 
- 11.9.2 慢启动与拥塞避免 311 
- 11.9.3 快速重传与快速恢复 314 
- 11.9.4 糊涂窗口与避免 316 
- 11.9.5 零窗口探查 319 
- 11.9.6 保活机制 321 
- 11.9.7 TCP定时器 322 
- 11.10 挑战更复杂的TCP应用 327 
- 11.10.1 Telnet服务器 327 
- 11.10.2 测试结果 333 
## 第12章 LwIP乾坤大挪移——操作系统模拟层 335 
- 12.1 模拟层是怎样炼成的 336 
- 12.1.1 移植综述 336 
- 12.1.2 添加文件 338 
- 12.1.3 修改头文件lwipopts.h 339 
- 12.1.4 头文件sys_arch.h 339 
- 12.1.5 全局变量与初始化 340 
- 12.1.6 信号量函数 341 
- 12.1.7 邮箱函数 343 
- 12.1.8 创建新进程 348 
- 12.1.9 修改内核初始化函数 349 
- 12.1.10 移植结果测试 350 
- 12.2 Sequential API牛刀小试 350 
- 12.2.1 回显服务器 351 
- 12.2.2 Web服务器 352 
- 12.2.3 操作系统下的raw API 355 
## 第13章 Sequential API大显身手 356 
- 13.1 探秘内核定时事件 356 
- 13.1.1 定时结构 356 
- 13.1.2 定时链表 357 
- 13.1.3 内核进程 359 
- 13.1.4 处理定时事件 361 
- 13.2 论消息机制的重要性 363 
- 13.2.1 消息结构 363 
- 13.2.2 数据包消息 364 
- 13.2.3 协议栈API实现 365 
- 13.2.4 API消息 367 
- 13.3 协议栈接口全搜罗 369 
- 13.3.1 用户数据缓冲netbuf 369 
- 13.3.2 如何操作数据缓冲 371 
- 13.3.3 连接结构netconn 373 
- 13.3.4 内核回调接口 375 
- 13.3.5 协议栈API秘籍 377 
- 13.4 Sequential API大会战 383 
- 13.4.1 网页控制设备 383 
- 13.4.2 UDP性能测试 386 
- 13.4.3 TCP性能测试 388 
- 13.4.4 并发服务器 390 
## 第14章 万剑归宗之Socket编程 395 
- 14.1 套接字接口来龙去脉 395 
- 14.1.1 如何实现Socket 395 
- 14.1.2 套接字函数秘籍 397 
- 14.2 Socket实战大串烧 401 
- 14.2.1 智能的TCP客户端 402 
- 14.2.2 UDP时间服务器 404 
- 14.2.3 Winsock客户端设计 406 
- 14.3 基于Select的并发服务器 408 
- 14.3.1 神奇的Select函数 409 
- 14.3.2 Select原理全解析 410 
- 14.3.3 Select实战——并发服务器 419 
## 第15章 LwIP工程实战——物联网关 424 
- 15.1 项目背景 424 
- 15.1.1 中央空调系统与温控器 424 
- 15.1.2 新需求的出现 427 
- 15.1.3 要做什么与如何去做 430 
- 15.2 智能网络温控器 431 
- 15.2.1 温控器实现方案 431 
- 15.2.2 Modbus TCP服务器 432 
- 15.3 物联网关设计 440 
- 15.3.1 物联网关实现方案 440 
- 15.3.2 网关服务器 441 
- 15.4 现场调试与测试 446 
- 15.4.1 温控器测试 446 
- 15.4.2 物联网关测试 447 
## 第16章 天下之术皆为我用—— LwIP高级篇 449 
- 16.1 外网访问之道——域名解析 449 
- 16.1.1 域名系统（DNS） 449 
- 16.1.2 DNS牛刀小试 450 
- 16.1.3 下载外网数据 453 
- 16.2 如何自动分配IP地址——DHCP 456 
- 16.2.1 DHCP大讲堂 456 
- 16.2.2 DHCP之实现详解 458 
- 16.2.3 是骡子是马——遛遛DHCP 460 
- 16.3 如何实现组播——Internet组管理 464 
- 16.3.1 IGMP协议大讲堂 464 
- 16.3.2 IGMP组播实践 465 
## 第17章 最后的战役 468 
- 17.1 如何配置协议栈 468 
- 17.1.1 内核配置文件opt.h 468 
- 17.1.2 如何提高TCP性能 471 
- 17.2 内核调试常用方法 472 
- 17.2.1 内核日志输出 472 
- 17.2.2 网络调试助手 474 
- 17.2.3 Wireshark抓包 475 
- 17.3 为了更好的明天 476 
- 17.3.1 常见移植问题 476 
- 17.3.2 常见应用问题 478 
- 17.4 故事结局 483 
## 参考文献 484

--------------

# 《Wireshark网络分析就这么简单》
- 初试锋芒 1 
- 从一道面试题开始说起 3 
- 小试牛刀：一个简单的应用实例 10 
- Excel文件的保存过程 13 
- 你一定会喜欢的技巧 17 
- Patrick的故事 29 
- Wireshark的前世今生 32 
- 庖丁解牛 35 
- NFS协议的解析 37 
- 从Wireshark看网络分层 52 
- TCP的连接启蒙 57 
- 快递员的工作策略——TCP窗口 64 
- 重传的讲究 70 
- 延迟确认与Nagle算法 80 
- 百家争鸣 84 
- 简单的代价——UDP 90 
- 剖析CIFS协议 93 
- 网络江湖 104 
- DNS小科普 111 
- 一个古老的协议——FTP 118 
- 上网的学问——HTTP 126 
- 无懈可击的Kerberos 132 
- TCPIP的故事 141 
- 举重若轻 145 
- “一小时内给你答复” 147 
- 午夜铃声 151 
- 深藏功与名 157 
- 棋逢对手 162 
- 学无止境 167 
- 一个技术男的自白 174

----

# 《Wireshark网络分析的艺术》
- 答读者问／1 
- Linux为什么卡住了？／3 
- 像福尔摩斯一样思考／7 
- 一篇关于VMware的文章／12 
- 来点有深度的／18 
- 三次握手的小知识／22 
- 被误解的TCP／27 
- 最经典的网络问题／30 
- 为什么丢了单子？／36 
- 受损的帧／42 
- 虚惊一场／45 
- NTLM协议分析／49 
- Wireshark的提示／54 
- 工作中的Wireshark／61 
- 书上错了吗？／63 
- 计算“在途字节数”／68 
- 估算网络拥塞点／71 
- 顺便说说LSO／74 
- 熟读RFC／77 
- 一个你本该能解决的问题／82 
- 几个关于分片的问题／87 
- MTU导致的悲剧／92 
- 迎刃而解／97 
- 昙花一现的协议／100 
- 另一种流控／105 
- 过犹不及／109 
- 治疗强迫症／114 
- 技术与工龄／119 
- 如何科学地推卸责任／123 
- 一个面试建议／126 
- 生活中的Wireshark／129 
- 假宽带真相／131 
- 手机抓包／138 
- 微博为什么会卡／145 
- 寻找HttpDNS／148 
- 谁动了我的网络／155 
- 一个协议的进化／161 
- 假装产品经理／168 
- 自学的窍门／172 
- 两个项目／177 
- 打造自己的分析工具／179 
- 一个创业点子／189

--------

# 《ARM Cortex-M3与Cortex-M4权威指南(第3版)》
## 第1章ARMCortex—M处理器简介 
- 1.1什么是ARMCortex—M处理器 
- 1.1.1Cortex—M3和Cortex—M4处理器 
- 1.1.2Cortex—M处理器家族 
- 1.1.3处理器和微控制器的区别 
- 1.1.4ARM和微控制器供应商 
- 1.1.5选择Cortex—M3和Cortex—M4微控制器 
- 1.2Cortex—M处理器的优势 
- 1.2.1低功耗 
- 1.2.2性能 
- 1.2.3能耗效率 
- 1.2.4代码密度 
- 1.2.5中断 
- 1.2.6易于使用 
- 1.2.7可扩展性 
- 1.2.8调试特性 
- 1.2.9OS支持 
- 1.2.10多种系统特性 
- 1.2.11软件可移植性和可重用性 
- 1.2.12选择（设备、工具和OS等） 
- 1.3ARMCortex—M处理器应用 
- 1.4ARM处理器和ARM微控制器的资源 
- 1.4.1ARM网站上有什么 
- 1.4.2微控制器供应商提供的文档 
- 1.4.3工具供应商提供的文档 
- 1.4.4其他资源 
- 1.5背景和历史 
- 1.5.1ARM简史 
- 1.5.2ARM处理器的发展 
- 1.5.3ThumbISA的架构版本 
- 1.5.4处理器命名 
- 1.5.5关于ARM生态系统 
## 第2章嵌入式软件开发简介 
- 2.1ARM微控制器是怎样构成的 
- 2.2开始时需要准备什么 
- 2.2.1开发组件 
- 2.2.2开发板 
- 2.2.3调试适配器 
- 2.2.4软件设备驱动 
- 2.2.5例子 
- 2.2.6文档和其他资源 
- 2.2.7其他设备 
- 2.3软件开发流程 
- 2.4编译应用程序 
- 2.5软件流程 
- 2.5.1轮询 
- 2.5.2中断驱动 
- 2.5.3多任务系统 
- 2.6C程序中的数据类型 
- 2.7输入、输出和外设访问 
- 2.8微控制器接口 
- 2.9Cortex微控制器软件接口标准（CMSIS） 
- 2.9.1CMSIS简介 
- 2.9.2CMSIS—Core所做的标准化 
- 2.9.3CMSIS—Core的组织结构 
- 2.9.4如何使用CMSIS—Core 
- 2.9.5CMSIS的优势 
- 2.9.6CMSIS的多个版本 
## 第3章技术综述 
- 3.1Cortex—M3和Cortex—M4处理器的一般信息 
- 3.1.1处理器类型 
- 3.1.2处理器架构 
- 3.1.3指令集 
- 3.1.4模块框图 
- 3.1.5存储器系统 
- 3.1.6中断和异常支持 
- 3.2Cortex—M3和Cortex—M4处理器的特性 
- 3.2.1性能 
- 3.2.2代码密度 
- 3.2.3低功耗 
- 3.2.4存储器系统 
- 3.2.5存储器保护单元 
- 3.2.6中断处理 
- 3.2.7OS支持和系统级特性 
- 3.2.8Cortex—M4的特殊特性 
- 3.2.9易于使用 
- 3.2.10调试支持 
- 3.2.11可扩展性 
- 3.2.12兼容性 
## 第4章架构 
- 4.1架构简介 
- 4.2编程模型 
- 4.2.1操作模式和状态 
- 4.2.2寄存器 
- 4.2.3特殊寄存器 
- 4.2.4浮点寄存器 
- 4.3应用程序状态寄存器 
- 4.3.1整数状态标志 
- 4.3.2Q状态标志 
- 4.3.3GE位 
- 4.4存储器系统 
- 4.4.1存储器系统特性 
- 4.4.2存储器映射 
- 4.4.3栈存储 
- 4.4.4存储器保护单元（MPU） 
- 4.5异常和中断 
- 4.5.1什么是异常 
- 4.5.2嵌套向量中断控制器（NVIC） 
- 4.5.3向量表 
- 4.5.4错误处理 
- 4.6系统控制块（SCB） 
- 4.7调试 
- 4.8复位和复位流程 
## 第5章指令集 
- 5.1ARMCortex—M处理器指令集的背景简介 
- 5.2ARMCortex—M处理器间的指令集比较 
- 5.3理解汇编语言语法 
- 5.4指令后缀的使用 
- 5.5统一汇编语言（UAL） 
- 5.6指令集 
- 5.6.1处理器内传送数据 
- 5.6.2存储器访问指令 
- 5.6.3算术运算 
- 5.6.4逻辑运算 
- 5.6.5移位和循环移位指令 
- 5.6.6数据转换运算（展开和反序） 
- 5.6.7位域处理指令 
- 5.6.8比较和测试 
- 5.6.9程序流控制 
- 5.6.10饱和运算 
- 5.6.11异常相关指令 
- 5.6.12休眠模式相关指令 
- 5.6.13存储器屏障指令 
- 5.6.14其他指令 
- 5.6.15不支持的指令 
- 5.7Cortex—M4特有的指令 
- 5.7.1Cortex—M4的增强DSP扩展简介 
- 5.7.2SIMD和饱和指令 
- 5.7.3乘法和MAC指令 
- 5.7.4打包和解包 
- 5.7.5浮点指令 
- 5.8桶形移位器 
- 5.9在编程中访问特殊寄存器和特殊指令 
- 5.9.1简介 
- 5.9.2内在函数 
- 5.9.3内联汇编和嵌入汇编 
- 5.9.4使用其他的编译器相关的特性 
- 5.9.5访问特殊寄存器 
- …… 
## 第6章存储器系统 
## 第7章异常和中断 
## 第8章深入了解异常处理 
## 第9章低功耗和系统控制特性 
## 第10章OS支持特性 
## 第11章存储器保护单元 
## 第12章错误异常和错误处理 
## 第13章浮点运算 
## 第14章调试和跟踪特性 
## 第15章KeilARM微控制器开发套件入门


------

# 《ARM Cortex-M0与Cortex-M0+权威指南(第2版)》
## 第1章概论
- 1.1欢迎来到嵌入式处理器的世界
- 1.1.1处理器有什么作用
- 1.1.2处理器、CPU、内核、微控制器及其命名
- 1.1.3嵌入式系统的编程
- 1.1.4学习微控制器需要了解什么
- 1.2理解处理器的类型
- 1.2.1处理器为什么有很多种类
- 1.2.2ARM处理器家族概述
- 1.2.3模糊边界
- 1.2.4ARM CortexM处理器系列
- 1.2.5ARM CortexM0和CortexM0+处理器简介
- 1.2.6从CortexM0处理器到CortexM0+处理器
- 1.2.7CortexM0和CortexM0+处理器的应用
- 1.3微控制器内部有什么
- 1.3.1微控制器内常见部件
- 1.3.2微控制器应用的处理器的特点
- 1.3.3硅片技术
- 1.4ARM介绍
- 1.4.1ARM生产芯片吗
- 1.4.2ARM的产品是什么
- 1.4.3芯片厂商为什么不设计自己的处理器
- 1.4.4ARM生态系统有什么特殊之处
- 1.5ARM处理器和ARM微控制器方面的资源
- 1.5.1ARM主页
- 1.5.2微控制器厂商提供的资源
- 1.5.3工具厂商提供的资源
- 1.5.4其他资源
## 第2章技术综述
- 2.1CortexM0和CortexM0+处理器
- 2.2模块框图
- 2.3典型系统
- 2.4什么是ARMv6M架构
- 2.5CortexM处理器间的软件可移植性
- 2.6ARM CortexM0和CortexM0+处理器的优势
- 2.6.1低功耗和能耗效率
- 2.6.2高代码密度
- 2.6.3低中断等待和确定行为
- 2.6.4易于使用
- 2.6.5系统级特性和OS支持特性
- 2.6.6调试特性
- 2.6.7可配置性、灵活性和可扩展性
- 2.6.8软件可移植性和可重用性
- 2.6.9产品选择的多样性
- 2.6.10生态系统支持
- 2.7CortexM0和CortexM0+处理器的应用
- 2.7.1微控制器
- 2.7.2传感器
- 2.7.3传感器集线器
- 2.7.4电源管理IC
- 2.7.5ASSP和ASIC
- 2.7.6片上系统中的子系统
- 2.8为什么要在微控制器应用中使用32位处理器
- 2.8.1性能
- 2.8.2代码密度
- 2.8.3ARM架构的其他优势
- 2.8.4软件可重用性
## 第3章嵌入式软件开发介绍
- 3.1欢迎进入嵌入式系统编程
- 3.2基本概念
- 3.2.1复位
- 3.2.2时钟
- 3.2.3电压
- 3.2.4输入和输出
- 3.2.5嵌入式软件程序流程介绍
- 3.2.6编程语言选择
- 3.3ARM CortexM编程介绍
- 3.3.1C编程数据类型
- 3.3.2用C访问外设
- 3.3.3程序映像内有什么
- 3.3.4SRAM中的数据
- 3.3.5微控制器启动时会发生什么
- 3.4软件开发流程
- 3.5Cortex微控制器软件接口标准
- 3.5.1CMSIS介绍
- 3.5.2CMSISCORE所做的标准化
- 3.5.3CMSISCORE的组织
- 3.5.4使用CMSISCORE
- 3.5.5CMSIS的优势
- 3.6软件发的其他信息
## 第4章架构
- 4.1ARMv6M架构综述
- 4.1.1架构的含义
- 4.1.2ARMv6M架构背景
- 4.2编程模型
- 4.2.1操作模式和状态
- 4.2.2寄存器和特殊寄存器
- 4.2.3APSR的行为
- 4.3存储器系统
- 4.3.1概述
- 4.3.2单周期I/O接口
- 4.3.3存储器保护单元
- 4.4栈存储操作
- 4.5异常和中断
- 4.6嵌套向量中断控制器
- 4.6.1灵活的中断管理
- 4.6.2嵌套中断支持
- 4.6.3向量异常入口
- 4.6.4中断屏蔽
- 4.7系统控制块
- 4.8调试系统
- 4.9程序映像和启动流程
## 第5章指令集
- 5.1指令集是什么
- 5.2ARM和Thumb指令集背景
- 5.3汇编基础
- 5.3.1汇编语法一览
- 5.3.2后缀的使用
- 5.3.3统一汇编语言(UAL)
- 5.4指令列表
- 5.4.1处理器内传送数据
- 5.4.2存储器访问
- 5.4.3栈存储访问
- 5.4.4算术运算
- 5.4.5逻辑运算
- 5.4.6移位和循环移位运算
- 5.4.7展开和顺序反转运算
- 5.4.8程序流控制
- 5.4.9存储器屏障指令
- 5.4.10异常相关指令
- 5.4.11休眠模式特性相关指令
- 5.4.12其他指令
- 5.5伪指令
## 第6章指令使用示例
- 6.1概述
- 6.2程序控制
- 6.2.1ifthenelse
- 6.2.2循环
- 6.2.3跳转指令
- 6.2.4跳转指令的典型用法
- 6.2.5函数调用和函数返回
- 6.2.6跳转表
- 6.3数据访问
- 6.3.1简单数据访问
- 6.3.2使用存储器访问指令的例子
- 6.4数据类型转换
- 6.4.1数据大小的转换
- 6.4.2大小端转换
- 6.5数据处理
- 6.5.164位/128位加法
- 6.5.264位/128位减法
- 6.5.3整数除法
- 6.5.4无符号整数开方根
- 6.5.5位和位域计算
## 第7章存储器系统
- 7.1微控制器中的存储器系统
- 7.2CortexM0和CortexM0+处理器中的总线系统
- 7.3存储器映射
- 7.3.1概述
- 7.3.2系统级设计
- 7.4程序存储器、Bootloader和存储器重映射
- 7.4.1程序存储器和Bootloader
- 7.4.2存储器映射
- 7.5数据存储器
- 7.6小端和大端支持
- 7.7数据类型
- 7.8存储器属性和存储器访问权限
- 7.9硬件行为对编程的影响
- 7.9.1数据对齐
- 7.9.2访问非法地址
- 7.9.3多加载和存储指令的使用
- 7.9.4等待状态
## 第8章异常和中断
- 8.1异常和中断的含义
- 8.2CortexM0和CortexM0+处理器内的异常类型
- 8.2.1概述
- 8.2.2不可屏蔽中断
- 8.2.3HardFault
- 8.2.4SVC
- 8.2.5可挂起的系统调用
- 8.2.6系统节拍
- 8.2.7中断
- 8.3NVIC简介
- 8.4异常优先级定义
- 8.5向量表
- 8.6异常流程概述
- 8.6.1接受异常
- 8.6.2压栈和出栈
- 8.6.3异常返回指令
- 8.6.4末尾连锁
- 8.6.5延迟到达
- 8.7EXC_RETURN
- 8.8用于中断控制的NVIC控制寄存器
- 8.8.1NVIC控制寄存器概述
- 8.8.2中断使能和清除使能
- 8.8.3中断挂起和清除挂起
- 8.8.4中断优先级
- 8.9异常屏蔽寄存器(PRIMASK)
- 8.10中断输入和挂起行为
- 8.10.1简单中断处理
- 8.10.2简单的脉冲中断处理
- 8.10.3中断挂起状态在得到服务前取消
- 8.10.4外设在确认中断请求时清除挂起状态
- 8.10.5ISR完成后中断请求保持为高
- 8.10.6进入ISR前产生了多个中断请求脉冲
- 8.10.7在ISR执行期间产生了中断请求脉冲
- 8.10.8已禁止中断的中断请求确认
- 8.11异常入口流程
- 8.11.1压栈
- 8.11.2取出向量并更新PC
- 8.11.3更新寄存器
- 8.12异常退出流程
- 8.12.1寄存器出栈
- 8.12.2从返回地址取指并执行
- 8.13中断等待
## 第9章系统控制和低功耗特性
- 9.1系统控制寄存器简介
- 9.2SCB中的寄存器
- 9.2.1SCB中的寄存器列表
- 9.2.2CPU ID寄存器
- 9.2.3用于系统异常管理的控制寄存器
- 9.2.4向量表偏移寄存器
- 9.2.5应用中断和复位控制寄存器
- 9.2.6系统控制寄存器
- 9.2.7配置和控制寄存器
- 9.2.8系统处理控制和状态寄存器
- 9.3使用自复位特性
- 9.4使用向量表重定位特性
- 9.5低功耗特性
- 9.5.1概述
- 9.5.2休眠模式
- 9.5.3等待事件和等待中断
- 9.5.4唤醒条件
- 9.5.5退出时休眠特性
- 9.5.6唤醒中断控制器
## 第10章操作系统支持特性
- 10.1支持OS的特性概述
- 10.2嵌入式系统的操作系统介绍
- 10.3SysTick定时器
- 10.3.1SysTick寄存器
- 10.3.2设置SysTick
- 10.3.3SysTick用于时间测量
- 10.3.4将SysTick用作单发定时器
- 10.4进程栈和PSP
- 10.5SVCall异常
- 10.6PendSV
- 10.7高级话题： 在编程中使用SVC和PendSV
- 10.7.1使用SVC异常
- 10.7.2使用PendSV异常
- 10.8高级话题： 实际的上下文切换
## 第11章错误处理
- 11.1错误异常概述
- 11.2错误是如何产生的
- 11.3分析错误
- 11.4意外切换至ARM状态
- 11.5实际应用中的错误处理
- 11.6软件开发期间的错误处理
- 11.7锁定
- 11.7.1锁定的原因
- 11.7.2锁定期间发生了什么
- 11.8避免锁定
- 11.9和ARMv7M架构中错误处理的对比
## 第12章存储器保护单元
- 12.1MPU是什么
- 12.2MPU适用的情形
- 12.3技术介绍
- 12.4MPU寄存器
- 12.4.1MPU类型寄存器
- 12.4.2MPU控制寄存器
- 12.4.3MPU区域编号寄存器
- 12.4.4MPU区域基地址寄存器
- 12.4.5MPU区域基本属性和大小寄存器
- 12.5设置MPU
- 12.6存储器屏障和MPU配置
- 12.7使用子区域禁止
- 12.7.1允许高效的存储器划分
- 12.7.2减少所需的区域总数
- 12.8使用MPU时的注意事项
- 12.8.1程序代码
- 12.8.2数据存储器
- 12.9和CortexM3/M4/M7处理器的MPU间的差异
## 第13章调试特性
- 13.1软件开发和调试特性
- 13.2调试接口
- 13.2.1JTAG和串行线调试通信协议
- 13.2.2CortexM处理器和CoreSight调试架构
- 13.2.3调试接口的设计考虑
- 13.3调试特性一览
- 13.4调试系统
- 13.5暂停模式和调试事件
- 13.6利用MTB实现指令跟踪
## 第14章Keil微控制器开发套件入门
- 14.1Keil微控制器开发套件介绍
- 14.1.1概述
- 14.1.2工具
- 14.1.3Keil MDK的优势
- 14.1.4安装
- 14.2典型的程序编译流程
- 14.3硬件介绍
- 14.3.1Freescale Freedom开发板(FRDMKL25Z)
- 14.3.2STMicroelectronics STM32L0 Discovery
- 14.3.3STMicroelectronics STM32F0 Discovery
- 14.3.4NXP LPC1114FN28
- 14.4μVision IDE入门
- 14.4.1如何开始
- 14.4.2启动Keil MDK
- 14.4.3Freescale FRDMKL25Z工程设置步骤
- 14.4.4STMicroelectronics STM32L0 Discovery工程设置步骤
- 14.4.5STMicroelectronice STM32F0 Discovery工程设置步骤
- 14.4.6NXP LPC1114FN28工程设置步骤
- 14.5使用IDE和调试器
- 14.6底层内容
- 14.6.1CMSIS文件
- 14.6.2时钟设置
- 14.6.3栈和堆的设置
- 14.6.4编译
- 14.7工程环境的优化
- 14.7.1目标选项
- 14.7.2优化选项
- 14.7.3运行时环境选项
- 14.7.4工程管理
- 14.8使用模拟器
- 14.9在SRAM中执行程序
- 14.10使用MTB指令跟踪
## 第15章IAR embedded workbench for ARM入门
- 15.1IAR embedded workbench for ARM概述
- 15.2典型的程序编译流程
- 15.3创建简单的blinky工程
- 15.4工程选项
- 15.5在IAR EWARM中使用MTB指令跟踪
- 15.6提示和要点
## 第16章GCC入门
- 16.1GCC工具链
- 16.2关于本章中的例子
- 16.3典型开发流程
- 16.4创建简单的Blinky工程
- 16.5命令行选项概述
- 16.6Flash编程
- 16.7在Keil MDKARM中使用ARM嵌入式处理器GNU工具
- 16.8在CooCox IDE中使用ARM嵌入式处理器GNU工具
- 16.8.1概述和设置
- 16.8.2创建新的工程
- 16.8.3使用IDE和调试器
## 第17章mbed入门
- 17.1什么是mbed
- 17.2mbed系统是怎么工作的
- 17.3mbed的优势
- 17.4设置FRDMKL25Z板和mbed账号
- 17.4.1检查mbed Web网页
- 17.4.2注册mbed账号
- 17.4.3个人计算机的设置
- 17.5创建blinky程序
- 17.5.1只开关红色LED的简单版本
- 17.5.2利用脉宽调试控制LED
- 17.6支持的常用外设对象
- 17.7使用printf
- 17.8应用实例： 火车模型控制器
- 17.9中断
- 17.10要点和提示
## 第18章编程实例
- 18.1利用通用异步收发器来产生输出
- 18.1.1通用异步收发器通信概述
- 18.1.2微控制器上的UART配置概述
- 18.1.3配置FRDMKL25Z中的UART
- 18.1.4配置STM32L0 Discovery板中的UART
- 18.1.5配置STM32F0 Discovery板上的UART
- 18.1.6配置LPC1114FN28上的UART
- 18.2实现printf
- 18.2.1概述
- 18.2.2Keil MDK的重定向
- 18.2.3IAR EWARM的重定向
- 18.2.4GNU编译器套件的重定向
- 18.2.5IAR EWARM的半主机
- 18.2.6CoIDE的半主机
- 18.3开发输入和输出函数
- 18.3.1为何要重新开发
- 18.3.2其他接口
- 18.3.3有关scanf的其他信息
- 18.4中断编程实例
- 18.4.1中断处理概述
- 18.4.2中断控制函数概述
- 18.5应用实例： 火车模型用的另一个控制器
- 18.6CMSISCORE的不同版本
## 第19章超低功耗设计
- 19.1超低功耗使用示例
- 19.1.1概述
- 19.1.2进入休眠模式
- 19.1.3WFE与WFI
- 19.1.4利用退出时休眠特性
- 19.1.5利用挂起发送事件特性
- 19.1.6利用唤醒中断控制器
- 19.1.7利用事件通信接口
- 19.2低功耗设计要求
- 19.3能量去哪里了
- 19.4开发低功耗应用
- 19.4.1低功耗设计概述
- 19.4.2降低功耗的各种方法
- 19.4.3选择正确的方法
- 19.5调试考虑
- 19.5.1调试和低功耗
- 19.5.2调试和Flash编程的“安全模式”
- 19.5.3低电压引脚和调试接口
- 19.6低电压设备的检测
- 19.6.1ULPBench的背景
- 19.6.2ULPBenchCP概述
- 19.7Freescale KL25Z低功耗特性使用示例
- 19.7.1目标
- 19.7.2测试设置
- 19.7.3KL25Z的低功耗模式
- 19.7.4时钟设计
- 19.7.5测试设置
- 19.7.6测量结果
- 19.8LPC1114低功耗特性使用示例
- 19.8.1LPC1114FN28概述
- 19.8.2实验1:使用12MHz内部和外部晶振
- 19.8.3实验2:使用降频1MHz和100kHz
- 19.8.4其他改进
- 19.8.5利用LPC1114的深度休眠
## 第20章嵌入式OS编程
- 20.1介绍
- 20.1.1背景
- 20.1.2嵌入式OS和RTOS
- 20.1.3为什么要使用嵌入式OS
- 20.1.4CMSISRTOS的作用
- 20.1.5关于Keil RTX Kernel
- 20.1.6在Keil MDK中构建一个简单RTX实例
- 20.2RTX Kernel概述
- 20.2.1线程
- 20.2.2RTX配置
- 20.2.3深入研究第一个例子
- 20.2.4线程间通信概述
- 20.2.5信号事件通信
- 20.2.6互斥体(Mutex)
- 20.2.7信号量
- 20.2.8消息队列
- 20.2.9邮件队列
- 20.2.10内存池管理特性
- 20.2.11通用等待函数和超时数值
- 20.2.12定时器特性
- 20.2.13给非特权线程增加SVC服务
- 20.3在应用中使用RTX
- 20.4调试RTX应用
- 20.5疑难解答
- 20.5.1栈大小需求
- 20.5.2优先级
- 20.5.3利用OS错误报告
- 20.5.4OS特性配置
- 20.5.5其他问题
- 20.6其他要点和提示
- 20.6.1修改RTX_Config_CM.c
- 20.6.2线程优先级
- 20.6.3缩短等待时间
- 20.6.4其他信息
## 第21章混合语言工程
- 21.1汇编在工程开发中的应用
- 21.2汇编编程实践和AAPCS
- 21.3汇编函数概述
- 21.3.1ARM工具链
- 21.3.2GCC工具链
- 21.3.3IAR Embedded Workbench for ARM
- 21.3.4汇编函数结构
- 21.4内联汇编
- 21.4.1ARM工具链
- 21.4.2GNU编译器组件
- 21.5嵌入汇编特性(ARM工具链)
- 21.6混合语言工程
- 21.6.1概述
- 21.6.2在汇编代码中调用C函数
- 21.6.3在C代码中调用汇编函数
- 21.7在Keil MDKARM中创建汇编工程
- 21.7.1一个简单的工程
- 21.7.2Hello World
- 21.7.3其他文本输出函数
- 21.8用于中断控制的通用汇编代码
- 21.8.1使能和禁止中断
- 21.8.2设置和清除中断挂起状态
- 21.8.3设置中断优先级
- 21.9汇编语言的其他编程技巧
- 21.9.1为变量分配数据空间
- 21.9.2复杂跳转处理
- 21.10使用特殊指令
- 21.10.1CMSISCORE
- 21.10.2习语识别
## 第22章软件移植
- 22.1概述
- 22.2从8位/16位微控制器向ARM CortexM移植软件
- 22.2.1通用改动
- 22.2.2存储器需求
- 22.2.38位或16位微控制器不再适用的优化
- 22.2.4实例： 从8051移植到ARM CortexM0/CortexM0+
- 22.3ARM7TDMI和CortexM0/M0+处理器间的差异
- 22.3.1经典ARM处理器概述
- 22.3.2操作模式
- 22.3.3寄存器
- 22.3.4指令集
- 22.3.5中断
- 22.4从ARM7TDMI向CortexM0/CortexM0+处理器移植软件
- 22.4.1启动代码和向量表
- 22.4.2中断
- 22.4.3C程序代码
- 22.4.4汇编代码
- 22.4.5原子访问
- 22.4.6优化
- 22.5各种CortexM处理器间的差异
- 22.5.1概述
- 22.5.2系统模型
- 22.5.3NVIC和异常
- 22.5.4指令集
- 22.5.5系统级特性
- 22.5.6调试和跟踪特性
- 22.6在CortexM处理器间移植时的通用改动
- 22.7CortexM0/M0+和CortexM1间的软件移植
- 22.8CortexM0/M0+和CortexM3间的软件移植
- 22.9CortexM0/M0+和CortexM4/M7间的软件移植
## 第23章高级话题
- 23.1C语言实现的位数据处理
- 23.2C实现的启动代码
- 23.3栈溢出检测
- 23.3.1什么是栈溢出
- 23.3.2工具链的栈分析
- 23.3.3栈的测试分析
- 23.3.4利用存储器保护单元对栈进行限制
- 23.3.5OS上下文切换期间的栈检测
- 23.4中断服务程序重入
- 23.5信号量设计
- 23.6存储器顺序和存储器屏障
## 附录A指令集快速参考
## 附录B异常类型快速参考
- B.1异常类型
- B.2异常压栈后栈的内容
## 附录C CMSIS-CORE快速参考
- C.1数据类型
- C.2异常枚举
- C.3嵌套向量中断控制器访问函数
- C.4系统和SysTick操作函数
- C.5内核寄存器操作函数
- C.6特殊指令操作函数
## 附录DNVIC、SCB和SysTick寄存器快速参考
- D.1NVIC寄存器一览
- D.2中断设置使能寄存器(NVICISER)
- D.3中断清除使能寄存器(NVICICER)
- D.4中断设置挂起寄存器(NVICISPR)
- D.5中断清除挂起寄存器(NVICICPR)
- D.6中断优先级寄存器(NVICIRQ［0］到NVICIRQ［7］)
- D.7SCB寄存器一览
- D.8CPU ID寄存器(SCBCPUID)
- D.9中断控制状态寄存器(SCBICSR)
- D.10向量表偏移寄存器(SCBVTOR，0xE000ED08)
- D.11应用中断和控制状态寄存器(SCBAIRCR)
- D.12系统控制寄存器(SCBSCR)
- D.13配置控制寄存器(SCBCCR)
- D.14系统处理优先级寄存器2(SCBSHR［0］)
- D.15系统处理优先级寄存器3(SCBSHR［1］)
- D.16系统处理控制和状态寄存器
- D.17SysTick寄存器一览
- D.18SysTick控制和状态寄存器(SysTickCTRL)
- D.19SysTick重装载值寄存器(SysTickLOAD)
- D.20SysTick当前值寄存器(SysTickVAL)
- D.21SysTick校准值寄存器(SysTickCALIB)
## 附录E调试寄存器快速参考
- E.1内核调试寄存器
- E.2断点单元
- E.3数据监视点单元
- E.4ROM表寄存器
- E.5微跟踪缓冲
- E.6POSITION寄存器
- E.7MASTER寄存器
- E.8FLOW寄存器
- E.9BASE寄存器
- E.10包格式
- E.11实例
## 附录F调试接头分配
- F.110针Cortex调试连接头
- F.220针Cortex调试+ETM接头
- F.3老式的20针IDC接头排列
## 附录G疑难解答
- G.1程序不运行/启动
- G.1.1向量表丢失或位置错误
- G.1.2使用了错误的C启动代码
- G.1.3复位向量中的值错误
- G.1.4程序映像没有被正确地编程到Flash中
- G.1.5错误的工具链配置
- G.1.6错误的栈指针初始值
- G.1.7错误的大小端设置
- G.2程序启动，却进入了硬件错误
- G.2.1非法存储器访问
- G.2.2非对齐数据访问
- G.2.3存储器访问权限(只限于CortexM0+处理器)
- G.2.4从总线返回错误
- G.2.5异常处理中的栈被破坏
- G.2.6程序在某些C函数中崩溃
- G.2.7意外地试图切换至ARM状态
- G.2.8在错误的优先级上执行SVC
- G.3休眠问题
- G.3.1执行WFE不进入休眠
- G.3.2退出时休眠过早地引起休眠
- G.3.3中断已经在挂起态时SEVONPEND不工作
- G.3.4由于休眠模式可能禁止了某些时钟，处理器无法唤醒
- G.3.5竞态
- G.4中断问题
- G.4.1执行了多余的中断处理
- G.4.2执行了多余的SysTick处理
- G.4.3在中断处理中禁止中断
- G.4.4错误的中断返回指令
- G.4.5异常优先级设置的数值
- G.5其他问题
- G.5.1错误的SVC参数传递方法
- G.5.2调试连接受到I/O设置或低功耗模式的影响
- G.5.3调试协议选择/配置
- G.5.4使用事件输出作为脉冲I/O
- G.5.5向量表和代码位置的设备实际需求
- G.6其他可能的编程陷阱
- G.6.1中断优先级
- G.6.2同时使用主栈和进程栈时的栈溢出
- G.6.3数据对齐
- G.6.4丢失volatile关键字
- G.6.5函数指针
- G.6.6读修改写
- G.6.7中断禁止
- G.6.8SystemInit函数
- G.6.9断点和内联

-------------

# 《Python基础教程(第3版)》
## 第 1 章 快速上手：基础知识
- 1.1 交互式解释器
- 1.2 算法是什么
- 1.3 数和表达式
- 1.4 变量
- 1.5 语句
- 1.6 获取用户输入
- 1.7 函数
- 1.8 模块
- 1.8.1 cmath和复数
- 1.8.2 回到未来
- 1.9 保存并执行程序
- 1.9.1 从命令提示符运行 Python 脚本
- 1.9.2 让脚本像普通程序一样
- 1.9.3 注释
- 1.10 字符串
- 1.10.1 单引号字符串以及对引号转义
- 1.10.2 拼接字符串
- 1.10.3 字符串表示 str和 repr
- 1.10.4 长字符串、原始字符串和字节
- 1.11 小结
- 1.11.1 本章介绍的新函数
- 1.11.2 预告
## 第 2 章 列表和元组
- 2.1 序列概述
- 2.2 通用的序列操作
- 2.2.1 索引
- 2.2.2 切片
- 2.2.3 序列相加
- 2.2.4 乘法
- 2.2.5 成员资格
- 2.3 列表：Python的主力
- 2.3.1 函数 list
- 2.3.2 基本的列表操作
- 2.3.3 列表方法
- 2.4 元组：不可修改的序列
- 2.5 小结
- 2.5.1 本章介绍的新函数
- 2.5.2 预告
## 第 3 章 使用字符串
- 3.1 字符串基本操作
- 3.2 设置字符串的格式：精简版
- 3.3 设置字符串的格式：完整版
- 3.3.1 替换字段名
- 3.3.2 基本转换
- 3.3.3 宽度、精度和千位分隔符
- 3.3.4 符号、对齐和用 0填充
- 3.4 字符串方法
- 3.4.1 center
- 3.4.2 find
- 3.4.3 join
- 3.4.4 lower
- 3.4.5 replace
- 3.4.6 split
- 3.4.7 strip
- 3.4.8 translate
- 3.4.9 判断字符串是否满足特定的条件
- 3.5 小结
- 3.5.1 本章介绍的新函数
- 3.5.2 预告
## 第 4 章 当索引不通时
- 4.1 字典的用途
- 4.2 创建和使用字典
- 4.2.1 函数 dict
- 4.2.2 基本的字典操作
- 4.2.3 将字符串格式设置功能用于字典
- 4.2.4 字典方法
- 4.3 小结
- 4.3.1 本章介绍的新函数
- 4.3.2 预告
## 第 5 章 条件、循环及其他语句
- 5.1 再谈 print和 import
- 5.1.1 打印多个参数
- 5.1.2 导入时重命名
- 5.2 赋值魔法
- 5.2.1 序列解包
- 5.2.2 链式赋值
- 5.2.3 增强赋值
- 5.3 代码块：缩进的乐趣
- 5.4 条件和条件语句
- 5.4.1 这正是布尔值的用武之地
- 5.4.2 有条件地执行和 if语句
- 5.4.3 else子句
- 5.4.4 elif子句
- 5.4.5 代码块嵌套
- 5.4.6 更复杂的条件
- 5.4.7 断言
- 5.5 循环
- 5.5.1 while循环
- 5.5.2 for循环
- 5.5.3 迭代字典
- 5.5.4 一些迭代工具
- 5.5.5 跳出循环 
- 5.5.6 循环中的 else子句
- 5.6 简单推导
- 5.7 三人行
- 5.7.1 什么都不做
- 5.7.2 使用 del删除
- 5.7.3 使用 exec和 eval执行字符串及计算其结果
- 5.8 小结
- 5.8.1 本章介绍的新函数
- 5.8.2 预告
## 第 6 章 抽象
- 6.1 懒惰是一种美德
- 6.2 抽象和结构
- 6.3 自定义函数
- 6.3.1 给函数编写文档
- 6.3.2 其实并不是函数的函数
- 6.4 参数魔法
- 6.4.1 值从哪里来
- 6.4.2 我能修改参数吗
- 6.4.3 关键字参数和默认值
- 6.4.4 收集参数
- 6.4.5 分配参数
- 6.4.6 练习使用参数
- 6.5 作用域
- 6.6 递归
- 6.6.1 两个经典案例：阶乘和幂
- 6.6.2 另一个经典案例：二分查找
- 6.7 小结
- 6.7.1 本章介绍的新函数
- 6.7.2 预告
## 第 7 章 再谈抽象
- 7.1 对象魔法
- 7.1.1 多态
- 7.1.2 多态和方法
- 7.1.3 封装
- 7.1.4 继承
- 7.2 类
- 7.2.1 类到底是什么
- 7.2.2 创建自定义类
- 7.2.3 属性、函数和方法
- 7.2.4 再谈隐藏
- 7.2.5 类的命名空间
- 7.2.6 指定超类
- 7.2.7 深入探讨继承
- 7.2.8 多个超类
- 7.2.9 接口和内省
- 7.2.10 抽象基类
- 7.3 关于面向对象设计的一些思考
- 7.4 小结
- 7.4.1 本章介绍的新函数
- 7.4.2 预告
## 第 8 章 异常
- 8.1 异常是什么
- 8.2 让事情沿你指定的轨道出错
- 8.2.1 raise语句
- 8.2.2 自定义的异常类
- 8.3 捕获异常
- 8.3.1 不用提供参数
- 8.3.2 多个 except子句
- 8.3.3 一箭双雕
- 8.3.4 捕获对象
- 8.3.5 一网打尽
- 8.3.6 万事大吉时
- 8.3.7 最后
- 8.4 异常和函数
- 8.5 异常之禅
- 8.6 不那么异常的情况
- 8.7 小结
- 8.7.1 本章介绍的新函数
- 8.7.2 预告
## 第 9 章 魔法方法、特性和迭代器
- 9.1 如果你使用的不是 Python 3
- 9.2 构造函数
- 9.2.1 重写普通方法和特殊的构造函数
- 9.2.2 调用未关联的超类构造函数
- 9.2.3 使用函数 super
- 9.3 元素访问
- 9.3.1 基本的序列和映射协议
- 9.3.2 从 list、dict和 str派生
- 9.4 其他魔法方法
- 9.5 特性
- 9.5.1 函数 property
- 9.5.2 静态方法和类方法
- 9.5.3 \_\_getattr\_\_、\_\_setattr\_\_等方法
- 9.6 迭代器
- 9.6.1 迭代器协议
- 9.6.2 从迭代器创建序列
- 9.7 生成器
- 9.7.1 创建生成器
- 9.7.2 递归式生成器
- 9.7.3 通用生成器
- 9.7.4 生成器的方法
- 9.7.5 模拟生成器
- 9.8 八皇后问题
- 9.8.1 生成器的回溯
- 9.8.2 问题
- 9.8.3 状态表示
- 9.8.4 检测冲突
- 9.8.5 基线条件
- 9.8.6 递归条件
- 9.8.7 扫尾工作
- 9.9 小结
- 9.9.1 本章介绍的新函数
- 9.9.2 预告
## 第 10 章开箱即用
- 10.1 模块
- 10.1.1 模块就是程序
- 10.1.2 模块是用来下定义的
- 10.1.3 让模块可用
- 10.1.4 包
- 10.2 探索模块
- 10.2.1 模块包含什么
- 10.2.2 使用 help获取帮助
- 10.2.3 文档
- 10.2.4 使用源代码
- 10.3 标准库：一些深受欢迎的模块
- 10.3.1 sys
- 10.3.2 os
- 10.3.3 fileinput
- 10.3.4 集合、堆和双端队列
- 10.3.5 time
- 10.3.6 random
- 10.3.7 shelve和 json
- 10.3.8 re
- 10.3.9 其他有趣的标准模块
- 10.4 小结
- 10.4.1 本章介绍的新函数
- 10.4.2 预告
## 第 11 章 文件
- 11.1 打开文件
- 11.2 文件的基本方法
- 11.2.1 读取和写入
- 11.2.2 使用管道重定向输出
- 11.2.3 读取和写入行
- 11.2.4 关闭文件
- 1.2.5 使用文件的基本方法
- 11.3 迭代文件内容
- 11.3.1 每次一个字符（或字节）
- 11.3.2 每次一行
- 11.3.3 读取所有内容
- 11.3.4 使用 fileinput实现延迟行迭代
- 11.3.5 文件迭代器
- 11.4 小结
- 11.4.1 本章介绍的新函数
- 11.4.2 预告
## 第 12 章 图形用户界面
- 12.1 创建 GUI示例应用程序
- 12.1.1 初探
- 12.1.2 布局
- 12.1.3 事件处理
- 12.1.4 最终的程序
- 12.2 使用其他 GUI工具包
- 12.3 小结
## 第 13 章 数据库支持
- 13.1 Python数据库 API
- 13.1.1 全局变量
- 13.1.2 异常
- 13.1.3 连接和游标
- 13.1.4 类型
- 13.2 SQLite和 PySQLite
- 13.2.1 起步
- 13.2.2 数据库应用程序示例
- 13.3 小结
- 13.3.1 本章介绍的新函数
- 13.3.2 预告
## 第 14 章 网络编程
- 14.1 几个网络模块
- 14.1.1 模块 socket
- 14.1.2 模块 urllib和 urllib2
- 14.1.3 其他模块
- 14.2 SocketServer及相关的类
- 14.3 多个连接
- 14.3.1 使用 SocketServer实现
- 分叉和线程化
- 14.3.2 使用 select和 poll实现
- 异步 I/O
- 14.4 Twisted
- 14.4.1 下载并安装 Twisted
- 14.4.2 编写 Twisted服务器
- 14.5 小结
- 14.5.1 本章介绍的新函数
- 14.5.2 预告
## 第 15 章 Python和 Web
- 15.1 屏幕抓取
- 15.1.1 Tidy和 XHTML解析
- 15.1.2 Beautiful Soup
- 15.2 使用 CGI创建动态网页 
- 15.2.1 第一步：准备 Web服务器
- 15.2.2 第二步：添加 !#行
- 15.2.3 第三步：设置文件权限
- 15.2.4 CGI安全风险
- 15.2.5 简单的 CGI脚本
- 15.2.6 使用 cgitb进行调试
- 15.2.7 使用模块 cgi
- 15.2.8 简单的表单
- 15.3 使用 Web框架
- 15.4 Web服务：更高级的抓取
- 15.4.1 RSS和相关内容
- 15.4.2 使用 XML-RPC进行远程过程调用
- 15.4.3 SOAP
- 15.5 小结
- 15.5.1 本章介绍的新函数
- 15.5.2 预告
## 第 16 章 测试基础
- 16.1 先测试再编码
- 16.1.1 准确的需求说明
- 16.1.2 做好应对变化的准备
- 16.1.3 测试四步曲
- 16.2 测试工具
- 16.2.1 doctest
- 16.2.2 unittest
- 16.3 超越单元测试
- 16.3.1 使用 PyChecker和 PyLint检查源代码
- 16.3.2 性能分析
- 16.4 小结
- 16.4.1 本章介绍的新函数
- 16.4.2 预告
## 第 17 章 扩展 Python
- 17.1 鱼和熊掌兼得
- 17.2 简单易行的方式： Jython和IronPython
- 17.3 编写 C语言扩展
- 17.3.1 SWIG
- 17.3.2 手工编写扩展
- 17.4 小结
- 17.4.1 本章介绍的新函数
- 17.4.2 预告
## 第 18 章 程序打包
- 18.1 Setuptools基础
- 18.2 打包
- 18.3 编译扩展
- 18.4 使用 py2exe创建可执行程序
- 18.5 小结
- 18.5.1 本章介绍的新函数
- 18.5.2 预告
## 第 19 章 趣味编程
- 19.1 为何要有趣
- 19.2 编程柔术
- 19.3 原型设计
- 19.4 配置 
- 19.4.1 提取常量
- 19.4.2 配置文件
- 19.5 日志
- 19.6 如果你已不胜其烦
- 19.7 如果你想深入学习
- 19.8 小结 
## 第 20 章 项目 1：自动添加标签
- 20.1 问题描述
- 20.2 有用的工具
- 20.3 准备工作
- 20.4 初次实现
- 20.4.1 找出文本块
- 20.4.2 添加一些标记
- 20.5 再次实现
- 20.5.1 处理程序
- 20.5.2 处理程序的超类
- 20.5.3 规则
- 20.5.4 规则的超类
- 20.5.5 过滤器
- 20.5.6 解析器
- 20.5.7 创建规则和过滤器
- 20.5.8 整合起来
- 20.6 进一步探索
## 第 21 章 项目 2：绘制图表
- 21.1 问题描述
- 21.2 有用的工具
- 21.3 准备工作
- 21.4 初次实现
- 21.4.1 使用 ReportLab绘图
- 21.4.2 绘制折线
- 21.4.3 编写原型
- 21.5 再次实现
- 21.5.1 获取数据
- 21.5.2 使用 LinePlot类
- 21.6 进一步探索
## 第 22 章 项目 3：万能的 XML
- 22.1 问题描述
- 22.2 有用的工具
- 22.3 准备工作
- 22.4 初次实现
- 22.4.1 创建简单的内容处理程序
- 22.4.2 创建 HTML页面
- 22.5 再次实现
- 22.5.1 分派器混合类
- 22.5.2 将首部和尾部写入文件的方法以及默认处理程序
- 22.5.3 支持目录
- 22.5.4 事件处理程序
- 22.6 进一步探索
## 第 23 章 项目 4：新闻汇总
- 23.1 问题描述
- 23.2 有用的工具
- 23.3 准备工作
- 23.4 初次实现
- 23.5 再次实现
- 23.6 进一步探索
## 第 24 章 项目 5：虚拟茶话会
- 24.1 问题描述
- 24.2 有用的工具
- 24.3 准备工作
- 24.4 初次实现
- 24.4.1 ChatServer类
- 24.4.2 ChatSession类
- 24.4.3 整合起来
- 24.5 再次实现 
- 24.5.1 基本的命令解释功能
- 24.5.2 聊天室
- 24.5.3 登录和退出聊天室
- 24.5.4 主聊天室
- 24.5.5 新的服务器
- 24.6 进一步探索
- 第 25 章 项目 6：使用 CGI进行远程编辑
- 25.1 问题描述
- 25.2 有用的工具
- 25.3 准备工作
- 25.4 初次实现
- 25.5 再次实现
- 25.5.1 创建文件名表单
- 25.5.2 编写编辑器脚本
- 25.5.3 编写保存脚本
- 25.5.4 运行编辑器
- 25.6 进一步探索
## 第 26 章 项目 7：自建公告板
- 26.1 问题描述
- 26.2 有用的工具
- 26.3 准备工作
- 26.4 初次实现
- 26.5 再次实现 
- 26.5.1 编写脚本 main.cgi
- 26.5.2 编写脚本 view.cgi
- 26.5.3 编写脚本 edit.cgi
- 26.5.4 编写脚本 save.cgi
- 26.5.5 尝试使用
- 26.6 进一步探索
## 第 27 章 项目 8：使用 XML-RPC共享文件
- 27.1 问题描述
- 27.2 有用的工具
- 27.3 准备工作
- 27.4 初次实现
- 27.4.1 实现简单的节点
- 27.4.2 尝试使用
- 27.5 再次实现
- 27.5.1 创建客户端界面
- 27.5.2 引发异常
- 27.5.3 验证文件名
- 27.5.4 尝试使用 
- 27.6 进一步探索 
## 第 28 章 项目 9：使用 GUI共享文件
- 28.1 问题描述
- 28.2 有用的工具 
- 28.3 准备工作
- 28.4 初次实现
- 28.5 再次实现
- 28.6 进一步探索
## 第 29 章 项目 10：自制街机游戏
- 29.1 问题描述
- 29.2 有用的工具 
- 29.2.1 pygame
- 29.2.2 pygame.locals 
- 29.2.3 pygame.display 
- 29.2.4 pygame.font 
- 29.2.5 pygame.sprite 
- 29.2.6 pygame.mouse 
- 29.2.7 pygame.event 
- 29.2.8 pygame.image 
- 29.3 准备工作
- 29.4 初次实现
- 29.5 再次实现
- 29.6 进一步探索
## 附录 A简明教程
## 附录 B Python参考手册
