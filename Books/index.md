# 《Python网络编程攻略》
## 第1章 套接字、IPv4和简单的客户端／服务器编程1
- 1.1 简介1 
- 1.2 打印设备名和IPv4地址2 
- 1.3 获取远程设备的IP地址4 
- 1.4 将IPv4地址转换成不同的格式5 
- 1.5 通过指定的端口和协议找到服务名6 
- 1.6 主机字节序和网络字节序之间相互转换7 
- 1.7 设定并获取默认的套接字超时时间8 
- 1.8 优雅地处理套接字错误9 
- 1.9 修改套接字发送和接收的缓冲区大小12 
- 1.10 把套接字改成阻塞或非阻塞模式13 
- 1.11 重用套接字地址14 
- 1.12 从网络时间服务器获取并打印当前时间16 
- 1.13 编写一个SNTP客户端17 
- 1.14 编写一个简单的回显客户端／服务器应用18  
## 第2章 使用多路复用套接字I／O提升性能22 
- 2.1 简介22 
- 2.2 在套接字服务器程序中使用ForkingMixIn23 
- 2.3 在套接字服务器程序中使用ThreadingMixIn25 
- 2.4 使用select.select编写一个聊天室服务器28 
- 2.5 使用select.epoll多路复用Web服务器34 
- 2.6 使用并发库Diesel多路复用回显服务器37 
## 第3章 IPv6、Unix域套接字和网络接口40 
- 3.1 简介40 
- 3.2 把本地端口转发到远程主机41 
- 3.3 通过ICMP查验网络中的主机44 
- 3.4 等待远程网络服务上线48 
- 3.5 枚举设备中的接口51 
- 3.6 找出设备中某个接口的IP地址52 
- 3.7 探测设备中的接口是否开启53 
- 3.8 检测网络中未开启的设备55 
- 3.9 使用相连的套接字执行基本的进程间通信57 
- 3.10 使用Unix域套接字执行进程间通信58 
- 3.11 确认你使用的Python是否支持IPv6套接字61 
- 3.12 从IPv6地址中提取IPv6前缀63 
- 3.13 编写一个IPv6回显客户端／服务器64 
## 第4章 HTTP协议网络编程68 
- 4.1 简介68 
- 4.2 从HTTP服务器下载数据68 
- 4.3 在你的设备中伺服HTTP请求70 
- 4.4 访问网站后提取cookie信息72 
- 4.5 提交网页表单75 
- 4.6 通过代理服务器发送Web请求77 
- 4.7 使用HEAD请求检查网页是否存在78 
- 4.8 把客户端伪装成Mozilla Firefox79  
- 4.9 使用HTTP压缩节省Web请求消耗的带宽80 
- 4.10 编写一个支持断点续传功能的HTTP容错客户端82 
- 4.11 使用Python和OpenSSL编写一个简单的HTTPS服务器84 
## 第5章 电子邮件协议、FTP和CGI编程87 
- 5.1 简介87 
- 5.2 列出FTP远程服务器中的文件87 
- 5.3 把本地文件上传到远程FTP服务器中89 
- 5.4 把当前工作目录中的内容压缩成ZIP文件后通过电子邮件发送91 
- 5.5 通过POP3协议下载谷歌电子邮件94 
- 5.6 通过IMAP协议查收远程服务器中的电子邮件95 
- 5.7 通过Gmail的SMTP服务器发送带有附件的电子邮件97 
- 5.8 使用CGI为基于Python的Web服务器编写一个留言板 99  
## 第6章 屏幕抓取和其他实用程序103 
- 6.1 简介103 
- 6.2 使用谷歌地图API搜索公司地址103 
- 6.3 使用谷歌地图URL搜索地理坐标105 
- 6.4 搜索维基百科中的文章106 
- 6.5 使用谷歌搜索股价110 
- 6.6 搜索GitHub中的源代码仓库111 
- 6.7 读取BBC的新闻订阅源114 
- 6.8 爬取网页中的链接116 
## 第7章 跨设备编程119 
- 7.1 简介119 
- 7.2 使用telnet在远程主机中执行shell命令119 
- 7.3 通过SFTP把文件复制到远程设备中121 
- 7.4 打印远程设备的CPU信息123 
- 7.5 在远程主机中安装Python包126 
- 7.6 在远程主机中运行My

--------
# 《嵌入式网络那些事》
## 前言 
## 第1章 实验平台背后的故事 1 
- 1.1 嵌入式网络技术一统江湖 1 
- 1.1.1 嵌入式网络的发展现状 1 
- 1.1.2 嵌入式LwIP协议栈 4 
- 1.2 基于STM32的实验平台浅析 6 
- 1.2.1 STM32处理器的兴起 6 
- 1.2.2 实验平台简介 9 
- 1.2.3 网卡连接情况 11 
- 1.3 本书主要内容 12 
## 第2章 LwIP协议栈初体验 15 
- 2.1 庐山真面目之LwIP代码结构 15 
- 2.1.1 LwIP简介 15 
- 2.1.2 源代码结构 17 
- 2.2 怎样用SI阅读源代码 22 
- 2.3 千里之行从LwIP框架做起 27 
- 2.3.1 协议栈分层思想 27 
- 2.3.2 进程模型 30 
- 2.3.3 协议栈编程接口 31 
## 第3章 LwIP移植初探——无操作系统模拟层 35 
- 3.1 移植说明 35 
- 3.2 移植头文件 37 
- 3.3 网卡驱动编写 40 
- 3.4 安装系统时钟 47 
- 3.5 协议栈初始化 47 
- 3.6 查询接收数据包 49 
- 3.7 数据包中断接收 51 
- 3.8 如何定位Ping问题 53 
## 第4章 内核动力之源——内存管理 55 
- 4.1 内存管理背后的故事 55 
- 4.1.1 内存管理概述 55 
- 4.1.2 常见内存分配策略 57 
- 4.2 以不变应万变——动态内存池 59 
- 4.2.1 数据结构描述 59 
- 4.2.2 函数实现 65 
- 4.3 见招拆招——动态内存堆 67 
- 4.3.1 数据结构描述 67 
- 4.3.2 函数实现 69 
- 4.4 其他内存分配策略 74 
## 第5章 网络数据包——内核血液 78 
- 5.1 数据包管理的必要性 78 
- 5.1.1 LwIP的分层特点 78 
- 5.1.2 协议进程模型 80 
- 5.2 数据包管理原理大揭密 80 
- 5.2.1 数据包结构pbuf 81 
- 5.2.2 pbuf的类型 82 
- 5.2.3 数据包申请函数 85 
- 5.2.4 数据包释放函数 88 
- 5.2.5 其他数据包操作函数 90 
## 第6章 网络抽水机——网络接口管理 92 
- 6.1 引言 92 
- 6.2 接口管理的始与末 93 
- 6.2.1 数据结构 93 
- 6.2.2 函数实现 96 
- 6.3 特殊的网络接口——环回 99 
- 6.3.1 实现原理 99 
- 6.3.2 应用程序环回通信实战 102 
- 6.4 如何动态更改IP地址 109 
- 6.4.1 重要函数 109 
- 6.4.2 实战程序 110 
## 第7章 漫漫鹊桥路——ARP协议 113 
- 7.1 ARP协议之扫盲篇 113 
- 7.1.1 物理地址与网络地址 113 
- 7.1.2 ARP协议的本质 115 
- 7.2 关键数据结构 117 
- 7.2.1 ARP表 117 
- 7.2.2 ARP报文 121 
- 7.3 ARP之数据包引进来 126 
- 7.3.1 以太网数据包递交 126 
- 7.3.2 ARP数据包处理 129 
- 7.3.3 ARP攻击 131 
- 7.3.4 ARP缓存表的更新 132 
- 7.4 ARP之数据包走出去 137 
- 7.4.1 ARP层数据处理总流程 138 
- 7.4.2 广播包与多播包的发送 138 
- 7.4.3 单播包的发送 140 
## 第8章 互联网身份证——网际协议（IP） 144 
- 8.1 IP协议之扫盲班 144 
- 8.1.1 概述 144 
- 8.1.2 IP地址 145 
- 8.1.3 特殊IP地址 147 
- 8.1.4 子网划分与子网掩码 148 
- 8.1.5 网络地址转换（NAT） 150 
- 8.1.6 单播、多播与广播 151 
- 8.2 什么是IP数据报 153 
- 8.2.1 数据报组成结构 153 
- 8.2.2 数据结构 158 
- 8.3 IP数据报之走出去 159 
- 8.3.1 发送数据报 159 
- 8.3.2 数据报分片 162 
- 8.4 IP数据报之引进来 166 
- 8.4.1 数据报接收 166 
- 8.4.2 分片重装数据结构 171 
- 8.4.3 分片重装函数 174 
- 8.4.4 分片插入与检查 178 
## 第9章 互联网医生——ICMP协议 182 
- 9.1 ICMP扫盲班 182 
- 9.1.1 ICMP协议 182 
- 9.1.2 报文交付 183 
- 9.1.3 报文类型 184 
- 9.1.4 报文格式 185 
- 9.1.5 差错报文 185 
- 9.1.6 查询报文 188 
- 9.2 ICMP实现大起底 189 
- 9.2.1 数据结构 189 
- 9.2.2 发送差错报文 191 
- 9.2.3 ICMP报文的处理 192 
- 9.2.4 ping命令 196 
- 9.2.5 ICMP洪水 197 
- 9.3 如何发送Ping请求 198 
- 9.3.1 实现原理——raw_pcb 199 
- 9.3.2 发送ping请求 200 
- 9.3.3 测试结果 203 
## 第10章 Raw API无招胜有招之UDP篇 205 
- 10.1 UDP协议扫盲班 205 
- 10.1.1 传输层协议 205 
- 10.1.2 UDP协议 206 
- 10.1.3 端口号 207 
- 10.1.4 UDP报文的交付 208 
- 10.1.5 UDP报文格式 209 
- 10.1.6 UDP伪首部与校验和 210 
- 10.2 UDP数据结构详解 212 
- 10.2.1 报文首部结构 212 
- 10.2.2 控制块 212 
- 10.3 UDP RAW编程秘籍 216 
- 10.3.1 使用UDP编程 216 
- 10.3.2 新建控制块 216 
- 10.3.3 绑定控制块 217 
- 10.3.4 连接控制块 218 
- 10.3.5 其他控制块操作函数 219 
- 10.4 UDP RAW编程初体验 220 
- 10.4.1 UDP编程秘诀 220 
- 10.4.2 回送程序 221 
- 10.4.3 测试结果 222 
- 10.4.4 回调编程的缺陷 224 
- 10.5 内核报文处理细节 224 
- 10.5.1 报文的发送 224 
- 10.5.2 报文接收与递交 228 
- 10.6 挑战更复杂的UDP应用 231 
- 10.6.1 使用TFTP传送文件 231 
- 10.6.2 应用程序实现 234 
- 10.6.3 TFTP测试结果 242 
## 第11章 Raw API无招胜有招之TCP篇 244 
- 11.1 TCP协议大揭秘 244 
- 11.1.1 TCP的必要性 244 
- 11.1.2 TCP的特性 245 
- 11.1.3 连接的定义 247 
- 11.1.4 数据流编号 248 
- 11.1.5 滑动窗口 248 
- 11.2 TCP入门——报文 249 
- 11.2.1 报文格式 249 
- 11.2.2 TCP选项 251 
- 11.2.3 紧急数据 252 
- 11.2.4 强迫数据交互 253 
- 11.2.5 报文首部数据结构 253 
- 11.3 TCP基础——连接 254 
- 11.3.1 建立连接 254 
- 11.3.2 断开连接 255 
- 11.3.3 复位连接 256 
- 11.3.4 TCP状态转换图 257 
- 11.3.5 特殊的状态转换 259 
- 11.4 TCP核心——控制块 260 
- 11.4.1 控制块数据结构 260 
- 11.4.2 控制块链表 263 
- 11.4.3 接收窗口 264 
- 11.4.4 发送窗口 264 
- 11.5 TCP RAW编程秘诀 265 
- 11.5.1 控制块新建 265 
- 11.5.2 控制块绑定 267 
- 11.5.3 控制块侦听 267 
- 11.5.4 控制块连接 268 
- 11.5.5 发送数据 270 
- 11.5.6 关闭连接 270 
- 11.5.7 其他函数 272 
- 11.6 TCP RAW编程初体验 272 
- 11.6.1 TCP编程本质 272 
- 11.6.2 HTTP服务器 278 
- 11.6.3 打不死的客户端 280 
- 11.7 TCP输出处理细节放送 283 
- 11.7.1 报文段缓冲 283 
- 11.7.2 报文段构建 285 
- 11.7.3 报文段发送 287 
- 11.8 TCP输入处理细节放送 289 
- 11.8.1 TCP层函数调用流程 289 
- 11.8.2 报文输入 291 
- 11.8.3 TIME_WAIT状态的报文处理 294 
- 11.8.4 LISTEN状态的报文处理 294 
- 11.8.5 SYN攻击 296 
- 11.8.6 TCP状态机函数 297 
- 11.8.7 TCP数据输入 301 
- 11.9 可靠的传输服务 305 
- 11.9.1 超时重传与RTT估计 306 
- 11.9.2 慢启动与拥塞避免 311 
- 11.9.3 快速重传与快速恢复 314 
- 11.9.4 糊涂窗口与避免 316 
- 11.9.5 零窗口探查 319 
- 11.9.6 保活机制 321 
- 11.9.7 TCP定时器 322 
- 11.10 挑战更复杂的TCP应用 327 
- 11.10.1 Telnet服务器 327 
- 11.10.2 测试结果 333 
## 第12章 LwIP乾坤大挪移——操作系统模拟层 335 
- 12.1 模拟层是怎样炼成的 336 
- 12.1.1 移植综述 336 
- 12.1.2 添加文件 338 
- 12.1.3 修改头文件lwipopts.h 339 
- 12.1.4 头文件sys_arch.h 339 
- 12.1.5 全局变量与初始化 340 
- 12.1.6 信号量函数 341 
- 12.1.7 邮箱函数 343 
- 12.1.8 创建新进程 348 
- 12.1.9 修改内核初始化函数 349 
- 12.1.10 移植结果测试 350 
- 12.2 Sequential API牛刀小试 350 
- 12.2.1 回显服务器 351 
- 12.2.2 Web服务器 352 
- 12.2.3 操作系统下的raw API 355 
## 第13章 Sequential API大显身手 356 
- 13.1 探秘内核定时事件 356 
- 13.1.1 定时结构 356 
- 13.1.2 定时链表 357 
- 13.1.3 内核进程 359 
- 13.1.4 处理定时事件 361 
- 13.2 论消息机制的重要性 363 
- 13.2.1 消息结构 363 
- 13.2.2 数据包消息 364 
- 13.2.3 协议栈API实现 365 
- 13.2.4 API消息 367 
- 13.3 协议栈接口全搜罗 369 
- 13.3.1 用户数据缓冲netbuf 369 
- 13.3.2 如何操作数据缓冲 371 
- 13.3.3 连接结构netconn 373 
- 13.3.4 内核回调接口 375 
- 13.3.5 协议栈API秘籍 377 
- 13.4 Sequential API大会战 383 
- 13.4.1 网页控制设备 383 
- 13.4.2 UDP性能测试 386 
- 13.4.3 TCP性能测试 388 
- 13.4.4 并发服务器 390 
## 第14章 万剑归宗之Socket编程 395 
- 14.1 套接字接口来龙去脉 395 
- 14.1.1 如何实现Socket 395 
- 14.1.2 套接字函数秘籍 397 
- 14.2 Socket实战大串烧 401 
- 14.2.1 智能的TCP客户端 402 
- 14.2.2 UDP时间服务器 404 
- 14.2.3 Winsock客户端设计 406 
- 14.3 基于Select的并发服务器 408 
- 14.3.1 神奇的Select函数 409 
- 14.3.2 Select原理全解析 410 
- 14.3.3 Select实战——并发服务器 419 
## 第15章 LwIP工程实战——物联网关 424 
- 15.1 项目背景 424 
- 15.1.1 中央空调系统与温控器 424 
- 15.1.2 新需求的出现 427 
- 15.1.3 要做什么与如何去做 430 
- 15.2 智能网络温控器 431 
- 15.2.1 温控器实现方案 431 
- 15.2.2 Modbus TCP服务器 432 
- 15.3 物联网关设计 440 
- 15.3.1 物联网关实现方案 440 
- 15.3.2 网关服务器 441 
- 15.4 现场调试与测试 446 
- 15.4.1 温控器测试 446 
- 15.4.2 物联网关测试 447 
## 第16章 天下之术皆为我用—— LwIP高级篇 449 
- 16.1 外网访问之道——域名解析 449 
- 16.1.1 域名系统（DNS） 449 
- 16.1.2 DNS牛刀小试 450 
- 16.1.3 下载外网数据 453 
- 16.2 如何自动分配IP地址——DHCP 456 
- 16.2.1 DHCP大讲堂 456 
- 16.2.2 DHCP之实现详解 458 
- 16.2.3 是骡子是马——遛遛DHCP 460 
- 16.3 如何实现组播——Internet组管理 464 
- 16.3.1 IGMP协议大讲堂 464 
- 16.3.2 IGMP组播实践 465 
## 第17章 最后的战役 468 
- 17.1 如何配置协议栈 468 
- 17.1.1 内核配置文件opt.h 468 
- 17.1.2 如何提高TCP性能 471 
- 17.2 内核调试常用方法 472 
- 17.2.1 内核日志输出 472 
- 17.2.2 网络调试助手 474 
- 17.2.3 Wireshark抓包 475 
- 17.3 为了更好的明天 476 
- 17.3.1 常见移植问题 476 
- 17.3.2 常见应用问题 478 
- 17.4 故事结局 483 
## 参考文献 484

--------------

# 《Wireshark网络分析就这么简单》
- 初试锋芒 1 
- 从一道面试题开始说起 3 
- 小试牛刀：一个简单的应用实例 10 
- Excel文件的保存过程 13 
- 你一定会喜欢的技巧 17 
- Patrick的故事 29 
- Wireshark的前世今生 32 
- 庖丁解牛 35 
- NFS协议的解析 37 
- 从Wireshark看网络分层 52 
- TCP的连接启蒙 57 
- 快递员的工作策略——TCP窗口 64 
- 重传的讲究 70 
- 延迟确认与Nagle算法 80 
- 百家争鸣 84 
- 简单的代价——UDP 90 
- 剖析CIFS协议 93 
- 网络江湖 104 
- DNS小科普 111 
- 一个古老的协议——FTP 118 
- 上网的学问——HTTP 126 
- 无懈可击的Kerberos 132 
- TCPIP的故事 141 
- 举重若轻 145 
- “一小时内给你答复” 147 
- 午夜铃声 151 
- 深藏功与名 157 
- 棋逢对手 162 
- 学无止境 167 
- 一个技术男的自白 174

----

# 《Wireshark网络分析的艺术》
- 答读者问／1 
- Linux为什么卡住了？／3 
- 像福尔摩斯一样思考／7 
- 一篇关于VMware的文章／12 
- 来点有深度的／18 
- 三次握手的小知识／22 
- 被误解的TCP／27 
- 最经典的网络问题／30 
- 为什么丢了单子？／36 
- 受损的帧／42 
- 虚惊一场／45 
- NTLM协议分析／49 
- Wireshark的提示／54 
- 工作中的Wireshark／61 
- 书上错了吗？／63 
- 计算“在途字节数”／68 
- 估算网络拥塞点／71 
- 顺便说说LSO／74 
- 熟读RFC／77 
- 一个你本该能解决的问题／82 
- 几个关于分片的问题／87 
- MTU导致的悲剧／92 
- 迎刃而解／97 
- 昙花一现的协议／100 
- 另一种流控／105 
- 过犹不及／109 
- 治疗强迫症／114 
- 技术与工龄／119 
- 如何科学地推卸责任／123 
- 一个面试建议／126 
- 生活中的Wireshark／129 
- 假宽带真相／131 
- 手机抓包／138 
- 微博为什么会卡／145 
- 寻找HttpDNS／148 
- 谁动了我的网络／155 
- 一个协议的进化／161 
- 假装产品经理／168 
- 自学的窍门／172 
- 两个项目／177 
- 打造自己的分析工具／179 
- 一个创业点子／189

--------

# 《ARM Cortex-M3与Cortex-M4权威指南(第3版)》
## 第1章ARMCortex—M处理器简介 
- 1.1什么是ARMCortex—M处理器 
- 1.1.1Cortex—M3和Cortex—M4处理器 
- 1.1.2Cortex—M处理器家族 
- 1.1.3处理器和微控制器的区别 
- 1.1.4ARM和微控制器供应商 
- 1.1.5选择Cortex—M3和Cortex—M4微控制器 
- 1.2Cortex—M处理器的优势 
- 1.2.1低功耗 
- 1.2.2性能 
- 1.2.3能耗效率 
- 1.2.4代码密度 
- 1.2.5中断 
- 1.2.6易于使用 
- 1.2.7可扩展性 
- 1.2.8调试特性 
- 1.2.9OS支持 
- 1.2.10多种系统特性 
- 1.2.11软件可移植性和可重用性 
- 1.2.12选择（设备、工具和OS等） 
- 1.3ARMCortex—M处理器应用 
- 1.4ARM处理器和ARM微控制器的资源 
- 1.4.1ARM网站上有什么 
- 1.4.2微控制器供应商提供的文档 
- 1.4.3工具供应商提供的文档 
- 1.4.4其他资源 
- 1.5背景和历史 
- 1.5.1ARM简史 
- 1.5.2ARM处理器的发展 
- 1.5.3ThumbISA的架构版本 
- 1.5.4处理器命名 
- 1.5.5关于ARM生态系统 
## 第2章嵌入式软件开发简介 
- 2.1ARM微控制器是怎样构成的 
- 2.2开始时需要准备什么 
- 2.2.1开发组件 
- 2.2.2开发板 
- 2.2.3调试适配器 
- 2.2.4软件设备驱动 
- 2.2.5例子 
- 2.2.6文档和其他资源 
- 2.2.7其他设备 
- 2.3软件开发流程 
- 2.4编译应用程序 
- 2.5软件流程 
- 2.5.1轮询 
- 2.5.2中断驱动 
- 2.5.3多任务系统 
- 2.6C程序中的数据类型 
- 2.7输入、输出和外设访问 
- 2.8微控制器接口 
- 2.9Cortex微控制器软件接口标准（CMSIS） 
- 2.9.1CMSIS简介 
- 2.9.2CMSIS—Core所做的标准化 
- 2.9.3CMSIS—Core的组织结构 
- 2.9.4如何使用CMSIS—Core 
- 2.9.5CMSIS的优势 
- 2.9.6CMSIS的多个版本 
## 第3章技术综述 
- 3.1Cortex—M3和Cortex—M4处理器的一般信息 
- 3.1.1处理器类型 
- 3.1.2处理器架构 
- 3.1.3指令集 
- 3.1.4模块框图 
- 3.1.5存储器系统 
- 3.1.6中断和异常支持 
- 3.2Cortex—M3和Cortex—M4处理器的特性 
- 3.2.1性能 
- 3.2.2代码密度 
- 3.2.3低功耗 
- 3.2.4存储器系统 
- 3.2.5存储器保护单元 
- 3.2.6中断处理 
- 3.2.7OS支持和系统级特性 
- 3.2.8Cortex—M4的特殊特性 
- 3.2.9易于使用 
- 3.2.10调试支持 
- 3.2.11可扩展性 
- 3.2.12兼容性 
## 第4章架构 
- 4.1架构简介 
- 4.2编程模型 
- 4.2.1操作模式和状态 
- 4.2.2寄存器 
- 4.2.3特殊寄存器 
- 4.2.4浮点寄存器 
- 4.3应用程序状态寄存器 
- 4.3.1整数状态标志 
- 4.3.2Q状态标志 
- 4.3.3GE位 
- 4.4存储器系统 
- 4.4.1存储器系统特性 
- 4.4.2存储器映射 
- 4.4.3栈存储 
- 4.4.4存储器保护单元（MPU） 
- 4.5异常和中断 
- 4.5.1什么是异常 
- 4.5.2嵌套向量中断控制器（NVIC） 
- 4.5.3向量表 
- 4.5.4错误处理 
- 4.6系统控制块（SCB） 
- 4.7调试 
- 4.8复位和复位流程 
## 第5章指令集 
- 5.1ARMCortex—M处理器指令集的背景简介 
- 5.2ARMCortex—M处理器间的指令集比较 
- 5.3理解汇编语言语法 
- 5.4指令后缀的使用 
- 5.5统一汇编语言（UAL） 
- 5.6指令集 
- 5.6.1处理器内传送数据 
- 5.6.2存储器访问指令 
- 5.6.3算术运算 
- 5.6.4逻辑运算 
- 5.6.5移位和循环移位指令 
- 5.6.6数据转换运算（展开和反序） 
- 5.6.7位域处理指令 
- 5.6.8比较和测试 
- 5.6.9程序流控制 
- 5.6.10饱和运算 
- 5.6.11异常相关指令 
- 5.6.12休眠模式相关指令 
- 5.6.13存储器屏障指令 
- 5.6.14其他指令 
- 5.6.15不支持的指令 
- 5.7Cortex—M4特有的指令 
- 5.7.1Cortex—M4的增强DSP扩展简介 
- 5.7.2SIMD和饱和指令 
- 5.7.3乘法和MAC指令 
- 5.7.4打包和解包 
- 5.7.5浮点指令 
- 5.8桶形移位器 
- 5.9在编程中访问特殊寄存器和特殊指令 
- 5.9.1简介 
- 5.9.2内在函数 
- 5.9.3内联汇编和嵌入汇编 
- 5.9.4使用其他的编译器相关的特性 
- 5.9.5访问特殊寄存器 
- …… 
## 第6章存储器系统 
## 第7章异常和中断 
## 第8章深入了解异常处理 
## 第9章低功耗和系统控制特性 
## 第10章OS支持特性 
## 第11章存储器保护单元 
## 第12章错误异常和错误处理 
## 第13章浮点运算 
## 第14章调试和跟踪特性 
## 第15章KeilARM微控制器开发套件入门

