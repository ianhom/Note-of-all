# 《Python网络编程攻略》
## 第1章 套接字、IPv4和简单的客户端／服务器编程1
- 1.2 打印设备名和IPv4地址2 
- 1.3 获取远程设备的IP地址4 
- 1.4 将IPv4地址转换成不同的格式5 
- 1.5 通过指定的端口和协议找到服务名6 
- 1.6 主机字节序和网络字节序之间相互转换7 
- 1.7 设定并获取默认的套接字超时时间8 
- 1.8 优雅地处理套接字错误9 
- 1.9 修改套接字发送和接收的缓冲区大小12 
- 1.10 把套接字改成阻塞或非阻塞模式13 
- 1.11 重用套接字地址14 
- 1.12 从网络时间服务器获取并打印当前时间16 
- 1.13 编写一个SNTP客户端17 
- 1.14 编写一个简单的回显客户端／服务器应用18  
## 第2章 使用多路复用套接字I／O提升性能22 
- 2.2 在套接字服务器程序中使用ForkingMixIn23 
- 2.3 在套接字服务器程序中使用ThreadingMixIn25 
- 2.4 使用select.select编写一个聊天室服务器28 
- 2.5 使用select.epoll多路复用Web服务器34 
- 2.6 使用并发库Diesel多路复用回显服务器37 
## 第3章 IPv6、Unix域套接字和网络接口40 
- 3.2 把本地端口转发到远程主机41 
- 3.3 通过ICMP查验网络中的主机44 
- 3.4 等待远程网络服务上线48 
- 3.5 枚举设备中的接口51 
- 3.6 找出设备中某个接口的IP地址52 
- 3.7 探测设备中的接口是否开启53 
- 3.8 检测网络中未开启的设备55 
- 3.9 使用相连的套接字执行基本的进程间通信57 
- 3.10 使用Unix域套接字执行进程间通信58 
- 3.11 确认你使用的Python是否支持IPv6套接字61 
- 3.12 从IPv6地址中提取IPv6前缀63 
- 3.13 编写一个IPv6回显客户端／服务器64 
## 第4章 HTTP协议网络编程68 
- 4.2 从HTTP服务器下载数据68 
- 4.3 在你的设备中伺服HTTP请求70 
- 4.4 访问网站后提取cookie信息72 
- 4.5 提交网页表单75 
- 4.6 通过代理服务器发送Web请求77 
- 4.7 使用HEAD请求检查网页是否存在78 
- 4.8 把客户端伪装成Mozilla Firefox79  
- 4.9 使用HTTP压缩节省Web请求消耗的带宽80 
- 4.10 编写一个支持断点续传功能的HTTP容错客户端82 
- 4.11 使用Python和OpenSSL编写一个简单的HTTPS服务器84 
## 第5章 电子邮件协议、FTP和CGI编程87 
- 5.2 列出FTP远程服务器中的文件87 
- 5.3 把本地文件上传到远程FTP服务器中89 
- 5.4 把当前工作目录中的内容压缩成ZIP文件后通过电子邮件发送91 
- 5.5 通过POP3协议下载谷歌电子邮件94 
- 5.6 通过IMAP协议查收远程服务器中的电子邮件95 
- 5.7 通过Gmail的SMTP服务器发送带有附件的电子邮件97 
- 5.8 使用CGI为基于Python的Web服务器编写一个留言板 99  
## 第6章 屏幕抓取和其他实用程序103 
- 6.2 使用谷歌地图API搜索公司地址103 
- 6.3 使用谷歌地图URL搜索地理坐标105 
- 6.4 搜索维基百科中的文章106 
- 6.5 使用谷歌搜索股价110 
- 6.6 搜索GitHub中的源代码仓库111 
- 6.7 读取BBC的新闻订阅源114 
- 6.8 爬取网页中的链接116 
## 第7章 跨设备编程119 
- 7.2 使用telnet在远程主机中执行shell命令119 
- 7.3 通过SFTP把文件复制到远程设备中121 
- 7.4 打印远程设备的CPU信息123 
- 7.5 在远程主机中安装Python包126 
- 7.6 在远程主机中运行My

--------
# 《嵌入式网络那些事》
## 前言 
## 第1章 实验平台背后的故事 1 
- 1.1 嵌入式网络技术一统江湖 1 
- 1.1.1 嵌入式网络的发展现状 1 
- 1.1.2 嵌入式LwIP协议栈 4 
- 1.2 基于STM32的实验平台浅析 6 
- 1.2.1 STM32处理器的兴起 6 
- 1.2.2 实验平台简介 9 
- 1.2.3 网卡连接情况 11 
## 第2章 LwIP协议栈初体验 15 
- 2.1 庐山真面目之LwIP代码结构 15 
- 2.1.1 LwIP简介 15 
- 2.1.2 源代码结构 17 
- 2.2 怎样用SI阅读源代码 22 
- 2.3 千里之行从LwIP框架做起 27 
- 2.3.1 协议栈分层思想 27 
- 2.3.2 进程模型 30 
- 2.3.3 协议栈编程接口 31 
## 第3章 LwIP移植初探——无操作系统模拟层 35 
- 3.1 移植说明 35 
- 3.2 移植头文件 37 
- 3.3 网卡驱动编写 40 
- 3.4 安装系统时钟 47 
- 3.5 协议栈初始化 47 
- 3.6 查询接收数据包 49 
- 3.7 数据包中断接收 51 
- 3.8 如何定位Ping问题 53 
## 第4章 内核动力之源——内存管理 55 
- 4.1 内存管理背后的故事 55 
- 4.1.1 内存管理概述 55 
- 4.1.2 常见内存分配策略 57 
- 4.2 以不变应万变——动态内存池 59 
- 4.2.1 数据结构描述 59 
- 4.2.2 函数实现 65 
- 4.3 见招拆招——动态内存堆 67 
- 4.3.1 数据结构描述 67 
- 4.3.2 函数实现 69 
- 4.4 其他内存分配策略 74 
## 第5章 网络数据包——内核血液 78 
- 5.1 数据包管理的必要性 78 
- 5.1.1 LwIP的分层特点 78 
- 5.1.2 协议进程模型 80 
- 5.2 数据包管理原理大揭密 80 
- 5.2.1 数据包结构pbuf 81 
- 5.2.2 pbuf的类型 82 
- 5.2.3 数据包申请函数 85 
- 5.2.4 数据包释放函数 88 
- 5.2.5 其他数据包操作函数 90 
## 第6章 网络抽水机——网络接口管理 92 
- 6.2 接口管理的始与末 93 
- 6.2.1 数据结构 93 
- 6.2.2 函数实现 96 
- 6.3 特殊的网络接口——环回 99 
- 6.3.1 实现原理 99 
- 6.3.2 应用程序环回通信实战 102 
- 6.4 如何动态更改IP地址 109 
- 6.4.1 重要函数 109 
- 6.4.2 实战程序 110 
## 第7章 漫漫鹊桥路——ARP协议 113 
- 7.1 ARP协议之扫盲篇 113 
- 7.1.1 物理地址与网络地址 113 
- 7.1.2 ARP协议的本质 115 
- 7.2 关键数据结构 117 
- 7.2.1 ARP表 117 
- 7.2.2 ARP报文 121 
- 7.3 ARP之数据包引进来 126 
- 7.3.1 以太网数据包递交 126 
- 7.3.2 ARP数据包处理 129 
- 7.3.3 ARP攻击 131 
- 7.3.4 ARP缓存表的更新 132 
- 7.4 ARP之数据包走出去 137 
- 7.4.1 ARP层数据处理总流程 138 
- 7.4.2 广播包与多播包的发送 138 
- 7.4.3 单播包的发送 140 
## 第8章 互联网身份证——网际协议（IP） 144 
- 8.1 IP协议之扫盲班 144 
- 8.1.2 IP地址 145 
- 8.1.3 特殊IP地址 147 
- 8.1.4 子网划分与子网掩码 148 
- 8.1.5 网络地址转换（NAT） 150 
- 8.1.6 单播、多播与广播 151 
- 8.2 什么是IP数据报 153 
- 8.2.1 数据报组成结构 153 
- 8.2.2 数据结构 158 
- 8.3 IP数据报之走出去 159 
- 8.3.1 发送数据报 159 
- 8.3.2 数据报分片 162 
- 8.4 IP数据报之引进来 166 
- 8.4.1 数据报接收 166 
- 8.4.2 分片重装数据结构 171 
- 8.4.3 分片重装函数 174 
- 8.4.4 分片插入与检查 178 
## 第9章 互联网医生——ICMP协议 182 
- 9.1 ICMP扫盲班 182 
- 9.1.1 ICMP协议 182 
- 9.1.2 报文交付 183 
- 9.1.3 报文类型 184 
- 9.1.4 报文格式 185 
- 9.1.5 差错报文 185 
- 9.1.6 查询报文 188 
- 9.2 ICMP实现大起底 189 
- 9.2.1 数据结构 189 
- 9.2.2 发送差错报文 191 
- 9.2.3 ICMP报文的处理 192 
- 9.2.4 ping命令 196 
- 9.2.5 ICMP洪水 197 
- 9.3 如何发送Ping请求 198 
- 9.3.1 实现原理——raw_pcb 199 
- 9.3.2 发送ping请求 200 
## 第10章 Raw API无招胜有招之UDP篇 205 
- 10.1 UDP协议扫盲班 205 
- 10.1.1 传输层协议 205 
- 10.1.2 UDP协议 206 
- 10.1.3 端口号 207 
- 10.1.4 UDP报文的交付 208 
- 10.1.5 UDP报文格式 209 
- 10.1.6 UDP伪首部与校验和 210 
- 10.2 UDP数据结构详解 212 
- 10.2.1 报文首部结构 212 
- 10.2.2 控制块 212 
- 10.3 UDP RAW编程秘籍 216 
- 10.3.1 使用UDP编程 216 
- 10.3.2 新建控制块 216 
- 10.3.3 绑定控制块 217 
- 10.3.4 连接控制块 218 
- 10.3.5 其他控制块操作函数 219 
- 10.4 UDP RAW编程初体验 220 
- 10.4.1 UDP编程秘诀 220 
- 10.4.2 回送程序 221 
- 10.4.3 测试结果 222 
- 10.4.4 回调编程的缺陷 224 
- 10.5 内核报文处理细节 224 
- 10.5.1 报文的发送 224 
- 10.5.2 报文接收与递交 228 
- 10.6 挑战更复杂的UDP应用 231 
- 10.6.1 使用TFTP传送文件 231 
- 10.6.2 应用程序实现 234 
- 10.6.3 TFTP测试结果 242 
## 第11章 Raw API无招胜有招之TCP篇 244 
- 11.1 TCP协议大揭秘 244 
- 11.1.1 TCP的必要性 244 
- 11.1.2 TCP的特性 245 
- 11.1.3 连接的定义 247 
- 11.1.4 数据流编号 248 
- 11.1.5 滑动窗口 248 
- 11.2 TCP入门——报文 249 
- 11.2.1 报文格式 249 
- 11.2.2 TCP选项 251 
- 11.2.3 紧急数据 252 
- 11.2.4 强迫数据交互 253 
- 11.2.5 报文首部数据结构 253 
- 11.3 TCP基础——连接 254 
- 11.3.1 建立连接 254 
- 11.3.2 断开连接 255 
- 11.3.3 复位连接 256 
- 11.3.4 TCP状态转换图 257 
- 11.3.5 特殊的状态转换 259 
- 11.4 TCP核心——控制块 260 
- 11.4.1 控制块数据结构 260 
- 11.4.2 控制块链表 263 
- 11.4.3 接收窗口 264 
- 11.4.4 发送窗口 264 
- 11.5 TCP RAW编程秘诀 265 
- 11.5.1 控制块新建 265 
- 11.5.2 控制块绑定 267 
- 11.5.3 控制块侦听 267 
- 11.5.4 控制块连接 268 
- 11.5.5 发送数据 270 
- 11.5.6 关闭连接 270 
- 11.6 TCP RAW编程初体验 272 
- 11.6.1 TCP编程本质 272 
- 11.6.2 HTTP服务器 278 
- 11.6.3 打不死的客户端 280 
- 11.7 TCP输出处理细节放送 283 
- 11.7.1 报文段缓冲 283 
- 11.7.2 报文段构建 285 
- 11.7.3 报文段发送 287 
- 11.8 TCP输入处理细节放送 289 
- 11.8.1 TCP层函数调用流程 289 
- 11.8.2 报文输入 291 
- 11.8.3 TIME_WAIT状态的报文处理 294 
- 11.8.4 LISTEN状态的报文处理 294 
- 11.8.5 SYN攻击 296 
- 11.8.6 TCP状态机函数 297 
- 11.8.7 TCP数据输入 301 
- 11.9 可靠的传输服务 305 
- 11.9.1 超时重传与RTT估计 306 
- 11.9.2 慢启动与拥塞避免 311 
- 11.9.3 快速重传与快速恢复 314 
- 11.9.4 糊涂窗口与避免 316 
- 11.9.5 零窗口探查 319 
- 11.9.6 保活机制 321 
- 11.9.7 TCP定时器 322 
- 11.10 挑战更复杂的TCP应用 327 
- 11.10.1 Telnet服务器 327 
## 第12章 LwIP乾坤大挪移——操作系统模拟层 335 
- 12.1 模拟层是怎样炼成的 336 
- 12.1.1 移植综述 336 
- 12.1.2 添加文件 338 
- 12.1.3 修改头文件lwipopts.h 339 
- 12.1.4 头文件sys_arch.h 339 
- 12.1.5 全局变量与初始化 340 
- 12.1.6 信号量函数 341 
- 12.1.7 邮箱函数 343 
- 12.1.8 创建新进程 348 
- 12.1.9 修改内核初始化函数 349 
- 12.1.10 移植结果测试 350 
- 12.2 Sequential API牛刀小试 350 
- 12.2.1 回显服务器 351 
- 12.2.2 Web服务器 352 
- 12.2.3 操作系统下的raw API 355 
## 第13章 Sequential API大显身手 356 
- 13.1 探秘内核定时事件 356 
- 13.1.1 定时结构 356 
- 13.1.2 定时链表 357 
- 13.1.3 内核进程 359 
- 13.1.4 处理定时事件 361 
- 13.2 论消息机制的重要性 363 
- 13.2.1 消息结构 363 
- 13.2.2 数据包消息 364 
- 13.2.3 协议栈API实现 365 
- 13.2.4 API消息 367 
- 13.3 协议栈接口全搜罗 369 
- 13.3.1 用户数据缓冲netbuf 369 
- 13.3.2 如何操作数据缓冲 371 
- 13.3.3 连接结构netconn 373 
- 13.3.4 内核回调接口 375 
- 13.3.5 协议栈API秘籍 377 
- 13.4 Sequential API大会战 383 
- 13.4.1 网页控制设备 383 
- 13.4.2 UDP性能测试 386 
- 13.4.3 TCP性能测试 388 
- 13.4.4 并发服务器 390 
## 第14章 万剑归宗之Socket编程 395 
- 14.1 套接字接口来龙去脉 395 
- 14.1.1 如何实现Socket 395 
- 14.1.2 套接字函数秘籍 397 
- 14.2 Socket实战大串烧 401 
- 14.2.1 智能的TCP客户端 402 
- 14.2.2 UDP时间服务器 404 
- 14.2.3 Winsock客户端设计 406 
- 14.3 基于Select的并发服务器 408 
- 14.3.1 神奇的Select函数 409 
- 14.3.2 Select原理全解析 410 
- 14.3.3 Select实战——并发服务器 419 
## 第15章 LwIP工程实战——物联网关 424 
- 15.1 项目背景 424 
- 15.1.1 中央空调系统与温控器 424 
- 15.1.2 新需求的出现 427 
- 15.1.3 要做什么与如何去做 430 
- 15.2 智能网络温控器 431 
- 15.2.1 温控器实现方案 431 
- 15.2.2 Modbus TCP服务器 432 
- 15.3 物联网关设计 440 
- 15.3.1 物联网关实现方案 440 
- 15.3.2 网关服务器 441 
- 15.4 现场调试与测试 446 
- 15.4.1 温控器测试 446 
- 15.4.2 物联网关测试 447 
## 第16章 天下之术皆为我用—— LwIP高级篇 449 
- 16.1 外网访问之道——域名解析 449 
- 16.1.1 域名系统（DNS） 449 
- 16.1.2 DNS牛刀小试 450 
- 16.1.3 下载外网数据 453 
- 16.2 如何自动分配IP地址——DHCP 456 
- 16.2.1 DHCP大讲堂 456 
- 16.2.2 DHCP之实现详解 458 
- 16.2.3 是骡子是马——遛遛DHCP 460 
- 16.3 如何实现组播——Internet组管理 464 
- 16.3.1 IGMP协议大讲堂 464 
- 16.3.2 IGMP组播实践 465 
## 第17章 最后的战役 468 
- 17.1 如何配置协议栈 468 
- 17.1.1 内核配置文件opt.h 468 
- 17.1.2 如何提高TCP性能 471 
- 17.2 内核调试常用方法 472 
- 17.2.1 内核日志输出 472 
- 17.2.2 网络调试助手 474 
- 17.2.3 Wireshark抓包 475 
- 17.3 为了更好的明天 476 
- 17.3.1 常见移植问题 476 
## 参考文献 484

--------------

# 《Wireshark网络分析就这么简单》
- 初试锋芒 1 
- 从一道面试题开始说起 3 
- 小试牛刀：一个简单的应用实例 10 
- Excel文件的保存过程 13 
- 你一定会喜欢的技巧 17 
- Patrick的故事 29 
- Wireshark的前世今生 32 
- NFS协议的解析 37 
- 从Wireshark看网络分层 52 
- TCP的连接启蒙 57 
- 快递员的工作策略——TCP窗口 64 
- 重传的讲究 70 
- 延迟确认与Nagle算法 80 
- 百家争鸣 84 
- 简单的代价——UDP 90 
- 剖析CIFS协议 93 
- 网络江湖 104 
- DNS小科普 111 
- 一个古老的协议——FTP 118 
- 上网的学问——HTTP 126 
- 无懈可击的Kerberos 132 
- TCPIP的故事 141 
- 举重若轻 145 
- “一小时内给你答复” 147 
- 午夜铃声 151 
- 深藏功与名 157 
- 棋逢对手 162 
- 学无止境 167 
- 一个技术男的自白 174

----

# 《Wireshark网络分析的艺术》
- Linux为什么卡住了？／3 
- 像福尔摩斯一样思考／7 
- 一篇关于VMware的文章／12 
- 来点有深度的／18 
- 三次握手的小知识／22 
- 被误解的TCP／27 
- 最经典的网络问题／30 
- 为什么丢了单子？／36 
- 受损的帧／42 
- 虚惊一场／45 
- NTLM协议分析／49 
- Wireshark的提示／54 
- 工作中的Wireshark／61 
- 书上错了吗？／63 
- 计算“在途字节数”／68 
- 估算网络拥塞点／71 
- 顺便说说LSO／74 
- 熟读RFC／77 
- 一个你本该能解决的问题／82 
- 几个关于分片的问题／87 
- MTU导致的悲剧／92 
- 迎刃而解／97 
- 昙花一现的协议／100 
- 另一种流控／105 
- 过犹不及／109 
- 治疗强迫症／114 
- 技术与工龄／119 
- 如何科学地推卸责任／123 
- 一个面试建议／126 
- 生活中的Wireshark／129 
- 假宽带真相／131 
- 手机抓包／138 
- 微博为什么会卡／145 
- 寻找HttpDNS／148 
- 谁动了我的网络／155 
- 一个协议的进化／161 
- 假装产品经理／168 
- 自学的窍门／172 
- 两个项目／177 
- 打造自己的分析工具／179 
- 一个创业点子／189

--------

# 《ARM Cortex-M3与Cortex-M4权威指南(第3版)》
## 第1章ARMCortex—M处理器简介 
- 1.1什么是ARMCortex—M处理器 
- 1.1.1Cortex—M3和Cortex—M4处理器 
- 1.1.2Cortex—M处理器家族 
- 1.1.3处理器和微控制器的区别 
- 1.1.4ARM和微控制器供应商 
- 1.1.5选择Cortex—M3和Cortex—M4微控制器 
- 1.2Cortex—M处理器的优势 
- 1.2.1低功耗 
- 1.2.2性能 
- 1.2.3能耗效率 
- 1.2.4代码密度 
- 1.2.5中断 
- 1.2.6易于使用 
- 1.2.7可扩展性 
- 1.2.8调试特性 
- 1.2.9OS支持 
- 1.2.10多种系统特性 
- 1.2.11软件可移植性和可重用性 
- 1.2.12选择（设备、工具和OS等） 
- 1.3ARMCortex—M处理器应用 
- 1.4ARM处理器和ARM微控制器的资源 
- 1.4.1ARM网站上有什么 
- 1.4.2微控制器供应商提供的文档 
- 1.4.3工具供应商提供的文档 
- 1.4.4其他资源 
- 1.5背景和历史 
- 1.5.1ARM简史 
- 1.5.2ARM处理器的发展 
- 1.5.3ThumbISA的架构版本 
- 1.5.4处理器命名 
- 1.5.5关于ARM生态系统 
## 第2章嵌入式软件开发简介 
- 2.1ARM微控制器是怎样构成的 
- 2.2开始时需要准备什么 
- 2.2.1开发组件 
- 2.2.2开发板 
- 2.2.3调试适配器 
- 2.2.4软件设备驱动 
- 2.2.5例子 
- 2.2.6文档和其他资源 
- 2.2.7其他设备 
- 2.3软件开发流程 
- 2.4编译应用程序 
- 2.5软件流程 
- 2.5.1轮询 
- 2.5.2中断驱动 
- 2.5.3多任务系统 
- 2.6C程序中的数据类型 
- 2.7输入、输出和外设访问 
- 2.8微控制器接口 
- 2.9Cortex微控制器软件接口标准（CMSIS） 
- 2.9.1CMSIS简介 
- 2.9.2CMSIS—Core所做的标准化 
- 2.9.3CMSIS—Core的组织结构 
- 2.9.4如何使用CMSIS—Core 
- 2.9.5CMSIS的优势 
- 2.9.6CMSIS的多个版本 
## 第3章技术综述 
- 3.1Cortex—M3和Cortex—M4处理器的一般信息 
- 3.1.1处理器类型 
- 3.1.2处理器架构 
- 3.1.3指令集 
- 3.1.4模块框图 
- 3.1.5存储器系统 
- 3.1.6中断和异常支持 
- 3.2Cortex—M3和Cortex—M4处理器的特性 
- 3.2.1性能 
- 3.2.2代码密度 
- 3.2.3低功耗 
- 3.2.4存储器系统 
- 3.2.5存储器保护单元 
- 3.2.6中断处理 
- 3.2.7OS支持和系统级特性 
- 3.2.8Cortex—M4的特殊特性 
- 3.2.9易于使用 
- 3.2.10调试支持 
- 3.2.11可扩展性 
- 3.2.12兼容性 
## 第4章架构 
- 4.1架构简介 
- 4.2编程模型 
- 4.2.1操作模式和状态 
- 4.2.2寄存器 
- 4.2.3特殊寄存器 
- 4.2.4浮点寄存器 
- 4.3应用程序状态寄存器 
- 4.3.1整数状态标志 
- 4.3.2Q状态标志 
- 4.3.3GE位 
- 4.4存储器系统 
- 4.4.1存储器系统特性 
- 4.4.2存储器映射 
- 4.4.3栈存储 
- 4.4.4存储器保护单元（MPU） 
- 4.5异常和中断 
- 4.5.1什么是异常 
- 4.5.2嵌套向量中断控制器（NVIC） 
- 4.5.3向量表 
- 4.5.4错误处理 
- 4.6系统控制块（SCB） 
- 4.7调试 
- 4.8复位和复位流程 
## 第5章指令集 
- 5.1ARMCortex—M处理器指令集的背景简介 
- 5.2ARMCortex—M处理器间的指令集比较 
- 5.3理解汇编语言语法 
- 5.4指令后缀的使用 
- 5.5统一汇编语言（UAL） 
- 5.6指令集 
- 5.6.1处理器内传送数据 
- 5.6.2存储器访问指令 
- 5.6.3算术运算 
- 5.6.4逻辑运算 
- 5.6.5移位和循环移位指令 
- 5.6.6数据转换运算（展开和反序） 
- 5.6.7位域处理指令 
- 5.6.8比较和测试 
- 5.6.9程序流控制 
- 5.6.10饱和运算 
- 5.6.11异常相关指令 
- 5.6.12休眠模式相关指令 
- 5.6.13存储器屏障指令 
- 5.6.14其他指令 
- 5.6.15不支持的指令 
- 5.7Cortex—M4特有的指令 
- 5.7.1Cortex—M4的增强DSP扩展简介 
- 5.7.2SIMD和饱和指令 
- 5.7.3乘法和MAC指令 
- 5.7.4打包和解包 
- 5.7.5浮点指令 
- 5.8桶形移位器 
- 5.9在编程中访问特殊寄存器和特殊指令 
- 5.9.1简介 
- 5.9.2内在函数 
- 5.9.3内联汇编和嵌入汇编 
- 5.9.4使用其他的编译器相关的特性 
- 5.9.5访问特殊寄存器 
- …… 
## 第6章存储器系统 
## 第7章异常和中断 
## 第8章深入了解异常处理 
## 第9章低功耗和系统控制特性 
## 第10章OS支持特性 
## 第11章存储器保护单元 
## 第12章错误异常和错误处理 
## 第13章浮点运算 
## 第14章调试和跟踪特性 
## 第15章KeilARM微控制器开发套件入门


------

# 《ARM Cortex-M0与Cortex-M0+权威指南(第2版)》
## 第1章概论
- 1.1欢迎来到嵌入式处理器的世界
- 1.1.1处理器有什么作用
- 1.1.2处理器、CPU、内核、微控制器及其命名
- 1.1.3嵌入式系统的编程
- 1.1.4学习微控制器需要了解什么
- 1.2理解处理器的类型
- 1.2.1处理器为什么有很多种类
- 1.2.2ARM处理器家族概述
- 1.2.3模糊边界
- 1.2.4ARM CortexM处理器系列
- 1.2.5ARM CortexM0和CortexM0+处理器简介
- 1.2.6从CortexM0处理器到CortexM0+处理器
- 1.2.7CortexM0和CortexM0+处理器的应用
- 1.3微控制器内部有什么
- 1.3.1微控制器内常见部件
- 1.3.2微控制器应用的处理器的特点
- 1.3.3硅片技术
- 1.4ARM介绍
- 1.4.1ARM生产芯片吗
- 1.4.2ARM的产品是什么
- 1.4.3芯片厂商为什么不设计自己的处理器
- 1.4.4ARM生态系统有什么特殊之处
- 1.5ARM处理器和ARM微控制器方面的资源
- 1.5.1ARM主页
- 1.5.2微控制器厂商提供的资源
- 1.5.3工具厂商提供的资源
## 第2章技术综述
- 2.1CortexM0和CortexM0+处理器
- 2.2模块框图
- 2.3典型系统
- 2.4什么是ARMv6M架构
- 2.5CortexM处理器间的软件可移植性
- 2.6ARM CortexM0和CortexM0+处理器的优势
- 2.6.1低功耗和能耗效率
- 2.6.2高代码密度
- 2.6.3低中断等待和确定行为
- 2.6.4易于使用
- 2.6.5系统级特性和OS支持特性
- 2.6.6调试特性
- 2.6.7可配置性、灵活性和可扩展性
- 2.6.8软件可移植性和可重用性
- 2.6.9产品选择的多样性
- 2.6.10生态系统支持
- 2.7CortexM0和CortexM0+处理器的应用
- 2.7.1微控制器
- 2.7.2传感器
- 2.7.3传感器集线器
- 2.7.4电源管理IC
- 2.7.5ASSP和ASIC
- 2.7.6片上系统中的子系统
- 2.8为什么要在微控制器应用中使用32位处理器
- 2.8.1性能
- 2.8.2代码密度
- 2.8.3ARM架构的其他优势
- 2.8.4软件可重用性
## 第3章嵌入式软件开发介绍
- 3.1欢迎进入嵌入式系统编程
- 3.2基本概念
- 3.2.1复位
- 3.2.2时钟
- 3.2.3电压
- 3.2.4输入和输出
- 3.2.5嵌入式软件程序流程介绍
- 3.2.6编程语言选择
- 3.3ARM CortexM编程介绍
- 3.3.1C编程数据类型
- 3.3.2用C访问外设
- 3.3.3程序映像内有什么
- 3.3.4SRAM中的数据
- 3.3.5微控制器启动时会发生什么
- 3.4软件开发流程
- 3.5Cortex微控制器软件接口标准
- 3.5.1CMSIS介绍
- 3.5.2CMSISCORE所做的标准化
- 3.5.3CMSISCORE的组织
- 3.5.4使用CMSISCORE
- 3.5.5CMSIS的优势
- 3.6软件发的其他信息
## 第4章架构
- 4.1ARMv6M架构综述
- 4.1.1架构的含义
- 4.1.2ARMv6M架构背景
- 4.2编程模型
- 4.2.1操作模式和状态
- 4.2.2寄存器和特殊寄存器
- 4.2.3APSR的行为
- 4.3存储器系统
- 4.3.1概述
- 4.3.2单周期I/O接口
- 4.3.3存储器保护单元
- 4.4栈存储操作
- 4.5异常和中断
- 4.6嵌套向量中断控制器
- 4.6.1灵活的中断管理
- 4.6.2嵌套中断支持
- 4.6.3向量异常入口
- 4.6.4中断屏蔽
- 4.7系统控制块
- 4.8调试系统
- 4.9程序映像和启动流程
## 第5章指令集
- 5.1指令集是什么
- 5.2ARM和Thumb指令集背景
- 5.3汇编基础
- 5.3.1汇编语法一览
- 5.3.2后缀的使用
- 5.3.3统一汇编语言(UAL)
- 5.4指令列表
- 5.4.1处理器内传送数据
- 5.4.2存储器访问
- 5.4.3栈存储访问
- 5.4.4算术运算
- 5.4.5逻辑运算
- 5.4.6移位和循环移位运算
- 5.4.7展开和顺序反转运算
- 5.4.8程序流控制
- 5.4.9存储器屏障指令
- 5.4.10异常相关指令
- 5.4.11休眠模式特性相关指令
- 5.4.12其他指令
- 5.5伪指令
## 第6章指令使用示例
- 6.1概述
- 6.2程序控制
- 6.2.1ifthenelse
- 6.2.2循环
- 6.2.3跳转指令
- 6.2.4跳转指令的典型用法
- 6.2.5函数调用和函数返回
- 6.2.6跳转表
- 6.3数据访问
- 6.3.1简单数据访问
- 6.3.2使用存储器访问指令的例子
- 6.4数据类型转换
- 6.4.1数据大小的转换
- 6.4.2大小端转换
- 6.5数据处理
- 6.5.164位/128位加法
- 6.5.264位/128位减法
- 6.5.3整数除法
- 6.5.4无符号整数开方根
- 6.5.5位和位域计算
## 第7章存储器系统
- 7.1微控制器中的存储器系统
- 7.2CortexM0和CortexM0+处理器中的总线系统
- 7.3存储器映射
- 7.3.1概述
- 7.3.2系统级设计
- 7.4程序存储器、Bootloader和存储器重映射
- 7.4.1程序存储器和Bootloader
- 7.4.2存储器映射
- 7.5数据存储器
- 7.6小端和大端支持
- 7.7数据类型
- 7.8存储器属性和存储器访问权限
- 7.9硬件行为对编程的影响
- 7.9.1数据对齐
- 7.9.2访问非法地址
- 7.9.3多加载和存储指令的使用
- 7.9.4等待状态
## 第8章异常和中断
- 8.1异常和中断的含义
- 8.2CortexM0和CortexM0+处理器内的异常类型
- 8.2.1概述
- 8.2.2不可屏蔽中断
- 8.2.3HardFault
- 8.2.4SVC
- 8.2.5可挂起的系统调用
- 8.2.6系统节拍
- 8.2.7中断
- 8.3NVIC简介
- 8.4异常优先级定义
- 8.5向量表
- 8.6异常流程概述
- 8.6.1接受异常
- 8.6.2压栈和出栈
- 8.6.3异常返回指令
- 8.6.4末尾连锁
- 8.6.5延迟到达
- 8.7EXC_RETURN
- 8.8用于中断控制的NVIC控制寄存器
- 8.8.1NVIC控制寄存器概述
- 8.8.2中断使能和清除使能
- 8.8.3中断挂起和清除挂起
- 8.8.4中断优先级
- 8.9异常屏蔽寄存器(PRIMASK)
- 8.10中断输入和挂起行为
- 8.10.1简单中断处理
- 8.10.2简单的脉冲中断处理
- 8.10.3中断挂起状态在得到服务前取消
- 8.10.4外设在确认中断请求时清除挂起状态
- 8.10.5ISR完成后中断请求保持为高
- 8.10.6进入ISR前产生了多个中断请求脉冲
- 8.10.7在ISR执行期间产生了中断请求脉冲
- 8.10.8已禁止中断的中断请求确认
- 8.11异常入口流程
- 8.11.1压栈
- 8.11.2取出向量并更新PC
- 8.11.3更新寄存器
- 8.12异常退出流程
- 8.12.1寄存器出栈
- 8.12.2从返回地址取指并执行
- 8.13中断等待
## 第9章系统控制和低功耗特性
- 9.1系统控制寄存器简介
- 9.2SCB中的寄存器
- 9.2.1SCB中的寄存器列表
- 9.2.2CPU ID寄存器
- 9.2.3用于系统异常管理的控制寄存器
- 9.2.4向量表偏移寄存器
- 9.2.5应用中断和复位控制寄存器
- 9.2.6系统控制寄存器
- 9.2.7配置和控制寄存器
- 9.2.8系统处理控制和状态寄存器
- 9.3使用自复位特性
- 9.4使用向量表重定位特性
- 9.5低功耗特性
- 9.5.1概述
- 9.5.2休眠模式
- 9.5.3等待事件和等待中断
- 9.5.4唤醒条件
- 9.5.5退出时休眠特性
- 9.5.6唤醒中断控制器
## 第10章操作系统支持特性
- 10.1支持OS的特性概述
- 10.2嵌入式系统的操作系统介绍
- 10.3SysTick定时器
- 10.3.1SysTick寄存器
- 10.3.2设置SysTick
- 10.3.3SysTick用于时间测量
- 10.3.4将SysTick用作单发定时器
- 10.4进程栈和PSP
- 10.5SVCall异常
- 10.6PendSV
- 10.7高级话题： 在编程中使用SVC和PendSV
- 10.7.1使用SVC异常
- 10.7.2使用PendSV异常
- 10.8高级话题： 实际的上下文切换
## 第11章错误处理
- 11.1错误异常概述
- 11.2错误是如何产生的
- 11.3分析错误
- 11.4意外切换至ARM状态
- 11.5实际应用中的错误处理
- 11.6软件开发期间的错误处理
- 11.7锁定
- 11.7.1锁定的原因
- 11.7.2锁定期间发生了什么
- 11.8避免锁定
- 11.9和ARMv7M架构中错误处理的对比
## 第12章存储器保护单元
- 12.1MPU是什么
- 12.2MPU适用的情形
- 12.3技术介绍
- 12.4MPU寄存器
- 12.4.1MPU类型寄存器
- 12.4.2MPU控制寄存器
- 12.4.3MPU区域编号寄存器
- 12.4.4MPU区域基地址寄存器
- 12.4.5MPU区域基本属性和大小寄存器
- 12.5设置MPU
- 12.6存储器屏障和MPU配置
- 12.7使用子区域禁止
- 12.7.1允许高效的存储器划分
- 12.7.2减少所需的区域总数
- 12.8使用MPU时的注意事项
- 12.8.1程序代码
- 12.8.2数据存储器
- 12.9和CortexM3/M4/M7处理器的MPU间的差异
## 第13章调试特性
- 13.1软件开发和调试特性
- 13.2调试接口
- 13.2.1JTAG和串行线调试通信协议
- 13.2.2CortexM处理器和CoreSight调试架构
- 13.2.3调试接口的设计考虑
- 13.3调试特性一览
- 13.4调试系统
- 13.5暂停模式和调试事件
- 13.6利用MTB实现指令跟踪
## 第14章Keil微控制器开发套件入门
- 14.1Keil微控制器开发套件介绍
- 14.1.1概述
- 14.1.2工具
- 14.1.3Keil MDK的优势
- 14.1.4安装
- 14.2典型的程序编译流程
- 14.3硬件介绍
- 14.3.1Freescale Freedom开发板(FRDMKL25Z)
- 14.3.2STMicroelectronics STM32L0 Discovery
- 14.3.3STMicroelectronics STM32F0 Discovery
- 14.3.4NXP LPC1114FN28
- 14.4μVision IDE入门
- 14.4.1如何开始
- 14.4.2启动Keil MDK
- 14.4.3Freescale FRDMKL25Z工程设置步骤
- 14.4.4STMicroelectronics STM32L0 Discovery工程设置步骤
- 14.4.5STMicroelectronice STM32F0 Discovery工程设置步骤
- 14.4.6NXP LPC1114FN28工程设置步骤
- 14.5使用IDE和调试器
- 14.6底层内容
- 14.6.1CMSIS文件
- 14.6.2时钟设置
- 14.6.3栈和堆的设置
- 14.6.4编译
- 14.7工程环境的优化
- 14.7.1目标选项
- 14.7.2优化选项
- 14.7.3运行时环境选项
- 14.7.4工程管理
- 14.8使用模拟器
- 14.9在SRAM中执行程序
- 14.10使用MTB指令跟踪
## 第15章IAR embedded workbench for ARM入门
- 15.1IAR embedded workbench for ARM概述
- 15.2典型的程序编译流程
- 15.3创建简单的blinky工程
- 15.4工程选项
- 15.5在IAR EWARM中使用MTB指令跟踪
- 15.6提示和要点
## 第16章GCC入门
- 16.1GCC工具链
- 16.2关于本章中的例子
- 16.3典型开发流程
- 16.4创建简单的Blinky工程
- 16.5命令行选项概述
- 16.6Flash编程
- 16.7在Keil MDKARM中使用ARM嵌入式处理器GNU工具
- 16.8在CooCox IDE中使用ARM嵌入式处理器GNU工具
- 16.8.1概述和设置
- 16.8.2创建新的工程
- 16.8.3使用IDE和调试器
## 第17章mbed入门
- 17.1什么是mbed
- 17.2mbed系统是怎么工作的
- 17.3mbed的优势
- 17.4设置FRDMKL25Z板和mbed账号
- 17.4.1检查mbed Web网页
- 17.4.2注册mbed账号
- 17.4.3个人计算机的设置
- 17.5创建blinky程序
- 17.5.1只开关红色LED的简单版本
- 17.5.2利用脉宽调试控制LED
- 17.6支持的常用外设对象
- 17.7使用printf
- 17.8应用实例： 火车模型控制器
- 17.9中断
## 第18章编程实例
- 18.1利用通用异步收发器来产生输出
- 18.1.1通用异步收发器通信概述
- 18.1.2微控制器上的UART配置概述
- 18.1.3配置FRDMKL25Z中的UART
- 18.1.4配置STM32L0 Discovery板中的UART
- 18.1.5配置STM32F0 Discovery板上的UART
- 18.1.6配置LPC1114FN28上的UART
- 18.2实现printf
- 18.2.2Keil MDK的重定向
- 18.2.3IAR EWARM的重定向
- 18.2.4GNU编译器套件的重定向
- 18.2.5IAR EWARM的半主机
- 18.2.6CoIDE的半主机
- 18.3开发输入和输出函数
- 18.3.1为何要重新开发
- 18.3.2其他接口
- 18.3.3有关scanf的其他信息
- 18.4中断编程实例
- 18.4.1中断处理概述
- 18.4.2中断控制函数概述
- 18.5应用实例： 火车模型用的另一个控制器
- 18.6CMSISCORE的不同版本
## 第19章超低功耗设计
- 19.1超低功耗使用示例
- 19.1.2进入休眠模式
- 19.1.3WFE与WFI
- 19.1.4利用退出时休眠特性
- 19.1.5利用挂起发送事件特性
- 19.1.6利用唤醒中断控制器
- 19.1.7利用事件通信接口
- 19.2低功耗设计要求
- 19.3能量去哪里了
- 19.4开发低功耗应用
- 19.4.1低功耗设计概述
- 19.4.2降低功耗的各种方法
- 19.4.3选择正确的方法
- 19.5调试考虑
- 19.5.1调试和低功耗
- 19.5.2调试和Flash编程的“安全模式”
- 19.5.3低电压引脚和调试接口
- 19.6低电压设备的检测
- 19.6.1ULPBench的背景
- 19.6.2ULPBenchCP概述
- 19.7Freescale KL25Z低功耗特性使用示例
- 19.7.2测试设置
- 19.7.3KL25Z的低功耗模式
- 19.7.4时钟设计
- 19.7.5测试设置
- 19.7.6测量结果
- 19.8LPC1114低功耗特性使用示例
- 19.8.1LPC1114FN28概述
- 19.8.2实验1:使用12MHz内部和外部晶振
- 19.8.3实验2:使用降频1MHz和100kHz
- 19.8.4其他改进
- 19.8.5利用LPC1114的深度休眠
## 第20章嵌入式OS编程
- 20.1.2嵌入式OS和RTOS
- 20.1.3为什么要使用嵌入式OS
- 20.1.4CMSISRTOS的作用
- 20.1.5关于Keil RTX Kernel
- 20.1.6在Keil MDK中构建一个简单RTX实例
- 20.2RTX Kernel概述
- 20.2.1线程
- 20.2.2RTX配置
- 20.2.3深入研究第一个例子
- 20.2.4线程间通信概述
- 20.2.5信号事件通信
- 20.2.6互斥体(Mutex)
- 20.2.7信号量
- 20.2.8消息队列
- 20.2.9邮件队列
- 20.2.10内存池管理特性
- 20.2.11通用等待函数和超时数值
- 20.2.12定时器特性
- 20.2.13给非特权线程增加SVC服务
- 20.3在应用中使用RTX
- 20.4调试RTX应用
- 20.5.1栈大小需求
- 20.5.2优先级
- 20.5.3利用OS错误报告
- 20.5.4OS特性配置
- 20.5.5其他问题
- 20.6其他要点和提示
- 20.6.1修改RTX_Config_CM.c
- 20.6.2线程优先级
- 20.6.3缩短等待时间
## 第21章混合语言工程
- 21.1汇编在工程开发中的应用
- 21.2汇编编程实践和AAPCS
- 21.3汇编函数概述
- 21.3.1ARM工具链
- 21.3.2GCC工具链
- 21.3.3IAR Embedded Workbench for ARM
- 21.3.4汇编函数结构
- 21.4内联汇编
- 21.4.1ARM工具链
- 21.4.2GNU编译器组件
- 21.5嵌入汇编特性(ARM工具链)
- 21.6混合语言工程
- 21.6.2在汇编代码中调用C函数
- 21.6.3在C代码中调用汇编函数
- 21.7在Keil MDKARM中创建汇编工程
- 21.7.1一个简单的工程
- 21.7.2Hello World
- 21.7.3其他文本输出函数
- 21.8用于中断控制的通用汇编代码
- 21.8.1使能和禁止中断
- 21.8.2设置和清除中断挂起状态
- 21.8.3设置中断优先级
- 21.9汇编语言的其他编程技巧
- 21.9.1为变量分配数据空间
- 21.9.2复杂跳转处理
- 21.10使用特殊指令
- 21.10.1CMSISCORE
- 21.10.2习语识别
## 第22章软件移植
- 22.2从8位/16位微控制器向ARM CortexM移植软件
- 22.2.1通用改动
- 22.2.2存储器需求
- 22.2.38位或16位微控制器不再适用的优化
- 22.2.4实例： 从8051移植到ARM CortexM0/CortexM0+
- 22.3ARM7TDMI和CortexM0/M0+处理器间的差异
- 22.3.1经典ARM处理器概述
- 22.3.2操作模式
- 22.3.3寄存器
- 22.3.4指令集
- 22.3.5中断
- 22.4从ARM7TDMI向CortexM0/CortexM0+处理器移植软件
- 22.4.1启动代码和向量表
- 22.4.2中断
- 22.4.3C程序代码
- 22.4.4汇编代码
- 22.4.5原子访问
- 22.4.6优化
- 22.5各种CortexM处理器间的差异
- 22.5.1概述
- 22.5.2系统模型
- 22.5.3NVIC和异常
- 22.5.4指令集
- 22.5.5系统级特性
- 22.5.6调试和跟踪特性
- 22.6在CortexM处理器间移植时的通用改动
- 22.7CortexM0/M0+和CortexM1间的软件移植
- 22.8CortexM0/M0+和CortexM3间的软件移植
- 22.9CortexM0/M0+和CortexM4/M7间的软件移植
## 第23章高级话题
- 23.1C语言实现的位数据处理
- 23.2C实现的启动代码
- 23.3栈溢出检测
- 23.3.1什么是栈溢出
- 23.3.2工具链的栈分析
- 23.3.3栈的测试分析
- 23.3.4利用存储器保护单元对栈进行限制
- 23.3.5OS上下文切换期间的栈检测
- 23.4中断服务程序重入
- 23.5信号量设计
- 23.6存储器顺序和存储器屏障
## 附录A指令集快速参考
## 附录B异常类型快速参考
- B.1异常类型
- B.2异常压栈后栈的内容
## 附录C CMSIS-CORE快速参考
- C.1数据类型
- C.2异常枚举
- C.3嵌套向量中断控制器访问函数
- C.4系统和SysTick操作函数
- C.5内核寄存器操作函数
- C.6特殊指令操作函数
## 附录DNVIC、SCB和SysTick寄存器快速参考
- D.1NVIC寄存器一览
- D.2中断设置使能寄存器(NVICISER)
- D.3中断清除使能寄存器(NVICICER)
- D.4中断设置挂起寄存器(NVICISPR)
- D.5中断清除挂起寄存器(NVICICPR)
- D.6中断优先级寄存器(NVICIRQ［0］到NVICIRQ［7］)
- D.7SCB寄存器一览
- D.8CPU ID寄存器(SCBCPUID)
- D.9中断控制状态寄存器(SCBICSR)
- D.10向量表偏移寄存器(SCBVTOR，0xE000ED08)
- D.11应用中断和控制状态寄存器(SCBAIRCR)
- D.12系统控制寄存器(SCBSCR)
- D.13配置控制寄存器(SCBCCR)
- D.14系统处理优先级寄存器2(SCBSHR［0］)
- D.15系统处理优先级寄存器3(SCBSHR［1］)
- D.16系统处理控制和状态寄存器
- D.17SysTick寄存器一览
- D.18SysTick控制和状态寄存器(SysTickCTRL)
- D.19SysTick重装载值寄存器(SysTickLOAD)
- D.20SysTick当前值寄存器(SysTickVAL)
- D.21SysTick校准值寄存器(SysTickCALIB)
## 附录E调试寄存器快速参考
- E.1内核调试寄存器
- E.2断点单元
- E.3数据监视点单元
- E.4ROM表寄存器
- E.5微跟踪缓冲
- E.6POSITION寄存器
- E.7MASTER寄存器
- E.8FLOW寄存器
- E.9BASE寄存器
- E.10包格式
## 附录F调试接头分配
- F.110针Cortex调试连接头
- F.220针Cortex调试+ETM接头
- F.3老式的20针IDC接头排列
## 附录G疑难解答
- G.1程序不运行/启动
- G.1.1向量表丢失或位置错误
- G.1.2使用了错误的C启动代码
- G.1.3复位向量中的值错误
- G.1.4程序映像没有被正确地编程到Flash中
- G.1.5错误的工具链配置
- G.1.6错误的栈指针初始值
- G.1.7错误的大小端设置
- G.2程序启动，却进入了硬件错误
- G.2.1非法存储器访问
- G.2.2非对齐数据访问
- G.2.3存储器访问权限(只限于CortexM0+处理器)
- G.2.4从总线返回错误
- G.2.5异常处理中的栈被破坏
- G.2.6程序在某些C函数中崩溃
- G.2.7意外地试图切换至ARM状态
- G.2.8在错误的优先级上执行SVC
- G.3休眠问题
- G.3.1执行WFE不进入休眠
- G.3.2退出时休眠过早地引起休眠
- G.3.3中断已经在挂起态时SEVONPEND不工作
- G.3.4由于休眠模式可能禁止了某些时钟，处理器无法唤醒
- G.3.5竞态
- G.4中断问题
- G.4.1执行了多余的中断处理
- G.4.2执行了多余的SysTick处理
- G.4.3在中断处理中禁止中断
- G.4.4错误的中断返回指令
- G.4.5异常优先级设置的数值
- G.5其他问题
- G.5.1错误的SVC参数传递方法
- G.5.2调试连接受到I/O设置或低功耗模式的影响
- G.5.3调试协议选择/配置
- G.5.4使用事件输出作为脉冲I/O
- G.5.5向量表和代码位置的设备实际需求
- G.6其他可能的编程陷阱
- G.6.1中断优先级
- G.6.2同时使用主栈和进程栈时的栈溢出
- G.6.3数据对齐
- G.6.4丢失volatile关键字
- G.6.5函数指针
- G.6.6读修改写
- G.6.7中断禁止
- G.6.8SystemInit函数
- G.6.9断点和内联

-------------

# 《Python基础教程(第3版)》
## 第 1 章 快速上手：基础知识
- 1.1 交互式解释器
- 1.2 算法是什么
- 1.3 数和表达式
- 1.4 变量
- 1.5 语句
- 1.6 获取用户输入
- 1.7 函数
- 1.8 模块
- 1.8.1 cmath和复数
- 1.8.2 回到未来
- 1.9 保存并执行程序
- 1.9.1 从命令提示符运行 Python 脚本
- 1.9.2 让脚本像普通程序一样
- 1.9.3 注释
- 1.10 字符串
- 1.10.1 单引号字符串以及对引号转义
- 1.10.2 拼接字符串
- 1.10.3 字符串表示 str和 repr
- 1.10.4 长字符串、原始字符串和字节
## 第 2 章 列表和元组
- 2.1 序列概述
- 2.2 通用的序列操作
- 2.2.1 索引
- 2.2.2 切片
- 2.2.3 序列相加
- 2.2.4 乘法
- 2.2.5 成员资格
- 2.3 列表：Python的主力
- 2.3.1 函数 list
- 2.3.2 基本的列表操作
- 2.3.3 列表方法
- 2.4 元组：不可修改的序列
## 第 3 章 使用字符串
- 3.1 字符串基本操作
- 3.2 设置字符串的格式：精简版
- 3.3 设置字符串的格式：完整版
- 3.3.1 替换字段名
- 3.3.2 基本转换
- 3.3.3 宽度、精度和千位分隔符
- 3.3.4 符号、对齐和用 0填充
- 3.4 字符串方法
- 3.4.1 center
- 3.4.2 find
- 3.4.3 join
- 3.4.4 lower
- 3.4.5 replace
- 3.4.6 split
- 3.4.7 strip
- 3.4.8 translate
- 3.4.9 判断字符串是否满足特定的条件
## 第 4 章 当索引不通时
- 4.1 字典的用途
- 4.2 创建和使用字典
- 4.2.1 函数 dict
- 4.2.2 基本的字典操作
- 4.2.3 将字符串格式设置功能用于字典
- 4.2.4 字典方法
## 第 5 章 条件、循环及其他语句
- 5.1 再谈 print和 import
- 5.1.1 打印多个参数
- 5.1.2 导入时重命名
- 5.2 赋值魔法
- 5.2.1 序列解包
- 5.2.2 链式赋值
- 5.2.3 增强赋值
- 5.3 代码块：缩进的乐趣
- 5.4 条件和条件语句
- 5.4.1 这正是布尔值的用武之地
- 5.4.2 有条件地执行和 if语句
- 5.4.3 else子句
- 5.4.4 elif子句
- 5.4.5 代码块嵌套
- 5.4.6 更复杂的条件
- 5.4.7 断言
- 5.5 循环
- 5.5.1 while循环
- 5.5.2 for循环
- 5.5.3 迭代字典
- 5.5.4 一些迭代工具
- 5.5.5 跳出循环 
- 5.5.6 循环中的 else子句
- 5.6 简单推导
- 5.7 三人行
- 5.7.1 什么都不做
- 5.7.2 使用 del删除
- 5.7.3 使用 exec和 eval执行字符串及计算其结果
## 第 6 章 抽象
- 6.1 懒惰是一种美德
- 6.2 抽象和结构
- 6.3 自定义函数
- 6.3.1 给函数编写文档
- 6.3.2 其实并不是函数的函数
- 6.4 参数魔法
- 6.4.1 值从哪里来
- 6.4.2 我能修改参数吗
- 6.4.3 关键字参数和默认值
- 6.4.4 收集参数
- 6.4.5 分配参数
- 6.4.6 练习使用参数
- 6.5 作用域
- 6.6 递归
- 6.6.1 两个经典案例：阶乘和幂
- 6.6.2 另一个经典案例：二分查找
## 第 7 章 再谈抽象
- 7.1 对象魔法
- 7.1.1 多态
- 7.1.2 多态和方法
- 7.1.3 封装
- 7.1.4 继承
- 7.2 类
- 7.2.1 类到底是什么
- 7.2.2 创建自定义类
- 7.2.3 属性、函数和方法
- 7.2.4 再谈隐藏
- 7.2.5 类的命名空间
- 7.2.6 指定超类
- 7.2.7 深入探讨继承
- 7.2.8 多个超类
- 7.2.9 接口和内省
- 7.2.10 抽象基类
- 7.3 关于面向对象设计的一些思考
## 第 8 章 异常
- 8.1 异常是什么
- 8.2 让事情沿你指定的轨道出错
- 8.2.1 raise语句
- 8.2.2 自定义的异常类
- 8.3 捕获异常
- 8.3.1 不用提供参数
- 8.3.2 多个 except子句
- 8.3.3 一箭双雕
- 8.3.4 捕获对象
- 8.3.5 一网打尽
- 8.3.6 万事大吉时
- 8.3.7 最后
- 8.4 异常和函数
- 8.5 异常之禅
- 8.6 不那么异常的情况
## 第 9 章 魔法方法、特性和迭代器
- 9.1 如果你使用的不是 Python 3
- 9.2 构造函数
- 9.2.1 重写普通方法和特殊的构造函数
- 9.2.2 调用未关联的超类构造函数
- 9.2.3 使用函数 super
- 9.3 元素访问
- 9.3.1 基本的序列和映射协议
- 9.3.2 从 list、dict和 str派生
- 9.4 其他魔法方法
- 9.5 特性
- 9.5.1 函数 property
- 9.5.2 静态方法和类方法
- 9.5.3 \_\_getattr\_\_、\_\_setattr\_\_等方法
- 9.6 迭代器
- 9.6.1 迭代器协议
- 9.6.2 从迭代器创建序列
- 9.7 生成器
- 9.7.1 创建生成器
- 9.7.2 递归式生成器
- 9.7.3 通用生成器
- 9.7.4 生成器的方法
- 9.7.5 模拟生成器
- 9.8 八皇后问题
- 9.8.1 生成器的回溯
- 9.8.2 问题
- 9.8.3 状态表示
- 9.8.4 检测冲突
- 9.8.5 基线条件
- 9.8.6 递归条件
- 9.8.7 扫尾工作
## 第 10 章开箱即用
- 10.1 模块
- 10.1.1 模块就是程序
- 10.1.2 模块是用来下定义的
- 10.1.3 让模块可用
- 10.1.4 包
- 10.2 探索模块
- 10.2.1 模块包含什么
- 10.2.2 使用 help获取帮助
- 10.2.3 文档
- 10.2.4 使用源代码
- 10.3 标准库：一些深受欢迎的模块
- 10.3.1 sys
- 10.3.2 os
- 10.3.3 fileinput
- 10.3.4 集合、堆和双端队列
- 10.3.5 time
- 10.3.6 random
- 10.3.7 shelve和 json
- 10.3.8 re
- 10.3.9 其他有趣的标准模块
## 第 11 章 文件
- 11.1 打开文件
- 11.2 文件的基本方法
- 11.2.1 读取和写入
- 11.2.2 使用管道重定向输出
- 11.2.3 读取和写入行
- 11.2.4 关闭文件
- 1.2.5 使用文件的基本方法
- 11.3 迭代文件内容
- 11.3.1 每次一个字符（或字节）
- 11.3.2 每次一行
- 11.3.3 读取所有内容
- 11.3.4 使用 fileinput实现延迟行迭代
- 11.3.5 文件迭代器
## 第 12 章 图形用户界面
- 12.1 创建 GUI示例应用程序
- 12.1.1 初探
- 12.1.2 布局
- 12.1.3 事件处理
- 12.1.4 最终的程序
- 12.2 使用其他 GUI工具包
## 第 13 章 数据库支持
- 13.1 Python数据库 API
- 13.1.1 全局变量
- 13.1.2 异常
- 13.1.3 连接和游标
- 13.1.4 类型
- 13.2 SQLite和 PySQLite
- 13.2.1 起步
- 13.2.2 数据库应用程序示例
## 第 14 章 网络编程
- 14.1 几个网络模块
- 14.1.1 模块 socket
- 14.1.2 模块 urllib和 urllib2
- 14.1.3 其他模块
- 14.2 SocketServer及相关的类
- 14.3 多个连接
- 14.3.1 使用 SocketServer实现
- 分叉和线程化
- 14.3.2 使用 select和 poll实现
- 异步 I/O
- 14.4 Twisted
- 14.4.1 下载并安装 Twisted
- 14.4.2 编写 Twisted服务器
## 第 15 章 Python和 Web
- 15.1 屏幕抓取
- 15.1.1 Tidy和 XHTML解析
- 15.1.2 Beautiful Soup
- 15.2 使用 CGI创建动态网页 
- 15.2.1 第一步：准备 Web服务器
- 15.2.2 第二步：添加 !#行
- 15.2.3 第三步：设置文件权限
- 15.2.4 CGI安全风险
- 15.2.5 简单的 CGI脚本
- 15.2.6 使用 cgitb进行调试
- 15.2.7 使用模块 cgi
- 15.2.8 简单的表单
- 15.3 使用 Web框架
- 15.4 Web服务：更高级的抓取
- 15.4.1 RSS和相关内容
- 15.4.2 使用 XML-RPC进行远程过程调用
- 15.4.3 SOAP
## 第 16 章 测试基础
- 16.1 先测试再编码
- 16.1.1 准确的需求说明
- 16.1.2 做好应对变化的准备
- 16.1.3 测试四步曲
- 16.2 测试工具
- 16.2.1 doctest
- 16.2.2 unittest
- 16.3 超越单元测试
- 16.3.1 使用 PyChecker和 PyLint检查源代码
- 16.3.2 性能分析
- 16.4 小结
- 16.4.1 本章介绍的新函数
- 16.4.2 预告
## 第 17 章 扩展 Python
- 17.1 鱼和熊掌兼得
- 17.2 简单易行的方式： Jython和IronPython
- 17.3 编写 C语言扩展
- 17.3.1 SWIG
- 17.3.2 手工编写扩展
## 第 18 章 程序打包
- 18.1 Setuptools基础
- 18.2 打包
- 18.3 编译扩展
- 18.4 使用 py2exe创建可执行程序
## 第 19 章 趣味编程
- 19.2 编程柔术
- 19.3 原型设计
- 19.4 配置 
- 19.4.1 提取常量
- 19.4.2 配置文件
- 19.5 日志
## 第 20 章 项目 1：自动添加标签
- 20.4.1 找出文本块
- 20.4.2 添加一些标记
- 20.5.1 处理程序
- 20.5.2 处理程序的超类
- 20.5.3 规则
- 20.5.4 规则的超类
- 20.5.5 过滤器
- 20.5.6 解析器
- 20.5.7 创建规则和过滤器
## 第 21 章 项目 2：绘制图表
- 21.4.1 使用 ReportLab绘图
- 21.4.2 绘制折线
- 21.4.3 编写原型
- 21.5.1 获取数据
- 21.5.2 使用 LinePlot类
## 第 22 章 项目 3：万能的 XML
- 22.4.1 创建简单的内容处理程序
- 22.4.2 创建 HTML页面
- 22.5.1 分派器混合类
- 22.5.2 将首部和尾部写入文件的方法以及默认处理程序
- 22.5.3 支持目录
- 22.5.4 事件处理程序
## 第 23 章 项目 4：新闻汇总
## 第 24 章 项目 5：虚拟茶话会
- 24.4.1 ChatServer类
- 24.4.2 ChatSession类 
- 24.5.1 基本的命令解释功能
- 24.5.2 聊天室
- 24.5.3 登录和退出聊天室
- 24.5.4 主聊天室
- 24.5.5 新的服务器
## 第 25 章 项目 6：使用 CGI进行远程编辑
- 25.5.1 创建文件名表单
- 25.5.2 编写编辑器脚本
- 25.5.3 编写保存脚本
- 25.5.4 运行编辑器
## 第 26 章 项目 7：自建公告板
- 26.5.1 编写脚本 main.cgi
- 26.5.2 编写脚本 view.cgi
- 26.5.3 编写脚本 edit.cgi
- 26.5.4 编写脚本 save.cgi
## 第 27 章 项目 8：使用 XML-RPC共享文件
- 27.4.1 实现简单的节点
- 27.4.2 尝试使用
- 27.5.1 创建客户端界面
- 27.5.2 引发异常
- 27.5.3 验证文件名
## 第 28 章 项目 9：使用 GUI共享文件
## 第 29 章 项目 10：自制街机游戏
- 29.2.1 pygame
- 29.2.2 pygame.locals 
- 29.2.3 pygame.display 
- 29.2.4 pygame.font 
- 29.2.5 pygame.sprite 
- 29.2.6 pygame.mouse 
- 29.2.7 pygame.event 
- 29.2.8 pygame.image 
## 附录 A简明教程
## 附录 B Python参考手册

--------
# 《Python编程快速上手:让繁琐工作自动化》
## 第一部分Python编程基础 
## 第1章 Python基础 3 
- 1.1 在交互式环境中输入表达式 3 
- 1.2 整型、浮点型和字符串数据类型 6 
- 1.3 字符串连接和复制 6 
- 1.4 在变量中保存值 7 
- 1.4.1 赋值语句 7 
- 1.4.2 变量名 9 
- 1.5 第一个程序 9 
- 1.6 程序剖析 11 
- 1.6.1 注释 11 
- 1.6.2 print（）函数 11 
- 1.6.3 input（）函数 11 
- 1.6.4 打印用户的名字 12 
- 1.6.5 len（）函数 12 
- 1.6.6 str（）、int（）和float（）函数 13 
- 1.7 小结 15 
- 1.8 习题 15 
## 第2章 控制流 17 
- 2.1 布尔值 18 
- 2.2 比较操作符 19 
- 2.3 布尔操作符 20 
- 2.3.1 二元布尔操作符 20 
- 2.3.2 not操作符 21 
- 2.4 混合布尔和比较操作符 21 
- 2.5 控制流的元素 22 
- 2.5.1 条件 22 
- 2.5.2 代码块 22 
- 2.6 程序执行 23 
- 2.7 控制流语句 23 
- 2.7.1 if语句 23 
- 2.7.2 else语句 24 
- 2.7.3 elif语句 25 
- 2.7.4 while循环语句 30 
- 2.7.5 恼人的循环 31 
- 2.7.6 break语句 33 
- 2.7.7 continue语句 34 
- 2.7.8 for循环和range（）函数 37 
- 2.7.9 等价的while循环 39 
- 2.7.10 range（）的开始、停止和步长参数 39 
- 2.8 导入模块 40from import语句 41 
- 2.9 用sys.exit（）提前结束程序 41 
- 2.10 小结 41 
- 2.11 习题 41 
## 第3章 函数 43 
- 3.1 def语句和参数 44 
- 3.2 返回值和return语句 45 
- 3.3 None值 46 
- 3.4 关键字参数和print（）47 
- 3.5 局部和全局作用域 48 
- 3.5.1 局部变量不能在全局作用域内使用 48 
- 3.5.2 局部作用域不能使用其他局部作用域内的变量 49 
- 3.5.3 全局变量可以在局部作用域中读取 49 
- 3.5.4 名称相同的局部变量和全局变量 50 
- 3.6 global语句 50 
- 3.7 异常处理 52 
- 3.8 一个小程序：猜数字 54 
- 3.9 小结 55 
- 3.10 习题 56 
- 3.11 实践项目 56 
- 3.11.1 Collatz序列 56 
- 3.11.2 输入验证 57 
## 第4章 列表 59 
- 4.1 列表数据类型 59 
- 4.1.1 用下标取得列表中的单个值 60 
- 4.1.2 负数下标 61 
- 4.1.3 利用切片取得子列表 61 
- 4.1.4 用len（）取得列表的长度 62 
- 4.1.5 用下标改变列表中的值 62 
- 4.1.6 列表连接和列表复制 62 
- 4.1.7 用del语句从列表中删除值 63 
- 4.2 使用列表 63 
- 4.2.1 列表用于循环 64 
- 4.2.2 in和notin操作符 65 
- 4.2.3 多重赋值技巧 66 
- 4.3 增强的赋值操作 66 
- 4.4 方法 67 
- 4.4.1 用index（）方法在列表中查找值 67 
- 4.4.2 用append（）和insert（）方法在列表中添加值 68 
- 4.4.3 用remove（）方法从列表中删除值 69 
- 4.4.4 用sort（）方法将列表中的值排序 69 
- 4.5 例子程序：神奇8球和列表 70 
- 4.6 类似列表的类型：字符串和元组 71 
- 4.6.1 可变和不可变数据类型 72 
- 4.6.2 元组数据类型 73 
- 4.6.3 用list（）和tuple（）函数来转换类型 74 
- 4.7 引用 75 
- 4.7.1 传递引用 76 
- 4.7.2 copy模块的copy（）和deepcopy（）函数 77 
- 4.8 小结 78 
- 4.9 习题 78 
- 4.10 实践项目 79 
- 4.10.1 逗号代码 79 
- 4.10.2 字符图网格 79 
## 第5章 字典和结构化数据 81 
- 5.1 字典数据类型 81 
- 5.1.1 字典与列表 82 
- 5.1.2 keys（）、values（）和items（）方法 83 
- 5.1.3 检查字典中是否存在键或值 84 
- 5.1.4 get（）方法 84 
- 5.1.5 setdefault（）方法 85 
- 5.2 漂亮打印 86 
- 5.3 使用数据结构对真实世界建模 87 
- 5.3.1 井字棋盘 88 
- 5.3.2 嵌套的字典和列表 91 
- 5.4 小结 92 
- 5.5 习题 93 
- 5.6 实践项目 93 
- 5.6.1 好玩游戏的物品清单 93 
- 5.6.2 列表到字典的函数，针对好玩游戏物品清单 94 
## 第6章 字符串操作 95 
- 6.1 处理字符串 95 
- 6.1.1 字符串字面量 95 
- 6.1.2 双引号 96 
- 6.1.3 转义字符 96 
- 6.1.4 原始字符串 96 
- 6.1.5 用三重引号的多行字符串 97 
- 6.1.6 多行注释 97 
- 6.1.7 字符串下标和切片 98 
- 6.1.8 字符串的in和notin操作符 98 
- 6.2 有用的字符串方法 99 
- 6.2.1 字符串方法upper（）、lower（）、isupper（）和islower（）99 
- 6.2.2 isX字符串方法 100 
- 6.2.3 字符串方法startswith（）和endswith（）102 
- 6.2.4 字符串方法join（）和split（）102 
- 6.2.5 用rjust（）、ljust（）和center（）方法对齐文本 103 
- 6.2.6 用strip（）、rstrip（）和lstrip（）删除空白字符 104 
- 6.2.7 用pyperclip模块拷贝粘贴字符串 105 
- 6.3 项目：口令保管箱 106 
- 第1步：程序设计和数据结构 106 
- 第2步：处理命令行参数 106 
- 第3步：复制正确的口令 107 
- 6.4 项目：在Wiki标记中添加无序列表 108 
- 第1步：从剪贴板中复制和粘贴 108 
- 第2步：分离文本中的行，并添加星号 109 
- 第3步：连接修改过的行 109 
- 6.5 小结 110 
- 6.6 习题 110 
- 6.7 实践项目 111 
- 表格打印 111 
- 第二部分 自动化任务 
## 第7章 模式匹配与正则表达式 115 
- 7.1 不用正则表达式来查找文本模式 116 
- 7.2 用正则表达式查找文本模式 117 
- 7.2.1 创建正则表达式对象 118 
- 7.2.2 匹配Regex对象 118 
- 7.2.3 正则表达式匹配复习 119 
- 7.3 用正则表达式匹配更多模式 119 
- 7.3.1 利用括号分组 119 
- 7.3.2 用管道匹配多个分组 120 
- 7.3.3 用问号实现可选匹配 121 
- 7.3.4 用星号匹配零次或多次 121 
- 7.3.5 用加号匹配一次或多次 122 
- 7.3.6 用花括号匹配特定次数 122 
- 7.4 贪心和非贪心匹配 123 
- 7.5 findall（）方法 124 
- 7.6 字符分类 124 
- 7.7 建立自己的字符分类 125 
- 7.8 插入字符和美元字符 126 
- 7.9 通配字符 126 
- 7.9.1 用点—星匹配所有字符 127 
- 7.9.2 用句点字符匹配换行 127 
- 7.10 正则表达式符号复习 128 
- 7.11 不区分大小写的匹配 128 
- 7.12 用sub（）方法替换字符串 129 
- 7.13 管理复杂的正则表达式 129 
- 7.14 组合使用re.IGNORECASE、re.DOTALL和re.VERBOSE 130 
- 7.15 项目：电话号码和Email地址提取程序 130 
- 第1步：为电话号码创建一个正则表达式 131 
- 第2步：为email地址创建一个正则表达式 132 
- 第3步：在剪贴板文本中找到所有匹配 132 
- 第4步：所有匹配连接成一个字符串，复制到剪贴板 133 
- 第5步：运行程序 133 
- 第6步：类似程序的构想 134 
- 7.16 小结 134 
- 7.17 习题 134 
- 7.18 实践项目 136 
- 7.18.1 强口令检测 136 
- 7.18.2 strip（）的正则表达式版本 136 
## 第8章 读写文件 137 
- 8.1 文件与文件路径 137 
- 8.1.1 Windows上的倒斜杠以及OS X和Linux上的正斜杠 138 
- 8.1.2 当前工作目录 139 
- 8.1.3 绝对路径与相对路径 139 
- 8.1.4 用os.makedirs（）创建新文件夹 140 
- 8.1.5 os.path模块 140 
- 8.1.6 处理绝对路径和相对路径 141 
- 8.1.7 查看文件大小和文件夹内容 142 
- 8.1.8 检查路径有效性 143 
- 8.2 文件读写过程 144 
- 8.2.1 用open（）函数打开文件 145 
- 8.2.2 读取文件内容 145 
- 8.2.3 写入文件 146 
- 8.3 用shelve模块保存变量 147 
- 8.4 用pprint.pformat（）函数保存变量 148 
- 8.5 项目：生成随机的测验试卷文件 149 
- 第1步：将测验数据保存在一个字典中 149 
- 第2步：创建测验文件，并打乱问题的次序 150 
- 第3步：创建答案选项 151 
- 第4步：将内容写入测验试卷和答案文件 151 
- 8.6 项目：多重剪贴板 153 
- 第1步：注释和shelf设置 153 
- 第2步：用一个关键字保存剪贴板内容 154 
- 第3步：列出关键字和加载关键字的内容 154 
- 8.7 小结 155 
- 8.8 习题 155 
- 8.9 实践项目 156 
- 8.9.1 扩展多重剪贴板 156 
- 8.9.2 疯狂填词 156 
- 8.9.3 正则表达式查找 156 
## 第9章 组织文件 157 
- 9.1 shutil模块 158 
- 9.1.1 复制文件和文件夹 158 
- 9.1.2 文件和文件夹的移动与改名 158 
- 9.1.3 永久删除文件和文件夹 160 
- 9.1.4 用send2trash模块安全地删除 160 
- 9.2 遍历目录树 161 
- 9.7 用zipfile模块压缩文件 162 
- 9.3.1 读取ZIP文件 163 
- 9.3.2 从ZIP文件中解压缩 164 
- 9.3.3 创建和添加到ZIP文件 164 
- 9.4 项目：将带有美国风格日期的文件改名为欧洲风格日期 165 
- 第1步：为美国风格的日期创建一个正则表达式 165 
- 第2步：识别文件名中的日期部分 166 
- 第3步：构成新文件名，并对文件改名 167 
- 第4步：类似程序的想法 168 
- 9.5 项目：将一个文件夹备份到一个ZIP文件 168 
- 第1步：弄清楚ZIP文件的名称 168 
- 第2步：创建新ZIP文件 169 
- 第3步：遍历目录树并添加到ZIP文件。170 
- 第4步：类似程序的想法 170 
- 9.6 小结 171 
- 9.7 习题 171 
- 9.8 实践项目 171 
- 9.8.1 选择性拷贝 171 
- 9.8.2 删除不需要的文件 172 
- 9.8.3 消除缺失的编号 172 
## 第10章 调试 173 
- 10.1 抛出异常 174 
- 10.2 取得反向跟踪的字符串 175 
- 10.3 断言 176 
- 10.3.1 在交通灯模拟中使用断言 177 
- 10.3.2 禁用断言 178 
- 10.4 日志 178 
- 10.4.1 使用日志模块 178 
- 10.4.2 不要用print（）调试 180 
- 10.4.3 日志级别 180 
- 10.4.4 禁用日志 181 
- 10.4.5 将日志记录到文件 182 
- 10.5 IDLE的调试器 182 
- 10.5.1 Go 183 
- 10.5.2 Step 183 
- 10.5.3 Over 183 
- 10.5.4 Out 183 
- 10.5.5 Quit 183 
- 10.5.6 调试一个数字相加的程序 184 
- 10.5.7 断点 185 
- 10.6 小结 187 
- 10.7 习题 187 
- 10.7 实践项目 188 
- 调试硬币抛掷 188 
## 第11章 从Web抓取信息 189 
- 11.1 项目：利用webbrowser模块的mapIt.py 190 
- 第1步：弄清楚URL 190 
- 第2步：处理命令行参数 191 
- 第3步：处理剪贴板内容，加载浏览器 191 
- 第4步：类似程序的想法 192 
- 11.2 用requests模块从Web下载文件 192 
- 11.2.1 用requests.get（）函数下载一个网页 193 
- 11.2.2 检查错误 193 
- 10.3 将下载的文件保存到硬盘 194 
- 10.4 HTML 195 
- 10.4.1 学习HTML的资源 195 
- 10.4.2 快速复习 195 
- 10.4.3 查看网页的HTML源代码 196 
- 10.4.4 打开浏览器的开发者工具 197 
- 10.4.5 使用开发者工具来寻找HTML元素 198 
- 10.5 用BeautifulSoup模块解析HTML 199 
- 10.5.1 从HTML创建一个BeautifulSoup对象 200 
- 10.5.2 用select（）方法寻找元素 200 
- 10.5.3 通过元素的属性获取数据 202 
- 10.6 项目：“I’mFeelingLucky”Google查找 202 
- 第1步：获取命令行参数，并请求查找页面 203 
- 第2步：找到所有的结果 203第3步：针对每个结果打开Web浏览器 204 
- 第4步：类似程序的想法 205 
- 10.7 项目：下载所有XKCD漫画 205 
- 第1步：设计程序 206 
- 第2步：下载网页 207 
- 第3步：寻找和下载漫画图像 207 
- 第4步：保存图像，找到前一张漫画 208 
- 第4步：类似程序的想法 209 
- 10.8 用selenium模块控制浏览器 210 
- 10.8.1 启动selenium控制的浏览器 210 
- 10.8.2 在页面中寻找元素 211 
- 10.8.3 点击页面 212 
- 10.8.4 填写并提交表单 212 
- 10.8.5 发送特殊键 213 
- 10.8.6 点击浏览器按钮 213 
- 10.8.7 关于selenium的更多信息 214 
- 10.9 小结 214 
- 10.10 习题 214 
- 10.11 实践项目 215 
- 10.11.1 命令行邮件程序 215 
- 10.11.2 图像网站下载 215 
- 10.11.32048215 
- 10.11.4 链接验证 215 
## 第12章 处理Excel电子表格 217 
- 12.1 Excel文档 217 
- 12.2 安装openpyxl模块 218 
- 12.3 读取Excel文档 218 
- 12.3.1 用openpyxl模块打开Excel文档 219 
- 12.3.2 从工作簿中取得工作表 219 
- 12.3.3 从表中取得单元格 220 
- 12.3.4 列字母和数字之间的转换 221 
- 12.3.5 从表中取得行和列 222 
- 12.3.6 工作薄、工作表、单元格 223 
- 12.4 项目：从电子表格中读取数据 223 
- 第1步：读取电子表格数据 224 
- 第2步：填充数据结构 225 
- 第3步：将结果写入文件 226 
- 第4步：类似程序的思想 227 
- 12.5 写入Excel文档 227 
- 12.5.1 创建并保存Excel文档 227 
- 12.5.2 创建和删除工作表 228 
- 12.5.3 将值写入单元格 229 
- 12.6 项目：更新一个电子表格 229 
- 第1步：利用更新信息建立数据结构 230 
- 第2步：检查所有行，更新不正确的价格 231 
- 第4步：类似程序的思想 231 
- 12.7 设置单元格的字体风格 232 
- 12.8 Font对象 232 
- 12.9 公式 234 
- 12.10 调整行和列 235 
- 12.10.1 设置行高和列宽 235 
- 12.10.2 合并和拆分单元格 236 
- 12.10.3 冻结窗格 237 
- 12.10.4 图表 238 
- 12.11 小结 240 
- 12.11 习题 240 
- 12.12 实践项目 241 
- 12.12.1 乘法表 241 
- 12.12.2 空行插入程序 241 
- 12.12.3 电子表格单元格翻转程序 242 
- 12.12.4 文本文件到电子表格 242 
- 12.12.5 电子表格到文本文件 242 
## 第13章 处理PDF和Word文档 243 
- 13.1 PDF文档 243 
- 13.1.1 从PDF提取文本 244 
- 13.1.2 解密PDF 245 
- 13.1.3 创建PDF 246 
- 13.1.4 拷贝页面 246 
- 13.1.5 旋转页面 247 
- 13.1.6 叠加页面 248 
- 13.1.7 加密PDF 249 
- 13.2 项目：从多个PDF中合并选择的页面 250 
- 第1步：找到所有PDF文件 250 
- 第2步：打开每个PDF文件 251 
- 第3步：添加每一页 252 
- 第4步：保存结果 252 
- 第5步：类似程序的想法 253 
- 13.3 Word文档 253 
- 13.3.1 读取Word文档 254 
- 13.3.2 从.docx文件中取得完整的文本 254 
- 13.3.3 设置Paragraph和Run对象的样式 255 
- 13.3.4 创建带有非默认样式的Word文档 257 
- 13.3.5 Run属性 257 
- 13.3.6 写入Word文档 258 
- 13.3.7 添加标题 260 
- 13.3.8 添加换行符和换页符 261 
- 13.3.9 添加图像 261 
- 13.4 小结 262 
- 13.5 习题 262 
- 13.6 实践项目 263 
- 13.6.1 PDF偏执狂 263 
- 13.6.2 定制邀请函，保存为Word文档 263 
- 13.6.3 暴力PDF口令破解程序 264 
## 第14章 处理CSV文件和JSON数据 265 
- 14.1 csv模块 265 
- 14.2.1 Reader对象 266 
- 14.2.2 在for循环中，从Reader对象读取数据 267 
- 14.2.3 Writer对象 268 
- 14.2.4 delimiter和lineterminator关键字参数 269 
- 14.3 项目：从CSV文件中删除表头 269 
- 第1步：循环遍历每个CSV文件 270 
- 第2步：读入CSV文件 270 
- 第3步：写入CSV文件，没有 
- 第一行 271 
- 第4步：类似程序的想法 272 
- 14.4 JSON和API 272 
- 14.5 json模块 273 
- 14.5.1 用loads（）函数读取 
- JSON 273 
- 14.5.2 用dumps函数写出 
- JSON 273 
- 14.6 项目：取得当前的天气数据 274 
- 第1步：从命令行参数获取位置 274 
- 第2步：下载JSON数据 275 
- 第3步：加载JSON数据并打印天气 275 
- 第4步：类似程序的想法 277 
- 14.7 小结 277 
- 14.8 习题 277 
- 14.9 实践项目 277 
- Excel到CSV的转换程序 277 
## 第15章 保持时间、计划任务和启动程序 279 
- 15.1 time模块 279 
- 15.1.1 time.time（）函数 279 
- 15.1.2 time.sleep（）函数 280 
- 15.2 数字四舍五入 281 
- 15.3 项目：超级秒表 282 
- 第1步：设置程序来记录时间 282 
- 第2步：记录并打印单圈时间 283 
- 第4步：类似程序的想法 283 
- 15.4 datetime模块 284 
- 15.4.1 timedelta数据类型 285 
- 15.4.2 暂停直至特定日期 286 
- 15.4.3 将datetime对象转换为字符串 287 
- 15.4.4 将字符串转换成datetime对象 288 
- 15.5 回顾Python的时间函数 288 
- 15.6 多线程 289 
- 15.6.1 向线程的目标函数传递参数 290 
- 15.6.2 并发问题 291 
- 15.7 项目：多线程XKCD下载程序 291 
- 第1步：修改程序以使用函数 292 
- 第2步：创建并启动线程 293 
- 第3步：等待所有线程结束 293 
- 15.8 从Python启动其他程序 294 
- 15.8.1 向Popen（）传递命令行参数 295 
- 15.8.2 TaskScheduler、launchd和 
- cron 296 
- 15.8.3 用Python打开网站 296 
- 15.8.4 运行其他Python脚本 296 
- 15.8.5 用默认的应用程序打开文件 297 
- 15.9 项目：简单的倒计时程序 298 
- 第1步：倒计时 298 
- 第2步：播放声音文件 298 
- 第3步：类似程序的想法 299 
- 15.10 小结 299 
- 15.11 习题 300 
- 15.12 实践项目 300 
- 15.12.1 美化的秒表 300 
- 15.12.2 计划的Web漫画下载 301 
## 第16章 发送电子邮件和短信 303 
- 16.1 SMTP 303 
- 16.2 发送电子邮件 304 
- 16.2.1 连接到SMTP服务器 304 
- 16.2.2 发送SMTP的“Hello”消息 305 
- 16.2.3 开始TLS加密 306 
- 16.2.4 登录到SMTP服务器 306 
- 16.2.5 发送电子邮件 306 
- 16.2.6 从SMTP服务器断开 307 
- 16.3 IMAP 307 
- 16.4 用IMAP获取和删除电子邮件 307 
- 16.4.1 连接到IMAP服务器 308 
- 16.4.2 登录到IMAP服务器 309 
- 16.4.3 搜索电子邮件 309 
- 16.4.4 选择文件夹 309 
- 16.4.5 执行搜索 310 
- 16.4.6 大小限制 312 
- 16.4.7 取邮件并标记为已读 312 
- 16.4.8 从原始消息中获取电子邮件地址 313 
- 16.4.9 从原始消息中获取正文 314 
- 16.4.10 删除电子邮件 315 
- 16.4.11 从IMAP服务器断开 315 
- 16.5 项目：向会员发送会费提醒电子邮件 316 
- 第1步：打开Excel文件 316 
- 第2步：查找所有未付成员 317 
- 第3步：发送定制的电子邮件提醒 318 
- 16.6 用Twilio发送短信 319 
- 16.6.1 注册Twilio账号 319 
- 16.6.2 发送短信 320 
- 16.7 项目：“只给我发短信”模块 321 
- 16.8 小结 322 
- 16.9 习题 323 
- 16.10 实践项目 323 
- 16.10.1 随机分配家务活的电子邮件程序 323 
- 16.10.2 伞提醒程序 324 
- 16.10.3 自动退订 324 
- 16.10.4 通过电子邮件控制你的电脑 324 
## 第17章 操作图像 327 
- 17.1 计算机图像基础 327 
- 17.1.1 颜色和RGBA值 328 
- 17.1.2 坐标和Box元组 329 
- 17.2 用Pillow操作图像 330 
- 17.2.1 处理Image数据类型 331 
- 17.2.2 裁剪图片 332 
- 17.2.3 复制和粘贴图像到其他图像 333 
- 17.2.4 调整图像大小 335 
- 17.2.5 旋转和翻转图像 336 
- 17.2.6 更改单个像素 338 
- 17.3 项目：添加徽标 339 
- 第1步：打开徽标图像 340 
- 第2步：遍历所有文件并打开图像 341 
- 第3步：调整图像的大小 341 
- 第4步：添加徽标，并保存更改 342 
- 第5步：类似程序的想法 343 
- 17.4 在图像上绘画 344 
- 17.4.1 绘制形状 344 
- 17.4.2 绘制文本 346 
- 17.5 小结 347 
- 17.6 习题 348 
- 17.7 实践项目 348 
- 17.7.1 扩展和修正本章项目的程序 348 
- 17.7.2 在硬盘上识别照片文件夹 349 
- 17.7.3 定制的座位卡 350 
## 第18章 用GUI自动化控制键盘和鼠标 351 
- 18.1 安装pyautogui模块 351 
- 18.2 走对路 352 
- 18.2.1 通过注销关闭所有程序 352 
- 18.2.2 暂停和自动防故障装置 352 
- 18.3 控制鼠标移动 353 
- 18.3.1 移动鼠标 354 
- 18.3.2 获取鼠标位置 354 
- 18.4 项目：“现在鼠标在哪里？”355 
- 第1步：导入模块 355 
- 第2步：编写退出代码和无限循环 355 
- 第3步：获取并打印鼠标坐标。356 
- 18.5 控制鼠标交互 357 
- 18.5.1 点击鼠标 357 
- 18.5.2 拖动鼠标 357 
- 18.5.3 滚动鼠标 359 
- 18.6 处理屏幕 360 
- 18.6.1 获取屏幕快照 360 
- 18.6.2 分析屏幕快照 360 
- 18.7 项目：扩展mouseNow程序 361 
- 18.8 图像识别 362 
- 18.9 控制键盘 363 
- 18.9.1 通过键盘发送一个字符串 363 
- 18.9.2 键名 364 
- 18.9.3 按下和释放键盘 365 
- 18.9.4 热键组合 365 
- 18.10 复习PyAutoGUI的函数 366 
- 18.11 项目：自动填表程序 367 
- 第1步：弄清楚步骤 368 
- 第2步：建立坐标 368 
- 第3步：开始键入数据 370 
- 第4步：处理选择列表和单选按钮 371 
- 第5步：提交表单并等待 372 
- 18.12 小结 372 
- 18.13 习题 373 
- 18.14 实践项目 373 
- 18.14.1 看起来很忙 373 
- 18.14.2 即时通信机器人 373 
- 18.14.3 玩游戏机器人指南 374 
## 附录A 安装第三方模块 375 
## 附录B 运行程序 377 
## 附录C 习题答案 381

----
# 《深入理解Android内核设计思想》
## 第1篇 Android编译篇 
## 第1章 Android系统简介 
- 1.1 Android系统发展历程 
- 1.2 Android系统特点 
- 1.3 Android系统框架 
## 第2章 Android源码下载及编译 
- 2.1 Android源码下载指南 
- 2.1.1 基于Repo和Git的版本管理 
- 2.1.2 Android源码下载流程 
- 2.2 原生态系统编译指南 
- 2.2.1 建立编译环境 
- 2.2.2 编译流程 
- 2.3 定制产品的编译与烧录 
- 2.3.1 定制新产品 
- 2.3.2 Linux内核编译 
- 2.3.3 烧录 
- 2.4 Android系统映像文件 
- 2.4.1 boot.img 
- 2.4.2 ramdisk.img 
- 2.4.3 system.img 
- 2.5 OTA系统升级 
- 2.5.1 生成升级包 
- 2.5.2 获取升级包 
- 2.5.3 OTA升级—RecoveryMode 
- 2.6 Android反编译 
## 第3章 Android编译系统 
- 3.1 Makefile入门 
- 3.2 Android编译系统 
- 3.2.1 Makefile依赖树的概念 
- 3.2.2 树根节点droid 
- 3.2.3 main.mk解析 
- 3.2.4 droidcore节点 
- 3.2.5 dist_files 
- 3.2.6 Android.mk的编写规则 
## 第2篇 Android原理篇 
## 第4章 操作系统基础 
- 4.1 计算机体系结构（Computer Architecture） 
- 4.1.1 冯·诺依曼结构 
- 4.1.2 哈佛结构 
- 4.2 什么是操作系统 
- 4.3 进程间通信的经典实现 
- 4.3.1 共享内存（Shared Memory） 
- 4.3.2 管道（Pipe） 
- 4.3.3 Unix Domain Socket 
- 4.3.4 RPC（RemoteProcedure Calls） 
- 4.4 同步机制的经典实现 
- 4.4.1 信号量（Semaphore） 
- 4.4.2 Mutex 
- 4.4.3 管程（Monitor） 
- 4.4.4 同步范例 
- 4.5 Android中的同步机制 
- 4.5.1 进程间同步——Mutex 
- 4.5.2 条件判断——Condition 
- 4.5.3 “栅栏、障碍”——Barrier 
- 4.5.4 加解锁的自动化操作——Autolock 
- 4.6 操作系统内存管理基础 
- 4.6.1 虚拟内存（Virtual Memory） 
- 4.6.2 内存保护（Memory Protection） 
- 4.6.3 内存分配与回收 
- 4.6.4 进程间通信——mmap 
- 4.7 Android中的Low Memory Killer 
- 4.8 Android匿名共享内存（Anonymous Shared Memory） 
- 4.8.1 Ashmem设备 
- 4.8.2 Ashmem应用实例 
- 4.9 JNI 
- 4.9.1 Java函数的本地实现 
- 4.9.2 本地代码访问JVM 
- 4.10 学习Android系统的两条线索 
## 第5章 Android进程／线程管理 
- 5.1 Android进程和线程 
- 5.2 Handler， MessageQueue，Runnable与Looper 
- 5.3 UI主线程——ActivityThread 
- 5.4 Thread类 
- 5.4.1 Thread类的内部原理 
- 5.4.2 Thread休眠和唤醒 
- 5.4.3 Thread实例 
- 5.5 Android应用程序的典型启动流程 
## 第6章 进程间通信——Binder 
- 6.1 智能指针 
- 6.1.1 智能指针的设计理念 
- 6.1.2 强指针sp 
- 6.1.3 弱指针wp 
- 6.2 进程间的数据传递载体——Parcel 
- 6.3 Binder驱动与协议 
- 6.3.1 打开Binder驱动——binder_open 
- 6.3.2 binder_mmap 
- 6.3.3 binder_ioctl 
- 6.4 “DNS”服务器——ServiceManager（Binder Server） 
- 6.4.1 ServiceManager的启动 
- 6.4.2 ServiceManager的构建 
- 6.4.3 获取ServiceManager服务——设计思考 
- 6.4.4 ServiceManagerProxy 
- 6.4.5 IBinder和BpBinder 
- 6.4.6 ProcessState和IPCThreadState 
- 6.5 Binder客户端——Binder Client 
- 6.6 Android接口描述语言——AIDL 
- 6.7 匿名Binder Server 
## 第7章 Android启动过程简析 
- 7.1 第一个系统进程（init） 
- 7.1.1 init.rc语法 
- 7.1.2 init.rc实例分析 
- 7.2 系统关键服务的启动简析 
- 7.2.1 Android的“DNS服务器”——ServiceManager 
- 7.2.2 “孕育”新的线程和进程——Zygote 
- 7.2.3 Android的“系统服务”——SystemServer 
## 第8章 管理Activity和组件运行状态的系统进程——Activity ManagerService （AMS） 
- 8.1 AMS功能概述 
- 8.2 管理当前系统中Activity状态——Activity Stack 
- 8.3 startActivity流程 
- 8.4 完成同一任务的“集合”——Activity Task 
- 8.4.1 “后进先出”——Last In，First Out 
- 8.4.2 管理Activity Task 
## 第9章 GUI系统之SurfaceFlinger 
- 9.1 OpenGL ES与EGL 
- 9.2 Android的硬件接口——HAL 
- 9.3 Android终端显示设备的“化身”——Gralloc与Framebuffer 
- 9.4 Android中的本地窗口 
- 9.4.1 FramebufferNativeWindow 
- 9.4.2 应用程序端的本地窗口——Surface 
- 9.5 BufferQueue详解 
- 9.5.1 BufferQueue的内部原理 
- 9.5.2 BufferQueue中的缓冲区分配 
- 9.5.3 应用程序的典型绘图流程 
- 9.5.4 应用程序与BufferQueue的关系 
- 9.6 SurfaceFlinger 
- 9.6.1 “黄油计划”——Project Butter 
- 9.6.2 SurfaceFlinger的启动 
- 9.6.3 接口的服务端——Client 
- 9.7 VSync的产生和处理 
- 9.7.1 VSync信号的产生和分发 
- 9.7.2 VSync信号的处理 
- 9.7.3 handleMessageTransaction 
- 9.7.4 “界面已经过时／无效，需要重新绘制”——handleMessageInvalidate 
- 9.7.5 合成前的准备工作——precomposition 
- 9.7.6 可见区域——rebuildLayerStacks 
- 9.7.7 为“Composition”搭建环境——setupHWComposer 
- 9.7.8 doDebugFlashRegions 
- 9.7.9 docomposition 
## 第10章 GUI系统之“窗口管理员”——WMS 
- 10.1 “窗口管理员”——WMS综述 
- 10.1.1 WMS的启动 
- 10.1.2 WMS的基础功能 
- 10.1.3 WMS的工作方式 
- 10.1.4 WMS，AMS与Activity间的联系 
- 10.2 窗口属性 
- 10.2.1 窗口类型与层级 
- 10.2.2 窗口策略（Window Policy） 
- 10.2.3 窗口属性（LayoutParams） 
- 10.3 窗口的添加过程 
- 10.3.1 系统窗口的添加过程 
- 10.3.2 Activity窗口的添加过程 
- 10.3.3 窗口添加实例 
- 10.4 Surface管理 
- 10.4.1 Surface申请流程（relayout） 
- 10.4.2 Surface的跨进程传递 
- 10.4.3 Surface的业务操作 
- 10.5 performLayoutAndPlaceSurfacesLockedInner 
- 10.6 窗口大小的计算过程 
- 10.7 启动窗口的添加与销毁 
- 10.7.1 启动窗口的添加 
- 10.7.2 启动窗口的销毁 
- 10.8 窗口动画 
- 10.8.1 窗口动画类型 
- 10.8.2 动画流程跟踪——WindowStateAnimator 
- 10.8.3 AppWindowAnimator 
- 10.8.4 动画的执行过程 
## 第11章 让你的界面炫彩起来的GUI系统之View体系 
- 11.1 应用程序中的View框架 
- 11.2 Activity中View Tree的创建过程 
- 11.3 在WMS中注册窗口 
- 11.4 ViewRoot的基本工作方式 
- 11.5 View Tree的遍历时机 
- 11.6 View Tree的遍历流程 
- 11.7 View和ViewGroup属性 
- 11.7.1 View的基本属性 
- 11.7.2 ViewGroup的属性 
- 11.7.3 View，ViewGroup和ViewParent 
- 11.7.4 Callback接口 
- 11.8 “作画“工具集——Canvas 
- 11.8.1 “绘制UI”——Skia 
- 11.8.2 数据中介——Surface.lockCanvas 
- 11.8.3 解锁并提交结果——unlockCanvasAndPost 
- 11.9 draw和onDraw 
- 11.10 View中的消息传递 
- 11.10.1 View中TouchEvent的投递流程 
- 11.10.2 ViewGoup中TouchEvent的投递流程 
- 11.11 View动画 
## 第12章 “问渠哪得清如许，为有源头活水来”——InputManagerService与输入事件 
- 12.1 事件的分类 
- 12.2 事件的投递流程 
- 12.2.1 InputManagerService 
- 12.2.2 InputReaderThread 
- 12.2.3 InputDispatcherThread 
- 12.2.4 ViewRootImpl对事件的派发 
## 第13章 应用不再同质化——音频系统 
- 13.1 音频基础 
- 13.1.1 声波 
- 13.1.2 音频的录制、存储与回放 
- 13.1.3 音频采样 
- 13.1.4 Nyquist–Shannon采样定律 
- 13.1.5 声道和立体声 
- 13.1.6 声音定级——Weber–Fechner law 
- 13.1.7 音频文件格式 
- 13.2 音频框架 
- 13.2.1 Linux中的音频框架 
- 13.2.2 TinyAlsa 
- 13.2.3 Android系统中的音频框架 
- 13.3 音频系统的核心——AudioFlinger 
- 13.3.1 AudioFlinger服务的启动和运行 
- 13.3.2 AudioFlinger对音频设备的管理 
- 13.3.3 PlaybackThread的循环主体 
- 13.3.4 AudioMixer 
- 13.4 策略的制定者——AudioPolicyService 
- 13.4.1 AudioPolicyService概述 
- 13.4.2 AudioPolicyService的启动过程 
- 13.4.3 AudioPolicyService与音频设备 
- 13.5 音频流的回放——AudioTrack 
- 13.5.1 AudioTrack应用实例 
- 13.5.2 AudioPolicyService的路由实现 
- 13.6 音频数据流 
- 13.6.1 AudioTrack中的音频流 
- 13.6.2 AudioTrack和AudioFlinger间的数据交互 
- 13.6.3 AudioMixer中的音频流 
- 13.7 音量控制 
- 13.8 音频系统的上层建筑 
- 13.8.1 从功能入手 
- 13.8.2 MediaPlayer 
- 13.8.3 MediaRecorder 
- 13.8.4 一个典型的多媒体录制程序 
- 13.8.5 MediaRecorder源码解析 
- 13.8.6 MediaPlayerService简析 
- 13.9 Android支持的媒体格式 
- 13.9.1 音频格式 
- 13.9.2 视频格式 
- 13.9.3 图片格式 
- 13.9.4 网络流媒体 
- 13.10 ID3信息简述 
- 13.11 Android多媒体文件管理 
- 13.11.1 MediaStore 
- 13.11.2 多媒体文件信息的存储“仓库”——MediaProvider 
- 13.11.3 多媒体文件管理中的“生产者”——MediaScanner 
- …… 
## 第3篇 应用原理篇 
## 第4篇 Android系统工具

----
# 《深入理解BootLoader》
## 第1章 BootLoader的概念 
- 1.1 BootLoader的角色 
- 1.2 BootLoader的来历 
- 1.3 BootLoader的概念 
- 1.3.1 MCU下的BootLoader 
- 1.3.2嵌入式ARM和Linux下的BootLoader 
- 1.3.3 PC下的引导流程 
## 第2章L．nux开发环境 
- 2.1编辑器Vim 
- 2.1.1 Vim介绍 
- 2.1.2 Vim的两个基本模式 
- 2.1.3 Vim的两个常用模式 
- 2.1.4 Vim的启动与退出 
- 2.1.5 Vim下光标的移动 
- 2.1.6 Vim下的复制、粘贴和删除 
- 2.1.7 Vim下的撤销和重复 
- 2.1.8 Vim下的查找和替换 
- 2.1.9 Vim下的文件恢复 
- 2.1.10 Vim下的插件 
- 2.2编译器GCC和交叉编译器 
- 2.2.1 GCC的编译流程 
- 2.2.2 GCC的常用编译选项 
- 2.2.3交叉编译器 
- 2.3常用shell命令和脚本 
- 2.3.1 find命令 
- 2.3.2 grep命令 
- 2.3.3管道与重定向 
- 2.4 工程管理Make和Makefile 
- 2.4.1 Make和Makefile 
- 2.4.2 Makefile中的变量 
- 2.4.3 自动推导规则 
- 2.4.4嵌套的Makefile 
- 2.4.5 Make伪目标 
- 2.4.6自动化变量 
- 2.4.7 Make的内嵌函数 
## 第3章 ARM体系结构 
- 3.1处理器模式 
- 3.2异常 
- 3.3 ARM寄存器 
- 3.4通用寄存器 
- 3.4.1未分组的寄存器：R0～R7 
- 3.4.2分组的寄存器：R8～R14 
- 3.4.3寄存器R15:程序计数器 
- 3.5程序状态寄存器 
- 3.5.1 PSR位的类型 
- 3.5.2条件标志位 
- 3.5.3中断禁止位 
- 3.5.4模式位 
- 第4章ARM指令集 
- 4.1数据处理指令 
- 4.2分支指令 
- 4.3软中断指令 
- 4.4程序状态寄存器指令 
- 4.5协处理器指令 
- 4.6加载常量的伪指令 
## 第5章ARM寻址模式 
- 5.1寻址模式1-数据处理指令的寻址模式 
- 5.1.1编码格式 
- 5.1.2移位器操作数 
- 5.1.3数据处理操作——立即数 
- 5.1.4数据处理操作——寄存器 
- 5.1.5数据处理操作——立即数的逻辑左移 
- 5.1.6数据处理操作——寄存器的逻辑左移 
- 5.1.7数据处理操作——立即数的逻辑右移 
- 5.1.8数据处理操作——寄存器的逻辑右移 
- 5.1.9数据处理操作——立即数的算术右移 
- 5.1.10数据处理操作——寄存器的算术右移 一 
- 5 .1.11数据处理操作——立即数的循环右移 一 
- 5.1.12数据处理操作——寄存器的循环右移 一 
- 5.1.13数据处理操作——扩展的循环右移 
- 5.2寻址模式2-字或无符号字节的load/store指令 
- 5.2.1编码格式 
- 5.2.2立即数偏移 
- 5.2.3寄存器偏移 
- 5.2.4比例寄存器偏移 
- 5.2.5立即数的前变址寻址 
- 5.2.6寄存器的前变址寻址 
- 5.2.7 比例寄存器的前变址寻址 
- 5.2.8立即数的后变址寻址 
- 5.2.9寄存器的后变址寻址 
- 5.2.10比例寄存器的后变址寻址 
- 5.3 寻址模式3-杂类load/store指令的寻址方式 
- 5.3.1编码格式 
- 5.3.2杂类load/store-立即数偏移 
## 第6章编译和链接 
## 第7章链接脚本 
## 第8章Linux下开发流水灯 
## 第9章U-Boot代码的分析 
## 第10章实现简单的BootLoader

-------
# 《Linux C编程从入门到精通》
## 第1章 Linux基础 
- 1.1 Linux的起源、发展和分类 
- 1.1.1 Linux的起源、特点和版本号 
- 1.1.2 Linux的结构 
- 1.1.3 Linux操作系统的分类 
- 1.1.4 Linux中的几个术语 
- 1.2 Linux的Shell 
- 1.2.1 常见的Shell 
- 1.2.2 Shell和终端 
- 1.2.3 Shell的工作方式 
- 1.2.4 Shell的启动 
- 1.3 Shell的使用基础 
- 1.3.1 Shell命令的标准格式 
- 1.3.2 Shell的通配符 
- 1.3.3 Shell中的引号 
- 1.3.4 Shell中的注释符 
- 1.4 Linux的常用命令 
- 1.4.1 文件操作命令 
- 1.4.2 目录操作命令 
- 1.4.3 其他常用命令 
## 第2章 在Linux中编写C语言代码 
- 2.1 Linux中C语言程序开发流程和工具介绍 
- 2.1.1 C语言程序开发流程 
- 2.1.2 C语言的开发工具 
- 2.2 Linux中的C语言编译器gcc 
- 2.2.1 gcc的安装 
- 2.2.2 gcc的使用 
- 2.3 Linux中的代码编辑器vim 
- 2.3.1 启动与退出vim 
- 2.3.2 vim的命令行模式 
- 2.3.3 vim的插入模式 
- 2.3.4 vim的底行模式 
- 2.3.5 vim的应用实例 
- 2.4 Linux中的调试环境gdb 
- 2.4.1 gdb功能简介 
- 2.4.2 gdb的调用 
- 2.4.3 gdb运行模式的选择 
- 2.4.4 gdb应用实例 
## 第3章 Linux编程进阶 
- 3.1 Linux如何执行一个程序 
- 3.2 Linux的程序存储空间 
- 3.3 Linux C的main函数 
- 3.4 Linux 的出错处理 
- 3.5 Linux C的标准输入和输出函数 
- 3.5.1 标准输出函数printf 
- 3.5.2 标准输入函数scanf 
- 3.5.3 标准输入／输出函数应用实例 
- 3.6 Linux C的内存分配 
- 3.7 Linux C的系统调用和库函数 
- 3.8 Linux 库函数的说明和应用实例 
- 3.8.1 平方根函数 
- 3.8.2 随机数产生函数 
- 3.8.3 大小写字母测试函数 
- 3.8.4 系统时间和日期函数 
- 3.8.5 系统登录用户名操作函数 
- 3.8.6 单字符输出函数 
- 3.8.7 求“不大于”整数函数 
- 3.8.8 “拆分”浮点数函数 
- 3.8.9 字符串转换函数 
- 3.8.10 字符串复制函数 
- 3.8.11 字符串长度计算函数 
- 3.8.12 字符串连接函数 
- 3.8.13 字符串复制函数 
- 3.8.14 字符串比较函数 
- 3.8.15 字符串查找函数 
- 3.8.16 内存分配函数 
- 3.8.17 内存映射函数 
## 第4章 Linux的文件编程 
- 4.1 Linux文件系统简介 
- 4.1.1 Linux文件系统基础 
- 4.1.2 Linux文件类型介绍 
- 4.2 Linux的基本文件操作函数 
- 4.2.1 打开文件函数 
- 4.2.2 关闭文件函数 
- 4.2.3 创建文件函数 
- 4.2.4 写文件函数 
- 4.2.5 文件偏移定位函数 
- 4.2.6 读文件函数 
- 4.3 Linux的高级文件操作函数 
- 4.3.1 文件状态操作函数 
- 4.3.2 时间相关函数 
- 4.3.3 文件的访问权限说明 
- 4.3.4 测试文件访问权限函数 
- 4.3.5 umask函数 
- 4.3.6 chmod函数和fchmod函数 
- 4.3.7 rename函数 
- 4.3.8 文件的其他高级操作函数 
- 4.4 目录文件操作 
- 4.4.1 mkdir和rmdir函数 
- 4.4.2 chdir、fchdir和getcmd函数 
- 4.4.3 opendir、closedir和readdir函数 
## 第5章 Linux的流编程 
- 5.1 Linux流操作的基础 
- 5.1.1 流和文件的关系 
- 5.1.2 流的结构和操作流程 
- 5.1.3 标准流介绍 
- 5.2 流的打开和关闭 
- 5.3 流的缓冲方式和缓冲区设置 
- 5.3.1 流的缓冲方式 
- 5.3.2 流的缓冲区设置方式 
- 5.4 流的读写 
- 5.4.1 字符读写 
- 5.4.2 行读写 
- 5.4.3 二进制读写 
- 5.4.4 流的出错处理 
- 5.4.5 流的冲洗 
- 5.5 流的定位 
- 5.5.1 ftell和fseek函数 
- 5.5.2 ftello和fseeko函数 
- 5.5.3 fgetpos和fsetpos函数 
- 5.6 流的格式化输出和输入 
- 5.6.1 格式化输出 
- 5.6.2 格式化输入 
- 5.6.3 格式化参数 
- 5.6.4 格式化输入输出应用实例 
- 5.7 临时文件 
## 第6章 Linux的进程 
- 6.1 Linux进程基础 
- 6.1.1 Linux进程及其执行过程 
- 6.1.2 Linux进程的描述符和标识符 
- 6.1.3 Linux进程的用户 
- 6.1.4 Linux进程的调度 
- 6.1.5 Linux中进程执行的流程 
- 6.2 Linux的进程控制 
- 6.2.1 进程的创建 
- 6.2.2 进程的执行 
- 6.2.3 进程的退出 
- 6.2.4 进程的销毁 
- 6.3 Linux进程的其他操作 
- 6.3.1 更改用户ID和组ID 
- 6.3.2 进程组、会话和特性 
- 6.3.3 system函数 
- 6.3.4 进程会计 
- 6.3.5 进程时间 
## 第7章 Linux的线程 
- 7.1 Linux线程基础 
- 7.1.1 线程的运行方式 
- 7.1.2 线程的标识符 
- 7.1.3 用户态线程和核心态线程 
- 7.1.4 编译带线程的代码 
- 7.2 线程的操作 
- 7.2.1 线程的创建 
- 7.2.2 线程的退出 
- 7.2.3 线程的阻塞 
- 7.2.4 线程的取消和清理 
- 7.2.5 线程分离 
- 7.2.6 函数比较 
- 7.3 线程的私有数据处理 
- 7.3.1 创建键函数 
- 7.3.2 取消键关联函数 
- 7.3.3 解决键冲突函数 
- 7.3.4 键关联函数 
- 7.3.5 线程私有数据地址获取函数 
- 7.3.6 私有数据处理应用实例 
- 7.4 线程的属性 
- 7.4.1 线程属性对象的初始化和销毁函数 
- 7.4.2 线程堆栈大小相关函数 
- 7.4.3 线程堆栈地址函数 
- 7.4.4 线程的拆卸状态函数 
- 7.4.5 线程的作用域函数 
- 7.4.6 线程的继承调度函数 
- 7.4.7 线程的调度策略函数 
- 7.4.8 线程的调度参数函数 
- 7.4.9 线程属性应用实例 
- 7.5 线程的同步方式 
- 7.5.1 互斥锁 
- 7.5.2 条件变量 
## 第8章 Linux的信号和进程间通信 
- 8.1 Linux的进程通信和信号基础 
- 8.1.1 Linux的进程通信 
- 8.1.2 信号机制和信号 
- 8.1.3 信号的工作方式 
- 8.1.4 Linux中的信号说明 
- 8.1.5 信号的注册 
- 8.1.6 可重入函数 
- 8.2 信号的基础操作 
- 8.2.1 发送信号 
- 8.2.2 信号的定时 
- 8.2.3 进程退出信号 
- 8.3 Linux的信号集 
- 8.4 信号的阻塞和挂起 
## 第9章 Linux的管道、命名管道和进程间通信 
- 9.1 Linux的管道基础 
- 9.1.1 管道的基本概念 
- 9.1.2 管道的实现方法 
- 9.1.3 管道读写操作规则 
- 9.1.4 管道的特点 
- 9.2 Linux的管道操作 
- 9.2.1 管道的创建和应用 
- 9.2.2 管道的高级操作函数 
- 9.3 Linux命名管道基础 
- 9.3.1 使用命名管道 
- 9.3.2 命名管道的常用工作方式 
- 9.3.3 命名管道的打开和读写 
- 9.4 Linux命名管道的操作 
- 9.4.1 命名管道的创建 
- 9.4.2 命名管道的读写 
## 第10章 Linux的System V IPC进程通信 
- 10.1 Linux的System V IPC进程通信基础 
- 10.1.1 System V IPC的操作函数 
- 10.1.2 System V IPC的标识符和关键字 
- 10.1.3 ipc_perm的结构和权限 
- 10.1.4 创建System V IPC对象过程 
- 10.1.5 System V IPC的缺点 
- 10.1.6 System V IPC的操作命令 
- 10.2 消息队列 
- 10.2.1 消息队列基础 
- 10.2.2 创建消息队列 
- 10.2.3 消息队列的发送和接收 
- 10.2.4 消息队列的控制 
- 10.3 信号量 
- 10.3.1 信号量基础 
- 10.3.2 信号量的相关函数 
- 10.3.3 信号量的应用 
- 10.4 共享内存 
- 10.4.1 共享内存基础 
- 10.4.2 共享内存的相关操作 
- 10.4.3 共享内存的应用实例

-----
# 《Linux Shell脚本攻略》
## 第1章 小试牛刀 1 
- 1.1 简介 1 
- 1.2 终端打印 3 
- 1.3 玩转变量和环境变量 6 
- 1.4 使用函数添加环境变量 10 
- 1.5 使用shell进行数学运算 11 
- 1.6 玩转文件描述符及重定向 14 
- 1.7 数组和关联数组 19 
- 1.8 使用别名 21 
- 1.9 获取终端信息 23 
- 1.10 获取、设置日期和延时 24 
- 1.11 调试脚本 27 
- 1.12 函数和参数 29 
- 1.13 将命令序列的输出读入变量 31 
- 1.14 不使用回车键来读取n个字符 33 
- 1.15 运行命令直至执行成功 34 
- 1.16 字段分隔符和迭代器 35 
- 1.17 比较与测试 38 
## 第2章 命令之乐 42 
- 2.2 用cat进行拼接 42 
- 2.3 录制并回放终端会话 45 
- 2.4 文件查找与文件列表 46 
- 2.5 玩转xargs 54 
- 2.6 用tr进行转换 59 
- 2.7 校验和与核实 63 
- 2.8 加密工具与散列 65 
- 2.9 排序、唯一与重复 68 
- 2.10 临时文件命名与随机数 72 
- 2.11 分割文件和数据 73 
- 2.12 根据扩展名切分文件名 76 
- 2.13 批量重命名和移动 78 
- 2.14 拼写检查与词典操作 80 
- 2.15 交互输入自动化 82 
- 2.16 利用并行进程加速命令执行 84 
## 第3章 以文件之名 86 
- 3.2 生成任意大小的文件 86 
- 3.3 文本文件的交集与差集 88 
- 3.4 查找并删除重复文件 90 
- 3.5 文件权限、所有权和粘滞位 93 
- 3.6 创建不可修改的文件 97 
- 3.7 批量生成空白文件 98 
- 3.8 查找符号链接及其指向目标 99 
- 3.9 列举文件类型统计信息 100 
- 3.10 使用环回文件 102 
- 3.11 生成ISO文件及混合型ISO 106 
- 3.12 查找文件差异并进行修补 108 
- 3.13 使用head与tail打印文件的前10行和后10行 110 
- 3.14 只列出目录的各种方法 113 
- 3.15 在命令行中使用pushd和popd进行快速定位 114 
- 3.16 统计文件的行数、单词数和字符数 115 
- 3.17 打印目录树 116 
## 第4章 让文本飞 119 
- 4.1 简介 119 
- 4.2 使用正则表达式 119 
- 4.3 用grep在文件中搜索文本 122 
- 4.4 用cut按列切分文件 128 
- 4.5 使用sed进行文本替换 131 
- 4.6 使用awk进行高级文本处理 135 
- 4.7 统计特定文件中的词频 141 
- 4.8 压缩或解压缩JavaScript 142 
- 4.9 按列合并多个文件 145 
- 4.10 打印文件或行中的第n个单词或列 146 
- 4.11 打印行或样式之间的文本 146 
- 4.12 以逆序形式打印行 147 
- 4.13 解析文本中的电子邮件地址和URL 149 
- 4.14 在文件中移除包含某个单词的句子 150 
- 4.15 对目录中的所有文件进行文本替换 151 
- 4.16 文本切片及参数操作 152 
## 第5章 一团乱麻？没这回事 154 
- 5.2 Web页面下载 154 
- 5.3 以纯文本形式下载网页 157 
- 5.4 cURL入门 157 
- 5.5 从命令行访问Gmail 161 
- 5.6 解析网站数据 163 
- 5.7 图片抓取器及下载工具 164 
- 5.8 网页相册生成器 167 
- 5.9 Twitter命令行客户端 169 
- 5.10 基于Web后端的定义查询工具 173 
- 5.11 查找网站中的无效链接 175 
- 5.12 跟踪网站变动 177 
- 5.13 以POST方式发送网页并读取响应 179 
## 第6章 B计划 182 
- 6.2 用tar归档 182 
- 6.3 用cpio归档 188 
- 6.4 使用gzip压缩数据 189 
- 6.5 用zip归档和压缩 193 
- 6.6 更快速的归档工具pbzip2 194 
- 6.7 创建压缩文件系统 195 
- 6.8 使用rsync备份系统快照 197 
- 6.9 用Git进行基于版本控制的备份 200 
- 6.10 用fsarchiver创建全盘镜像 203 
## 第7章 无网不利 205 
- 7.2 网络设置 205 
- 7.3 使用ping 210 
- 7.4 列出网络上所有的活动主机 213 
- 7.5 使用SSH在远程主机上运行命令 216 
- 7.6 通过网络传输文件 220 
- 7.7 连接无线网络 223 
- 7.8 用SSH实现无密码自动登录 225 
- 7.9 使用SSH进行端口转发 227 
- 7.10 在本地挂载点上挂载远程驱动器 228 
- 7.11 网络流量与端口分析 229 
- 7.12 创建套接字 230 
- 7.13 互联网连接共享 231 
- 7.14 使用iptables架设简易防火墙 233 
## 第8章 当个好管家 235 
- 8.2 监视磁盘使用情况 235 
- 8.3 计算命令执行时间 240 
- 8.4 收集与当前登录用户、启动日志及启动故障的相关信息 243 
- 8.5 列出1小时内占用CPU最多的10个进程 245 
- 8.6 使用watch监视命令输出 247 
- 8.7 记录文件及目录访问 248 
- 8.8 用logrotate管理日志文件 249 
- 8.9 用syslog记录日志 251 
- 8.10 通过监视用户登录找出入侵者 252 
- 8.11 监视远程磁盘的健康情况 255 
- 8.12 找出系统中用户的活跃时段 258 
- 8.13 电源使用的测量与优化 260 
- 8.14 监视磁盘活动 261 
- 8.15 检查磁盘及文件系统错误 262 
## 第9章 管理重任 264 
- 9.2 收集进程信息 264 
- 9.3 杀死进程以及发送或响应信号 273 
- 9.4 向用户终端发送消息 276 
- 9.5 采集系统信息 278 
- 9.6 使用proc采集信息 279 
- 9.7 用cron进行调度 280 
- 9.8 从Bash中读写MySQL数据库 283 
- 9.9 用户管理脚本 287 
- 9.10 图像文件的缩放及格式转换 291 
- 9.11 从终端截图 294 
- 9.12 管理多个终端 295 

-----
# 《Linux系统命令及Shell脚本实践指南》
## 第1章 Linux简介1 
- 1.1 Linux的发展历史1 
- 1.2 Linux的特点2 
- 1.3 系统安装3 
- 1.3.1 安装前的规划3 
- 1.3.2 安装RedHat4 
- 1.3.3 安装CentOS11 
- 1.4 系统登录16 
- 1.4.1 第一次登录系统的设置16 
- 1.4.2 使用图形模式登录21 
- 1.4.3 使用终端模式登录23 
- 1.4.4 开始学习使用Linux的命令24 
- 1.5 系统启动流程25 
- 1.5.1 系统引导概述25 
- 1.5.2 系统运行级别26 
- 1.5.3 服务启动脚本27 
- 1.5.4 Grub介绍29 
- 1.6 获得帮助31 
- 1.6.1 使用manpage31 
- 1.6.2 使用infopage32 
- 1.6.3 其他获得帮助的方式32 
## 第2章 Linux用户管理33 
- 2.1 Linux用户和用户组33 
- 2.1.1 UID和GID33 
- 2.1.2 /etc/passwd和/etc/shadow34 
- 2.2 Linux账号管理36 
- 2.2.1 新增和删除用户36 
- 2.2.2 新增和删除用户组39 
- 2.2.3 检查用户信息39 
- 2.3 切换用户40 
- 2.3.1 切换成其他用户40 
- 2.3.2 用其他用户的身份执行命令：sudo41 
- 2.4 例行任务管理43 
- 2.4.1 单一时刻执行一次任务：at43 
- 2.4.2 周期性执行任务：cron44 
- 2.4.3 /etc/crontab的管理45 
## 第3章 Linux文件管理46 
- 3.1 文件和目录管理46 
- 3.1.1 绝对路径和相对路径47 
- 3.1.2 文件的相关操作48 
- 3.1.3 目录的相关操作51 
- 3.1.4 文件时间戳53 
- 3.2 文件和目录的权限54 
- 3.2.1 查看文件或目录的权限：ls—al54 
- 3.2.2 文件隐藏属性55 
- 3.2.3 改变文件权限：chmod56 
- 3.2.4 改变文件的拥有者：chown56 
- 3.2.5 改变文件的拥有组：chgrp57 
- 3.2.6 文件特殊属性：SUID/SGID/Sticky57 
- 3.2.7 默认权限和umask58 
- 3.2.8 查看文件类型：file60 
- 3.3 查找文件60 
- 3.3.1 一般查找：find61 
- 3.3.2 数据库查找：locate61 
- 3.3.3 查找执行文件：which/whereis62 
- 3.4 文件压缩和打包63 
- 3.4.1 gzip/gunzip63 
- 3.4.2 tar63 
- 3.4.3 bzip263 
- 3.4.4 cpio64 
## 第4章 Linux文件系统65 
- 4.1 文件系统65 
- 4.1.1 什么是文件系统65 
- 4.1.2 ext2文件系统简介65 
- 4.1.3 ext3文件系统简介66 
- 4.2 磁盘分区、创建文件系统、挂载66 
- 4.2.1 创建文件系统：fdisk66 
- 4.2.2 磁盘挂载：mount69 
- 4.2.3 设置启动自动挂载：/etc/fstab70 
- 4.2.4 磁盘检验：fsck、badblocks70 
- 4.3 Linux逻辑卷71 
- 4.3.1 什么是逻辑卷71 
- 4.3.2 如何制作逻辑卷72 
- 4.4 硬链接和软链接76 
- 4.4.1 什么是硬链接76 
- 4.4.2 什么是软链接77 
## 第5章 字符处理79 
- 5.1 管道79 
- 5.2 使用grep搜索文本79 
- 5.3 使用sort排序80 
- 5.4 使用uniq删除重复内容82 
- 5.5 使用cut截取文本82 
- 5.6 使用tr做文本转换83 
- 5.7 使用paste做文本合并84 
- 5.8 使用split分割大文件84 
## 第6章 网络管理86 
- 6.1 网络接口配置86 
- 6.1.1 使用ifconfig检查和配置网卡86 
- 6.1.2 将IP配置信息写入配置文件87 
- 6.2 路由和网关设置88 
- 6.3 DNS客户端配置89 
- 6.3.1 /etc/hosts89 
- 6.3.2 /etc/resolv.conf90 
- 6.4 网络测试工具90 
- 6.4.1 ping90 
- 6.4.2 host91 
- 6.4.3 traceroute91 
- 6.4.4 常见网络故障排查92 
## 第7章 进程管理94 
- 7.1 什么是进程94 
- 7.2 进程和程序的区别95 
- 7.3 进程的观察：ps、top95 
- 7.4 进程的终止：kill、killall98 
- 7.5 查询进程打开的文件：lsof99 
- 7.6 进程优先级调整：nice、renice101 
## 第8章 Linux下的软件安装103 
- 8.1 源码包编译安装103 
- 8.1.1 编译、安装、打印HelloWorld程序103 
- 8.1.2 使用源码包编译安装Apache106 
- 8.2 RPM安装软件108 
- 8.2.1 什么是RPM108 
- 8.2.2 RPM包管理命令：rpm109 
- 8.2.3 包依赖关系110 
- 8.2.4 使用RPM包安装gcc110 
- 8.2.5 使用RPM包安装Apache112 
- 8.3 yum安装软件114 
- 8.3.1 yum命令的基本用法114 
- 8.3.2 使用yum安装Apache115 
- 8.3.3 RedHat使用yum的问题115 
- 8.3.4 自建本地yum源118 
- 8.3.5 自建网络yum源121 
- 8.4 三种安装方法的比较123 
- 8.5 重建RPM包124 
- 8.5.1 创建重建环境124 
- 8.5.2 快速重建RPM包124 
- 8.5.3 以spec文件重建RPM包125 
- 8.5.4 spec文件简介126 
## 第9章 vi和vim编辑器129 
- 9.1 vi和vim编辑器简介129 
- 9.2 vi编辑器129 
- 9.2.1 模式介绍129 
- 9.2.2 案例练习130 
- 9.3 vim编辑器134 
- 9.3.1 多行编辑134 
- 9.3.2 多文件编辑134 
- 9.3.3 使用vimtutor深入学习vim136 
- 9.4 gedit编辑器137 
- 9.4.1 gedit编辑器简介137 
- 9.4.2 启动gedit编辑器138 
## 第10章 正则表达式139 
- 10.1 正则表达式基础139 
- 10.1.1 什么是正则表达式139 
- 10.1.2 基础的正则表达式140 
- 10.1.3 扩展的正则表达式143 
- 10.1.4 通配符144 
- 10.2 正则表达式示例146 
- 10.3 文本处理工具sed150 
- 10.3.1 sed介绍150 
- 10.3.2 删除151 
- 10.3.3 查找替换152 
- 10.3.4 字符转换153 
- 10.3.5 插入文本153 
- 10.3.6 读入文本154 
- 10.3.7 打印154 
- 10.3.8 写文件154 
- 10.3.9 sed脚本155 
- 10.3.10 高级替换155 
- 10.3.11 sed总结156 
- 10.4 文本处理工具awk157 
- 10.4.1 打印指定域158 
- 10.4.2 指定打印分隔符158 
- 10.4.3 内部变量NF159 
- 10.4.4 打印固定域159 
- 10.4.5 截取字符串159 
- 10.4.6 确定字符串的长度160 
- 10.4.7 使用awk求列和160 
## 第11章 Shell编程概述161 
- 11.1 Shell简介161 
- 11.1.1 Shell是什么161 
- 11.1.2 Shell的历史163 
- 11.1.3 Shell的功能164 
- 11.1.4 Shell编程的优势164 
- 11.2 第一个Shell脚本164 
- 11.2.1 编辑第一个Shell脚本164 
- 11.2.2 运行脚本165 
- 11.2.3 Shell脚本的排错166 
- 11.3 Shell的内建命令169 
## 第12章 BashShell的安装184 
- 12.1 确定你的Shell版本184 
- 12.2 安装bash184 
- 12.3 使用新版本的BashShell186 
- 12.4 在Windows中安装bash187 
## 第13章 Shell编程基础191 
- 13.1 变量191 
- 13.1.1 局部变量191 
- 13.1.2 环境变量191 
- 13.1.3 变量命名197 
- 13.1.4 变量赋值和取值198 
- 13.1.5 取消变量199 
- 13.1.6 特殊变量199 
- 13.1.7 数组200 
- 13.1.8 只读变量202 
- 13.1.9 变量的作用域203 
- 13.2 转义和引用205 
- 13.2.1 转义205 
- 13.2.2 引用206 
- 13.2.3 命令替换207 
- 13.3 运算符208 
- 13.3.1 算术运算符209 
- 13.3.2 位运算符209 
- 13.3.3 自增自减211 
- 13.4 其他算术运算211 
- 13.4.1 使用$[]做运算211 
- 13.4.2 使用expr做运算212 
- 13.4.3 内建运算命令declare212 
- 13.4.4 算术扩展213 
- 13.4.5 使用bc做运算213 
- 13.5 特殊字符215 
- 13.5.1 通配符215 
- 13.5.2 引号215 
- 13.5.3 注释符215 
- 13.5.4 大括号216 
- 13.5.5 控制字符217 
## 第14章 测试和判断218 
- 14.1 测试218 
- 14.1.1 测试结构218 
- 14.1.2 文件测试219 
- 14.1.3 字符串测试220 
- 14.1.4 整数比较222 
- 14.1.5 逻辑测试符和逻辑运算符223 
- 14.2 判断224 
- 14.2.1 if判断结构224 
- 14.2.2 if/else判断结构225 
- 14.2.3 if/elif/else判断结构226 
- 14.2.4 case判断结构227 
## 第15章 循环229 
- 15.1 for循环229 
- 15.1.1 带列表的for循环229 
- 15.1.2 不带列表的for循环231 
- 15.1.3 类C的for循环232 
- 15.1.4 for的无限循环233 
- 15.2 while循环234 
- 15.2.1 while循环的语法234 
- 15.2.2 使用while按行读取文件235 
- 15.2.3 while的无限循环236 
- 15.3 until循环237 
- 15.3.1 until循环的语法237 
- 15.3.2 until的无限循环238 
- 15.4 select循环238 
- 15.5 嵌套循环239 
- 15.6 循环控制241 
- 15.6.1 break语句241 
- 15.6.2 continue语句241 
## 第16章 函数243 
- 16.1 函数的基本知识243 
- 16.1.1 函数的定义和调用243 
- 16.1.2 函数的返回值244 
- 16.2 带参数的函数246 
- 16.2.1 位置参数246 
- 16.2.2 指定位置参数值247 
- 16.2.3 移动位置参数248 
- 16.3 函数库249 
- 16.3.1 自定义函数库249 
- 16.3.2 函数库/etc/init.d/functions简介249 
- 16.4 递归函数251 
## 第17章 重定向255 
- 17.1 重定向简介255 
- 17.1.1 重定向的基本概念255 
- 17.1.2 文件标识符和标准输入输出255 
- 17.2 I/O重定向255 
- 17.2.1 I/O重定向符号和用法255 
- 17.2.2 使用exec260 
- 17.2.3 HereDocument262 
## 第18章 脚本范例263 
- 18.1 批量添加用户脚本263 
- 18.2 检测服务器存活266 
- 18.3 使用expect实现自动化输入268 
- 18.4 自动登录ftp备份270 
- 18.5 文件安全检测脚本272 
- 18.6 ssh自动登录备份273 
- 18.7 使用rsync备份275 
- 18.8 使用netcat备份277 
- 18.9 使用iptables建立防火墙279 
- 18.10 自定义开机启动项的init脚本282 
- 18.11 使用脚本操作MySQL数据库286 
- 18.12 基于LVM快照的MySQL数据库备份288 
- 18.13 页面自动化安装LAMP环境291

------
# 《Linux大棚命令百篇上：文件和文本篇》
## Shell 基础及工具篇  1
- 1 今天的主角是Shell 2
- 2 用chsh 来改变Shell  8
- 3 export 将环境变量昭告天下  11
- 4 read，倾听是一种美德  17
- 5 expr，一款多功能计算器  24
- 6 tmux 给你带来多窗口的享受  26
- 7 用alias 起个昵称吧  33
- 8 history 是历史的镜子  40
- 9 xargs 绝对的护花使者  46
- 10 time，你最懂时间  51
- 11 sleep，睡眠也有学问  57
## 文件和磁盘篇  60
- 1 file 命令探寻文件信息  61
- 2 ln 连接你我他  66
- 3 find 命令上篇——find 初体验  72
- 4 find 命令下篇——find 引出的正则知识  83
- 5 du 最了解磁盘占用  91
- 6 压缩系列之一——gzip  100
- 7 压缩系列之二——bzip2  107
- 8 压缩系列之三——zip  111
- 9 dd 造出很大的黑洞  114
## 文本处理篇  119
- 1 echo 命令上篇——帮你发声，替你歌唱  121
- 2 echo 命令下篇——让世界充满色彩  126
- 3 搜索三兄弟grep、egrep 和fgrep  131
- 4 sed 的流艺术之一——初体验  139
- 5 sed 的流艺术之二——花样命令  141
- 6 sed 的流艺术之三——露几手  144
- 7 sed 的流艺术之四——插入和控制  147
- 8 awk 是三兄弟系列之一——入门  152
- 9 awk 是三兄弟系列之二——多行操作  157
- 10 awk 是三兄弟系列之三——多文件操作  161
- 11 awk 是三兄弟系列之四——外部调用  166
- 12 awk 是三兄弟系列之五——实战  171
- 13 cut 是修剪小能手  176
- 14 wc 帮你计算字数  184
- 15 split 是拆分小能手  188
- 16 paste 用来拼接  192
- 17 sort 命令上篇——sort 帮你排序  196
- 18 sort 命令下篇——关于k 选项的大讨论  201
- 19 Vi 中的替换艺术  208
- 20 加密工具全家桶  212

-----
# 《Linux大棚命令百篇(下):网络和系统篇》
## 网络篇  1
- 1 ping 遍大江南北  3
- 2 DNS 探秘之一——nslookup 初体验  8
- 3 DNS 探秘之二——DNS 知识温故知新  11
- 4 DNS 探秘之三——nslookup 输出解析  18
- 5 DNS 探秘之四——DNS 协议中的五元组 20
- 6 DNS 探秘之五——nslookup 交互模式  24
- 7 DNS 探秘之六——dig 初体验  29
- 8 DNS 探秘之七——dig 选项走马观花  32
- 9 iproute2 系列之一——和netstat 说再见  38
- 10 iproute2 系列之二——篡权的ss  40
- 11 iproute2 系列之三——iproute2 后浪推前浪  45
- 12 iproute2 系列之四——ip 不只是地址  49
- 13 iproute2 系列之五——除了四还有六  55
- 14 神探tcpdump 第一招——神探出场  59
- 15 神探tcpdump 第二招——两个选项  61
- 16 神探tcpdump 第三招——选项进阶  64
- 17 神探tcpdump 第四招——保存与回放  67
- 18 神探tcpdump 第五招——过滤流量  69
- 19 神探tcpdump 第六招——过滤实战  72
- 20 神探tcpdump 第七招——过滤高手  74
- 21 神探tcpdump 第八招——输出解读  78
- 22 神探tcpdump 终结招——七个秘籍  83
- 23 nc，一只可爱的网猫  85
- 24 ssh-copy-id，帮你建立信任  89
- 25 rsync 同步的艺术  92
- 26 其实你不懂wget 的心之一——下载文件  99
- 27 其实你不懂wget 的心之二——躲避封禁  103
- 28 其实你不懂wget 的心之三——下载目录  105
- 29 其实你不懂wget 的心之四——体贴的选项  108
## 进程和性能篇  111
- 1 uptime 给机器记考勤  113
- 2 内存不决问free  116
- 3 用好SWAP 的空间  122
- 4 vmstat 性能查看利器  130
- 5 mpstat，让你了解CPU 的心  137
- 6 top 命令庖丁解牛之一——入门  141
- 7 top 命令庖丁解牛之二——列管理  147
- 8 top 命令庖丁解牛之三——进程数据  152
- 9 top 命令庖丁解牛之四——排序大法  154
- 10 top 命令庖丁解牛之五——CPU 和内存  156
- 11 iostat 让I/O 尽在掌握之中  159
- 12 让pidof 告诉我们进程ID  165
- 13 sar 访谈  168
- 14 帮你找到幕后黑手——lsof 应用篇  177
- 15 帮你找到幕后黑手——lsof 悬疑篇  183
- 16 帮你找到幕后黑手——lsof 进阶篇  187
- 17 帮你找到幕后黑手——fuser 学习篇  190
- 18 ps 命令看着简单，其实很难 

-------
# 《Vim实用技巧》
## 第1章 Vim解决问题的方式1 
- 认识.命令1 
- 不要自我重复4 
- 以退为进6 
- 执行、重复、回退7 
- 查找并手动替换9 
- 认识.范式11 
## 第一部分 模式 
## 第2章 普通模式14 
- 停顿时请移开画笔14 
- 把撤销单元切成块15 
- 构造可重复的修改16 
- 用次数做简单的算术运算18 
- 能够重复，就别用次数20 
- 双剑合璧，天下无敌22 
## 第3章 插入模式26 
- 在插入模式中可即时更正错误26 
- 返回普通模式27 
- 不离开插入模式，粘贴寄存器中的文本28 
- 随时随地做运算30 
- 用字符编码插入非常用字符31 
- 用二合字母插入非常用字符32 
- 用替换模式替换已有文本32 
## 第4章 可视模式34 
- 深入理解可视模式34 
- 选择高亮选区36 
- 重复执行面向行的可视命令38 
- 只要可能，最好用操作符命令，而不是可视命令39 
- 用面向列块的可视模式编辑表格数据42 
- 修改列文本43 
- 在长短不一的高亮块后添加文本45 
## 第5章 命令行模式47 
- 认识Vim的命令行模式47 
- 在一行或多个连续行上执行命令50 
- 使用‘：t’和‘：m’命令复制和移动行54 
- 在指定范围上执行普通模式命令57 
- 重复上次的Ex命令59 
- 自动补全Ex命令60 
- 把当前单词插入命令行62 
- 回溯历史命令63 
- 运行Shell命令65 
- 批处理运行Ex命令69 
## 第二部分 文件 
## 第6章 管理多个文件74 
- 用缓冲区列表管理打开的文件74 
- 用参数列表将缓冲区分组77 
- 管理隐藏缓冲区80 
- 将工作区切分成窗口82 
- 用标签页将窗口分组85 
## 第7章 打开及保存文件88 
- 用：edit命令打开文件88 
- 使用：find打开文件91 
- 使用netrw管理文件系统93 
- 把文件保存到不存在的目录中96 
- 以超级用户权限保存文件97 
## 第三部分 更快地移动及跳转 
## 第8章 用动作命令在文档中移动102 
- 让手指保持在本位行上102 
- 区分实际行与屏幕行105 
- 基于单词移动107 
- 对字符进行查找109 
- 通过查找进行移动113 
- 用精确的文本对象选择选区115 
- 删除周边，修改内部119 
- 设置位置标记，以便快速跳回120 
- 在匹配括号间跳转122 
## 第9章 在文件间跳转125 
- 遍历跳转列表125 
- 遍历改变列表127 
- 跳转到光标下的文件128 
- 用全局位置标记在文件间快速跳转131 
## 第四部分 寄存器 
## 第10章 复制与粘贴134 
- 用无名寄存器实现删除、复制与粘贴操作134 
- 深入理解Vim寄存器137 
- 用寄存器中的内容替换高亮选区的文本142 
- 把寄存器的内容粘贴出来144 
- 与系统剪贴板进行交互147 
## 第11章 宏150 
- 宏的读取与执行150 
- 规范光标位置、直达目标以及中止宏153 
- 加次数回放宏155 
- 在连续的文本行上重复修改157 
- 给宏追加命令160 
- 在一组文件中执行宏162 
- 用迭代求值的方式给列表编号166 
- 编辑宏的内容168 
## 第五部分 模式 
## 第12章 按模式匹配及按原义匹配174 
- 调整查找模式的大小写敏感性174 
- 按正则表达式查找时，使用\v模式开关175 
- 按原义查找文本时，使用\V原义开关178 
- 使用圆括号捕获子匹配179 
- 界定单词的边界181 
- 界定匹配的边界182 
- 转义问题字符184 
## 第13章 查找188 
- 结识查找命令188 
- 高亮查找匹配190 
- 在执行查找前预览第一处匹配191 
- 将光标偏移到查找匹配的结尾193 
- 对完整的查找匹配进行操作194 
- 利用查找历史，迭代完成复杂的模式197 
- 统计当前模式的匹配个数200 
- 查找当前高亮选区中的文本202 
## 第14章 替换204 
- 认识substitute命令204 
- 在文件范围内查找并替换每一处匹配206 
- 手动控制每一次替换操作208 
- 重用上次的查找模式209 
- 用寄存器的内容替换211 
- 重复上一次substitute命令213 
- 使用子匹配重排CSV文件的字段216 
- 在替换过程中执行算术运算217 
- 交换两个或更多的单词219 
- 在多个文件中执行查找与替换221 
## 第15章 global命令225 
- 认识global命令225 
- 删除所有包含模式的文本行226 
- 将TODO项收集至寄存器228 
- 将CSS文件中所有规则的属性按照字母排序230 
## 第六部分 工具 
## 第16章 通过ctags建立索引，并用其浏览源代码236 
- 认识ctags236 
- 配置Vim使用ctags239 
- 使用Vim的标签跳转命令，浏览关键字的定义241 
## 第17章 编译代码，并通过Quickfix列表浏览错误信息245 
- 不用离开Vim也能编译代码245 
- 浏览Quickfix列表248 
- 回溯以前的Quickfix列表251 
- 定制外部编译器251 
## 第18章 通过grep、vimgrep以及其他工具对整个工程进行查找255 
- 不必离开Vim也能调用grep255 
- 定制grep程序257 
- 使用Vim内置正则表达式引擎的Grep260 
## 第19章 自动补全263 
- 认识Vim的关键字自动补全263 
- 与自动补全的弹出式菜单进行交互265 
- 掌握关键字的来龙去脉267 
- 使用字典中的单词进行自动补全269 
- 自动补全整行文本270 
- 自动补全单词序列271 
- 自动补全文件名273 
- 根据上下文自动补全274 
## 第20章 利用Vim的拼写检查器，查找并更正拼写错误276 
- 对你的工作进行拼写检查276 
- 使用其他拼写字典278 
- 将单词添加到拼写文件中279 
- 在插入模式下更正拼写错误280 
## 第21章 接下来干什么283 
- 21.1 继续练习283 
- 21.2 定制你自己的Vim283 
- 21.3 欲善其事，先利其器284 
## 附录A 根据个人喜好定制Vim285 
- A.1 动态改变Vim的设置项285 
- A.2 将配置信息存至vimrc文件287 
- A.3 为特定类型的文件应用个性化设置288

-----
# 《鸟哥的Linux私房菜-基础学习篇》
## 第一部分　Linux的规则与安装
- 　第0章　计算机概论　
- 　第1章　Linux是什么　
- 　第2章　Linux如何学习　
- 　第3章　主机规划与磁盘分区　
- 　第4章　安装CentOS 5.x与多重引导小技巧　
- 　第5章　首次登录与在线求助man page　
## 第二部分　Linux文件、目录与磁盘格式
- 　第6章　Linux的文件权限与目录配置　
- 　第7章　Linux文件与目录管理　
- 　第8章　Linux磁盘与文件系统管理　
- 　第9章　文件与文件系统的压缩与打包　
## 第三部分　学习shell与shell script
- 　第10章　vim程序编辑器　
- 　第11章　认识与学习bash　
- 　第12章　正则表达式与文件格式化处理　
- 　第13章　学习shell script　
## 第四部分　Linux使用者管理
- 　第14章　Linux账号管理与ACL权限设置　
- 　第15章　磁盘配额(Quota)与高级文件系统管理　
- 　第16章　例行性工作(crontab)　
- 　第17章　程序管理与SELinux初探　
- 　第18章　认识系统服务(daemons)　
- 　第19章　认识与分析日志文件　
## 第五部分　Linux系统管理员
- 　第20章　启动流程、模块管理与Loader　
- 　第21章　系统设置工具(网络与打印机)与硬件检测　
- 　第22章　软件安装：源码与Tarball　
- 　第23章　软件安装：RPM、SRPM与YUM功能 　
- 　第24章　X Window设置介绍　
- 　第25章　Linux备份策略　
- 　第26章　Linux内核编译与管理　
## 附录A　快速索引

-----
# 《深入理解LINUX内核》
## 第一章 绪论
- Linux与其他类Unix内核的比较
- 硬件的依赖性
- Linux版本
- 操作系统基本概念
- Unix文件系统概述
- Unix内核概述
## 第二章 内存寻址
- 内存地址
- 硬件中的分段
- Linux中的分段
- 硬件中的分页
- Linux中的分页
## 第三章 进程
- 进程、轻量级进程和线程
- 进程描述符
- 进程切换
- 创建进程
- 撤消进程
## 第四章 中断和异常
- 中断信号的作用
- 中断和异常
- 中断和异常处理程序的嵌套执行
- 初始化中断描述符表
- 异常处理
- 中断处理
- 软中断及tasklet
- 工作队列
- 从中断和异常返回
## 第五章 内核同步
- 内核如何为不同的请求提供服务
- 同步原语
- 对内核数据结构的同步访问
- 避免竞争条件的实例
## 第六章 定时测量
- 时钟和定时器电路
- Linux计时体系结构
- 更新时间和日期
- 更新系统统计数
- 软定时器和延迟函数
- 与定时测量相关的系统调用
## 第七章 进程调度
- 调度策略
- 调度算法
- 调度程序所使用的数据结构
- 调度程序所使用的函数
- 多处理器系统中运行队列的平衡
- 与调度相关的系统调用
## 第八章 内存管理
- 页框管理
- 内存区管理
- 非连续内存区管理
## 第九章 进程地址空间
- 进程的地址空间
- 内存描述符
- 线性区
- 缺页异常处理程序
- 创建和删除进程的地址空间
- 堆的管理
## 第十章 系统调用
- POSIX API和系统调用
- 系统调用处理程序及服务例程
- 进入和退出系统调用
- 参数传递
- 内核封装例程
## 第十一章 信号
- 信号的作用
- 产生信号
- 传递信号
- 与信号处理相关的系统调用
## 第十二章 虚拟文件系统
- 虚拟文件系统(VFS)的作用
- VFS的数据结构
- 文件系统类型
- 文件系统处理
- 路径名查找
- VFS系统调用的实现
- 文件加锁
## 第十三章 I/O体系结构和设备驱动程序
- I/O体系结构
- 设备驱动程序模型
- 设备文件
- 设备驱动程序
- 字符设备驱动程序
## 第十四章 块设备驱动程序
- 块设备的处理
- 通用块层
- I/O调度程序
- 块设备驱动程序
- 打开块设备文件
## 第十五章 页高速缓存
- 页高速缓存
- 把块存放在页高速缓存中
- 把脏页写入磁盘
- sync()、fsync()和fdatasync()系统调用
## 第十六章 访问文件
- 读写文件
- 内存映射
- 直接I/O传送
- 异步I/O
## 第十七章 回收页框
- 页框回收算法
- 反向映射
- PFRA实现
- 交换
## 第十八章 Ext2和Ext3文件系统
- Ext2的一般特征
- Ext2磁盘数据结构
- Ext2的内存数据结构
- 创建Ext2文件系统
- Ext2的方法
- 管理Ext2磁盘空间
- Ext3文件系统
## 第十九章 进程通信
- 管道
- FIFO
- System V IPC
- POSIX消息队列
## 第二十章 程序的执行
- 可执行文件
- 可执行格式
- 执行域
- exec函数
## 附录一 系统启动
## 附录二 模块

-----
# 《Linux内核设计的艺术》
## 第1章从开机加电到执行main函数之前的过程1 
- 1.1启动BIOS，准备实模式下的中断向量表和中断服务程序1 
- 1.1.1BIOS的启动原理2 
- 1.1.2BIOS在内存中加载中断向量表和中断服务程序3 
- 1.2加载操作系统内核程序并为保护模式做准备5 
- 1.2.1加载第一部分内核代码——引导程序（bootsect）5 
- 1.2.2加载第二部分内核代码——setup7 
- 1.2.3加载第三部分内核代码——system模块13 
- 1.3开始向32位模式转变，为main函数的调用做准备17 
- 1.3.1关中断并将system移动到内存地址起始位置0x0000017 
- 1.3.2设置中断描述符表和全局描述符表19 
- 1.3.3打开A20，实现32位寻址21 
- 1.3.4为保护模式下执行head.s做准备23 
- 1.3.5head.s开始执行26 
- 1.4本章小结44 
## 第2章设备环境初始化及激活进程045 
- 2.1设置根设备、硬盘46 
- 2.2规划物理内存格局，设置缓冲区、虚拟盘、主内存46 
- 2.3设置虚拟盘空间并初始化48 
- 2.4内存管理结构mem_map初始化50 
- 2.5异常处理类中断服务程序挂接51 
- 2.6初始化块设备请求项结构57 
- 2.7与建立人机交互界面相关的外设的中断服务程序挂接59 
- 2.7.1对串行口进行设置59 
- 2.7.2对显示器进行设置60 
- 2.7.3对键盘进行设置61 
- 2.8开机启动时间设置63 
- 2.9初始化进程065 
- 2.9.1初始化进程068 
- 2.9.2设置时钟中断71 
- 2.9.3设置系统调用总入口71 
- 2.10初始化缓冲区管理结构73 
- 2.11初始化硬盘75 
- 2.12初始化软盘77 
- 2.13开启中断78 
- 2.14进程0由0特权级翻转到3特权级，成为真正的进程78 
- 2.15本章小结80 
## 第3章进程1的创建及执行81 
- 3.1进程1的创建81 
- 3.1.1进程0创建进程181 
- 3.1.2在task[64]中为进程1申请一个空闲位置并获取进程号87 
- 3.1.3调用copy_process函数89 
- 3.1.4设置进程1的分页管理94 
- 3.1.5进程1共享进程0的文件99 
- 3.1.6设置进程1在GDT中的表项99 
- 3.1.7进程1处于就绪态100 
- 3.2内核第一次做进程调度103 
- 3.3轮转到进程1执行107 
- 3.3.1进程1为安装硬盘文件系统做准备109 
- 3.3.2进程1格式化虚拟盘并更换根设备为虚拟盘135 
- 3.3.3进程1在根设备上加载根文件系统138 
- 3.4本章小结151 
## 第4章进程2的创建及执行152 
- 4.1打开终端设备文件及复制文件句柄152 
- 4.1.1打开标准输入设备文件152 
- 4.1.2打开标准输出、标准错误输出设备文件166 
- 4.2进程1创建进程2并切换到进程2执行169 
- 4.3加载shell程序178 
- 4.3.1关闭标准输入设备文件，打开rc文件178 
- 4.3.2检测shell文件181 
- 4.3.3为shell程序的执行做准备186 
- 4.3.4执行shell程序192 
- 4.4系统实现怠速196 
- 4.4.1创建update进程196 
- 4.4.2切换到shell进程执行198 
- 4.4.3重建shell204 
- 4.5本章小结205 
## 第5章文件操作206 
- 5.1安装文件系统206 
- 5.1.1获取外设的超级块206 
- 5.1.2确定根文件系统的挂接点209 
- 5.1.3将超级块与根文件系统挂接210 
- 5.2打开文件211 
- 5.2.1将进程的\*filp[20]与file_table[64]挂接212 
- 5.2.2获取文件i节点213 
- 5.2.3将文件i节点与file_table[64]挂接223 
- 5.3读文件224 
- 5.3.1确定数据块在外设中的位置224 
- 5.3.2将数据块读入缓冲块228 
- 5.3.3将缓冲块中的数据复制到进程空间228 
- 5.4新建文件230 
- 5.4.1查找文件230 
- 5.4.2新建文件i节点231 
- 5.4.3新建文件目录项233 
- 5.5写文件238 
- 5.5.1确定文件的写入位置238 
- 5.5.2申请缓冲块241 
- 5.5.3将指定的数据从进程空间复制到缓冲块241 
- 5.5.4数据同步到外设的两种方法242 
- 5.6修改文件245 
- 5.6.1重定位文件的当前操作指针246 
- 5.6.2修改文件246 
- 5.7关闭文件248 
- 5.7.1当前进程的filp与file_table[64]脱钩248 
- 5.7.2文件i节点被释放249 
- 5.8删除文件250 
- 5.8.1对文件的删除条件进行检查251 
- 5.8.2进行具体的删除工作252 
- 5.9本章小结255 
## 第6章用户进程与内存管理256 
- 6.1线性地址的保护256 
- 6.1.1进程线性地址空间的格局256 
- 6.1.2段基址、段限长、GDT、LDT、特权级257 
- 6.2分页260 
- 6.2.1线性地址映射到物理地址260 
- 6.2.2进程执行时分页261 
- 6.2.3进程共享页面267 
- 6.2.4内核分页270 
- 6.3一个用户进程从创建到退出的完整过程273 
- 6.3.1创建str1进程273 
- 6.3.2str1进程加载的准备工作285 
- 6.3.3str1进程的运行、加载289 
- 6.3.4str1进程的退出296 
- 6.4多个用户进程同时运行299 
- 6.4.1进程调度299 
- 6.4.2页写保护303 
- 6.5本章小结309 
## 第7章缓冲区和多进程操作文件310 
- 7.1缓冲区的作用310 
- 7.2缓冲区的总体结构311 
- 7.3b_dev、b_blocknr及request的作用312 
- 7.3.1保证进程与缓冲块数据交互的正确性312 
- 7.3.2让数据在缓冲区中停留的时间尽可能长320 
- 7.4uptodate和dirt的作用325 
- 7.4.1b_uptodate的作用326 
- 7.4.2b_dirt的作用331 
- 7.4.3i_uptodate、i_dirt和s_dirt的作用334 
- 7.5count、lock、wait、request的作用336 
- 7.5.1b_count的作用336 
- 7.5.2i_count的作用338 
- 7.5.3b_lock、\*b_wait的作用341 
- 7.5.4i_lock、i_wait、s_lock、\*s_wait的作用344 
- 7.5.5补充request的作用347 
- 7.6实例1：关于缓冲块的进程等待队列349 
- 7.7总体来看缓冲块和请求项370 
- 7.8实例2：多进程操作文件的综合实例373 
- 7.9本章小结388 
## 第8章进程间通信389 
- 8.1管道机制389 
- 8.1.1管道的创建过程391 
- 8.1.2管道的操作396 
- 8.2信号机制410 
- 8.2.1信号的使用412 
- 8.2.2信号对进程执行状态的影响422 
- 8.3本章小结431 
## 第9章操作系统的设计指导思想432 
- 9.1运行一个最简单的程序，看操作系统为程序运行做了哪些工作432 
- 9.2操作系统的设计指导思想——主奴机制434 
- 9.2.1主奴机制中的进程及进程创建机制435 
- 9.2.2操作系统的设计如何体现主奴机制436 
- 9.3实现主奴机制的三种关键技术438 
- 9.3.1保护和分页438 
- 9.3.2特权级440 
- 9.3.3中断441 
- 9.4建立主奴机制的决定性因素——先机443 
- 9.5软件和硬件的关系444 
- 9.5.1非用户进程——进程0、进程1、shell进程444 
- 9.5.2文件与数据存储445 
- 9.6父子进程共享页面450 
- 9.7操作系统的全局中断与进程的局部中断——信号450 
- 9.8本章小结451 

-----
# 《LINUX内核设计与实现(第三版)》
## 第1章 Linux内核简介1
- 1.1 Unix的历史1
- 1.2 追寻Linus足迹：Linux简介2
- 1.3 操作系统和内核简介3
- 1.4 Linux内核和传统Unix内核的比较5
- 1.5 Linux内核版本7
- 1.6 Linux内核开发者社区8
- 1.7 小结8
## 第2章 从内核出发10
- 2.1 获取内核源码10
- 2.1.1 使用Git10
- 2.1.1 安装内核源代码10
- 2.1.3 使用补丁11
- 2.2 内核源码树11
- 2.3 编译内核12
- 2.3.1 配置内核12
- 2.3.2 减少编译的垃圾信息14
- 2.3.3 衍生多个编译作业 14
- 2.3.4 安装新内核14
- 2.4 内核开发的特点15
- 2.4.1 无libc库抑或无标准头文件15
- 2.4.2 GNU C16
- 2.4.3 没有内存保护机制18
- 2.4.4 不要轻易在内核中使用浮点数18
- 2.4.5 容积小而固定的栈18
- 2.4.6 同步和并发18
- 2.4.7 可移植性的重要性19
- 2.5 小结19
## 第3章 进程管理20
- 3.1 进程20
- 3.2 进程描述符及任务结构 21
- 3.2.1 分配进程描述符22
- 3.2.2 进程描述符的存放23
- 3.2.3 进程状态23
- 3.2.4 设置当前进程状态25
- 3.2.5 进程上下文25
- 3.2.6 进程家族树25
- 3.3 进程创建26
- 3.3.1 写时拷贝27
- 3.3.2 fork()27
- 3.3.3 vfork()28
- 3.4 线程在Linux中的实现28
- 3.4.1 创建线程29
- 3.4.2 内核线程30
- 3.5 进程终结31
- 3.5.1 删除进程描述符32
- 3.5.2 孤儿进程造成的进退维谷32
- 3.6 小结34
## 第4章 进程调度35
- 4.1 多任务35
- 4.2 Linux 的进程调度36
- 4.3 策略36
- 4.3.1 I/O消耗型和处理器消耗型的进程36
- 4.3.2 进程优先级37
- 4.3.3 时间片38
- 4.3.4 调度策略的活动38
- 4.4 Linux调度算法39
- 4.4.1 调度器类39
- 4.4.2 Unix 系统中的进程调度40
- 4.4.3 公平调度41
- 4.5 Linux调度的实现42
- 4.5.1 时间记账42
- 4.5.2 进程选择44
- 4.5.3 调度器入口48
- 4.5.4 睡眠和唤醒49
- 4.6 抢占和上下文切换51
- 4.6.1 用户抢占53
- 4.6.2 内核抢占53
- 4.7 实时调度策略54
- 4.8 与调度相关的系统调用54
- 4.8.1 与调度策略和优先级相关的系统调用55
- 4.8.2 与处理器绑定有关的系统调用55
- 4.8.3 放弃处理器时间56
- 4.9 小结56
## 第5章 系统调用57
- 5.1 与内核通信57
- 5.2 API、POSIX和C库57
- 5.3 系统调用58
- 5.3.1 系统调用号59
- 5.3.2 系统调用的性能59
- 5.4 系统调用处理程序60
- 5.4.1 指定恰当的系统调用60
- 5.4.2 参数传递60
- 5.5 系统调用的实现61
- 5.5.1 实现系统调用61
- 5.5.2 参数验证62
- 5.6 系统调用上下文64
- 5.6.1 绑定一个系统调用的最后步骤65
- 5.6.2 从用户空间访问系统调用67
- 5.6.3 为什么不通过系统调用的方式实现68
- 5.7 小结68
## 第6章 内核数据结构69
- 6.1 链表69
- 6.1.1 单向链表和双向链表69
- 6.1.2 环形链表70
- 6.1.3 沿链表移动71
- 6.1.4 Linux 内核中的实现71
- 6.1.5 操作链表73
- 6.1.6 遍历链表75
- 6.2 队列78
- 6.2.1 kfifo79
- 6.2.2 创建队列79
- 6.2.3 推入队列数据79
- 6.2.4 摘取队列数据80
- 6.2.5 获取队列长度80
- 6.2.6 重置和撤销队列80
- 6.2.7 队列使用举例 81
- 6.3 映射 81
- 6.3.1 初始化一个idr82
- 6.3.2 分配一个新的UID82
- 6.3.3 查找UID83
- 6.3.4 删除UID84
- 6.3.5 撤销idr84
- 6.4 二叉树84
- 6.4.1 二叉搜索树84
- 6.4.2 自平衡二叉搜索树 85
- 6.5 数据结构以及选择 87
- 6.6 算法复杂度88
- 6.6.1 算法88
- 6.6.2 大o 符号88
- 6.6.3 大θ符号89
- 6.6.4 时间复杂度89
- 6.7 小结 90
## 第7章 中断和中断处理91
- 7.1 中断91
- 7.2 中断处理程序92
- 7.3 上半部与下半部的对比93
- 7.4 注册中断处理程序93
- 7.4.1 中断处理程序标志94
- 7.4.2 一个中断例子95
- 7.4.3 释放中断处理程序95
- 7.5 编写中断处理程序96
- 7.5.1 共享的中断处理程序97
- 7.5.2 中断处理程序实例97
- 7.6 中断上下文99
- 7.7 中断处理机制的实现100
- 7.8 /proc/interrupts102
- 7.9 中断控制103
- 7.9.1 禁止和激活中断103
- 7.9.2 禁止指定中断线105
- 7.9.3 中断系统的状态105
- 7.10 小结106
## 第8章 下半部和推后执行的工作107
- 8.1 下半部107
- 8.1.1 为什么要用下半部108
- 8.1.2 下半部的环境108
- 8.2 软中断110
- 8.2.1 软中断的实现111
- 8.2.2 使用软中断113
- 8.3 tasklet114
- 8.3.1 tasklet的实现114
- 8.3.2 使用tasklet116
- 8.3.3 老的BH机制119
- 8.4 工作队列120
- 8.4.1 工作队列的实现121
- 8.4.2 使用工作队列124
- 8.4.3 老的任务队列机制126
- 8.5 下半部机制的选择127
- 8.6 在下半部之间加锁128
- 8.7 禁止下半部128
- 8.8 小结129
- 
- 第9章 内核同步介绍131
- 9.1 临界区和竞争条件131
- 9.1.1 为什么我们需要保护132
- 9.1.2 单个变量133
- 9.2 加锁134
- 9.2.1 造成并发执行的原因135
- 9.2.2 了解要保护些什么136
- 9.3 死锁137
- 9.4 争用和扩展性138
- 9.5 小结140
## 第10章 内核同步方法141
- 10.1 原子操作141
- 10.1.1 原子整数操作142
- 10.1.2 64位原子操作144
- 10.1.3 原子位操作145
- 10.2 自旋锁147
- 10.2.1 自旋锁方法148
- 10.2.2 其他针对自旋锁的操作149
- 10.2.3 自旋锁和下半部150
- 10.3 读-写自旋锁150
- 10.4 信号量152
- 10.4.1 计数信号量和二值信号量153
- 10.4.2 创建和初始化信号量154
- 10.4.3 使用信号量154
- 10.5 读-写信号量155
- 10.6 互斥体156
- 10.6.1 信号量和互斥体158
- 10.6.2 自旋锁和互斥体158
- 10.7 完成变量158
- 10.8 BLK：大内核锁159
- 10.9 顺序锁160
- 10.10 禁止抢占161
- 10.11 顺序和屏障162
- 10.12 小结165
## 第11章 定时器和时间管理166
- 11.1 内核中的时间概念166
- 11.2 节拍率：HZ167
- 11.2.1 理想的HZ值168
- 11.2.2 高HZ的优势169
- 11.2.3 高HZ的劣势169
- 11.3 jiffies170
- 11.3.1 jiffies的内部表示171
- 11.3.2 jiffies 的回绕172
- 11.3.3 用户空间和HZ173
- 11.4 硬时钟和定时器174
- 11.4.1 实时时钟174
- 11.4.2 系统定时器174
- 11.5 时钟中断处理程序174
- 11.6 实际时间176
- 11.7 定时器178
- 11.7.1 使用定时器178
- 11.7.2 定时器竞争条件180
- 11.7.3 实现定时器180
- 11.8 延迟执行181
- 11.8.1 忙等待181
- 11.8.2 短延迟182
- 11.8.3 schedule_timeout()183
- 11.9 小结185
## 第12章 内存管理186
- 12.1 页186
- 12.2 区187
- 12.3 获得页189
- 12.3.1 获得填充为0的页190
- 12.3.2 释放页191
- 12.4 kmalloc()191
- 12.4.1 gfp_mask标志192
- 12.4.2 kfree()195
- 12.5 vmalloc()196
- 12.6 slab层197
- 12.6.1 slab层的设计198
- 12.6.2 slab分配器的接口200
- 12.7 在栈上的静态分配203
- 12.7.1 单页内核栈203
- 12.7.2 在栈上光明正大地工作203
- 12.8 高端内存的映射204
- 12.8.1 永久映射204
- 12.8.2 临时映射204
- 12.9 每个CPU的分配20512.10 新的每个CPU接口206
- 12.10.1 编译时的每个CPU数据206
- 12.10.2 运行时的每个CPU数据207
- 12.11 使用每个CPU数据的原因208
- 12.12 分配函数的选择209
- 12.13 小结209
## 第13章 虚拟文件系统210
- 13.1 通用文件系统接口210
- 13.2 文件系统抽象层211
- 13.3 Unix文件系统212
- 13.4 VFS 对象及其数据结构213
- 13.5 超级块对象214
- 13.6 超级块操作215
- 13.7 索引节点对象217
- 13.8 索引节点操作219
- 13.9 目录项对象222
- 13.9.1 目录项状态222
- 13.9.2 目录项缓存223
- 13.10 目录项操作224
- 13.11 文件对象225
- 13.12 文件操作226
- 13.13 和文件系统相关的数据结构230
- 13.14 和进程相关的数据结构232
- 13.15 小结233
## 第14章 块I/O层234
- 14.1 剖析一个块设备234
- 14.2 缓冲区和缓冲区头235
- 14.3 bio结构体237
- 14.3.1 I/O向量238
- 14.3.2 新老方法对比239
- 14.4 请求队列240
- 14.5 I/O调度程序240
- 14.5.1 I/O调度程序的工作241
- 14.5.2 Linus 电梯241
- 14.5.3 最终期限I/O调度程序242
- 14.5.4 预测I/O调度程序244
- 14.5.5 完全公正的排队I/O调度程序244
- 14.5.6 空操作的I/O调度程序245
- 14.5.7 I/O调度程序的选择245
- 14.6 小结246
## 第15章 进程地址空间247
- 15.1 地址空间247
- 15.2 内存描述符248
- 15.2.1 分配内存描述符249
- 15.2.2 撤销内存描述符250
- 15.2.3 mm_struct 与内核线程250
- 15.3 虚拟内存区域251
- 15.3.1 VMA标志251
- 15.3.2 VMA 操作253
- 15.3.3 内存区域的树型结构和内存区域的链表结构254
- 15.3.4 实际使用中的内存区域254
- 15.4 操作内存区域255
- 15.4.1 find_vma()256
- 15.4.2 find_vma_prev()257
- 15.4.3 find_vma_intersection()257
- 15.5 mmap()和do_mmap()：创建地址区间258
- 15.6 mummap()和do_mummap()：删除地址区间259
- 15.7 页表260
- 15.8 小结261
## 第16章 页高速缓存和页回写262
- 16.1 缓存手段262
- 16.1.1 写缓存262
- 16.1.2 缓存回收263
- 16.2 Linux 页高速缓存264
- 16.2.1 address_space对象264
- 16.2.2 address_space 操作266
- 16.2.3 基树267
- 16.2.4 以前的页散列表268
- 16.3 缓冲区高速缓存268
- 16.4 flusher线程268
- 16.4.1 膝上型计算机模式270
- 16.4.2 历史上的bdflush、kupdated 和pdflush270
- 16.4.3 避免拥塞的方法：使用多线程271
- 16.5 小结271
## 第17章 设备与模块273
- 17.1 设备类型273
- 17.2 模块274
- 17.2.1 Hello，World274
- 17.2.2 构建模块275
- 17.2.3 安装模块277
- 17.2.4 产生模块依赖性277
- 17.2.5 载入模块278
- 17.2.6 管理配置选项279
- 17.2.7 模块参数280
- 17.2.8 导出符号表282
- 17.3 设备模型283
- 17.3.1 kobject283
- 17.3.2 ktype284
- 17.3.3 kset285
- 17.3.4 kobject、ktype和kset的相互关系285
- 17.3.5 管理和操作kobject286
- 17.3.6 引用计数287
- 17.4 sysfs288
- 17.4.1 sysfs中添加和删除kobject 290
- 17.4.2 向sysfs中添加文件291
- 17.4.3 内核事件层293
- 17.5 小结294
## 第18章 调试295
- 18.1 准备开始295
- 18.2 内核中的bug296
- 18.3 通过打印来调试296
- 18.3.1 健壮性296
- 18.3.2 日志等级297
- 18.3.3 记录缓冲区298
- 18.3.4 syslogd和klogd298
- 18.3.5 从printf()到printk()的转换298
- 18.4 oops298
- 18.4.1 ksymoops300
- 18.4.2 kallsyms300
- 18.5 内核调试配置选项301
- 18.6 引发bug并打印信息301
- 18.7 神奇的系统请求键302
- 18.8 内核调试器的传奇303
- 18.8.1 gdb303
- 18.8.2 kgdb304
- 18.9 探测系统304
- 18.9.1 用UID作为选择条件304
- 18.9.2 使用条件变量305
- 18.9.3 使用统计量305
- 18.9.4 重复频率限制305
- 18.10 用二分查找法找出引发罪恶的变更306
- 18.11 使用Git进行二分搜索307
- 18.12 当所有的努力都失败时：社区308
- 18.13 小结308
## 第19章 可移植性309
- 19.1 可移植操作系统309
- 19.2 Linux移植史310
- 19.3 字长和数据类型311
- 19.3.1 不透明类型313
- 19.3.2 指定数据类型314
- 19.3.3 长度明确的类型314
- 19.3.4 char型的符号问题315
- 19.4 数据对齐315
- 19.4.1 避免对齐引发的问题316
- 19.4.2 非标准类型的对齐316
- 19.4.3 结构体填补316
- 19.5 字节顺序318
- 19.6 时间319
- 19.7 页长度320
- 19.8 处理器排序320
- 19.9 SMP、内核抢占、高端内存321
- 19.10 小结321
## 第20章 补丁、开发和社区322
- 20.1 社区322
- 20.2 Linux编码风格322
- 20.2.1 缩进323
- 20.2.2 switch 语句323
- 20.2.3 空格324
- 20.2.4 花括号325
- 20.2.5 每行代码的长度326
- 20.2.6 命名规范326
- 20.2.7 函数326
- 20.2.8 注释326
- 20.2.9 typedef327
- 20.2.10 多用现成的东西328
- 20.2.11 在源码中减少使用ifdef328
- 20.2.12 结构初始化328
- 20.2.13 代码的事后修正329
- 20.3 管理系统329
- 20.4 提交错误报告329
- 20.5 补丁330
- 20.5.1 创建补丁330
- 20.5.2 用Git创建补丁331
- 20.5.3 提交补丁331

------
# 《奔跑吧Linux内核》
## LINUX内核奔跑卷 1 
## 第 1章 处理器体系结构 4 
## 第 2章 内存管理 32 
- 2.1 物理内存初始化 36 
- 2.1.1 内存管理概述 36 
- 2.1.2 内存大小 37 
- 2.1.3 物理内存映射 38 
- 2.1.4 zone初始化 40 
- 2.1.5 空间划分 44 
- 2.1.6 物理内存初始化 45 
- 2.2 页表的映射过程 51 
- 2.2.1 ARM32页表映射 51 
- 2.2.2 ARM64页表映射 60 
- 2.3 内核内存的布局图 67 
- 2.3.1 ARM32内核内存布局图 67 
- 2.3.2 ARM64内核内存布局图 70 
- 2.4 分配物理页面 72 
- 2.4.1 伙伴系统分配内存 72 
- 2.4.2 释放页面 85 
- 2.5 slab分配器 90 
- 2.5.1 创建slab描述符 91 
- 2.5.2 分配slab对象 103 
- 2.5.3 释放slab缓冲对象 108 
- 2.5.4 kmalloc分配函数 111 
- 2.6 vmalloc 113 
- 2.7 VMA操作 120 
- 2.7.1 查找VMA 122 
- 2.7.2 插入VMA 124 
- 2.7.3 合并VMA 129 
- 2.7.4 红黑树例子 131 
- 2.8 malloc 133 
- 2.8.1 brk实现 134 
- 2.8.2 VM_LOCK情况 138 
- 2.9 mmap 150 
- 2.9.1 mmap概述 151 
- 2.10 缺页中断处理 155 
- 2.10.1 do_page_fault() 157 
- 2.10.2 匿名页面缺页中断 165 
- 2.10.3 文件映射缺页中断 169 
- 2.10.4 写时复制 175 
- 2.11 page引用计数 184 
- 2.11.1 struct page数据结构 185 
- 2.11.2 \_count和_mapcount的区别 188 
- 2.11.3 页面锁PG_Locked 192 
- 2.12 反向映射RMAP 192 
- 2.12.1 父进程分配匿名页面 193 
- 2.12.2 父进程创建子进程 198 
- 2.12.3 子进程发生COW 200 
- 2.12.4 RMAP应用 201 
- 2.13 回收页面 204 
- 2.13.1 LRU链表 204 
- 2.13.2 kswapd内核线程 216 
- 2.13.3 balance_pgdat函数 219 
- 2.13.4 shrink_zone函数 228 
- 2.13.5 shrink_active_list函数 233 
- 2.13.6 shrink_inactive_list函数 238 
- 2.13.7 跟踪LRU活动情况 244 
- 2.13.8 Refault Distance算法 244 
- 2.14 匿名页面生命周期 251 
- 2.14.1 匿名页面的诞生 251 
- 2.14.2 匿名页面的使用 252 
- 2.14.3 匿名页面的换出 252 
- 2.14.4 匿名页面的换入 254 
- 2.14.5 匿名页面销毁 254 
- 2.15 页面迁移 254 
- migrate_pages()函数 255 
- 2.16 内存规整（memory compaction） 262 
- 2.16.1 内存规整实现 263 
- 2.17 KSM 273 
- 2.17.1 KSM实现 274 
- 2.17.2 匿名页面和KSM页面的区别 293 
- 2.18 Dirty COW内存漏洞 296 
- 2.19 总结内存管理数据结构和API 309 
- 2.19.1 内存管理数据结构的关系图 309 
- 2.19.2 内存管理中常用API 312 
- 2.20 新更新和展望 315 
- 2.20.1 页面回收策略从zone迁移到node 315 
- 2.20.2 OOM Killer改进 316 
- 2.20.3 swap优化 317 
- 2.20.4 展望 318 
## 第3章 进程管理 319 
- 3.1 进程的诞生 320 
- 3.1.1 init进程 321 
- 3.1.2 fork 325 
- 3.2 CFS调度器 345 
- 3.2.1 权重计算 346 
- 3.2.2 进程创建 358 
- 3.2.3 进程调度 369 
- 3.2.4 scheduler tick 379 
- 3.2.5 组调度 382 
- 3.2.6 PELT算法改进 386 
- 3.3 SMP负载均衡 389 
- 3.3.1 CPU域初始化 389 
- 3.3.2 SMP负载均衡 401 
- 3.3.3 唤醒进程 415 
- 3.3.4 调试 421 
- 3.4 HMP调度器 422 
- 3.4.1 初始化 423 
- 3.4.2 HMP负载调度 425 
- 3.4.3 新创建的进程 436 
- 3.5 NUMA调度器 438 
- 3.5.1 node和page的关系 439 
- 3.5.2 扫描进程 441 
- 3.5.3 NUMA缺页中断 442 
- 3.5.4 进程迁移 450 
- 3.6 EAS绿色节能调度器 457 
- 3.6.1 能效模型 459 
- 3.6.2 WALT算法 465 
- 3.6.3 唤醒进程 480 
- 3.6.4 CPU动态调频 491 
- 3.7 实时调度 496 
- 3.8.1 进程管理更新 500 
## 第4章 并发与同步 501 
- 4.1 原子操作与内存屏障 503 
- 4.1.1 原子操作 503 
- 4.1.2 内存屏障 506 
- 4.2 spinlock 508 
- 4.2.1 spinlock实现 509 
- 4.2.2 spinlock变种 511 
- 4.2.3 spinlock和raw_spin_lock 512 
- 4.3 信号量 513 
- 4.3.1 信号量 513 
- 4.4 Mutex互斥体 517 
- 4.4.1 MCS锁机制 518 
- 4.4.2 Mutex锁的实现 525 
- 4.4.3 小结 531 
- 4.5 读写锁 531 
- 4.5.1 读者信号量 532 
- 4.5.2 写者锁 538 
- 4.6 RCU 544 
- 4.6.1 经典RCU和Tree RCU 547 
- 4.6.2 Tree RCU设计 551 
- 4.7 内存管理中的锁 574 
- 4.8.1 Queued Spinlock 584 
- 4.8.2 读写信号量优化 591 
- 4.8.4 推荐书籍 593 
## 第5章 中断管理 594  
- 5.1 Linux中断管理机制 595 
- 5.1.1 ARM中断控制器 595 
- 5.1.2 硬件中断号和Linux中断号的映射 599 
- 5.1.3 注册中断 610 
- 5.1.4 ARM底层中断处理 618 
- 5.1.5 高层中断处理 626 
- 5.1.6 小结 636 
- 5.2 软中断和tasklet 637 
- 5.2.1 SoftIRQ软中断 638 
- 5.2.2 tasklet 642 
- 5.2.3 local_bh_disable/local_bh_enable 647 
- 5.3 workqueue工作队列 650 
- 5.3.1 初始化工作队列 652 
- 5.3.2 创建工作队列 659 
- 5.3.3 调度一个work 665 
- 5.3.4 取消一个work 675 
- 5.3.5 和调度器的交互 680 
## 第6章 内核调试 684 
- 6.1 QEMU调试Linux内核 684 
- 6.1.1 QEMU运行ARM Linux内核 684 
- 6.1.2 QEMU调试ARM Linux内核 687 
- 6.1.3 QEMU运行ARMv8开发平台 688 
- 6.1.4 文件系统支持 690 
- 6.1.5 图形化调试 691 
- 6.1.6 实验进阶 693 
- 6.2 ftrace 694 
- 6.2.1 irqs跟踪器 695 
- 6.2.2 preemptoff跟踪器 696 
- 6.2.3 preemptirqsoff跟踪器 697 
- 6.2.4 function跟踪器 698 
- 6.2.5 动态ftrace 699 
- 6.2.6 事件跟踪 700 
- 6.2.7 添加tracepoint 702 
- 6.2.8 trace-cmd和kernelshark 705 
- 6.2.9 trace marker 707 
- 6.3 SystemTap 710 
- 6.4 内存检测 714 
- 6.4.1 slub_debug 714 
- 6.4.2 内存泄漏检测kmemleak 718 
- 6.4.3 kasan内存检测 720 
- 6.5 死锁检测 722 
- 6.6 内核调试秘籍 728 
- 6.6.1 printk 728 
- 6.6.2 动态打印 730 
- 6.6.3 RAM Console 731 
- 6.6.4 OOPS分析 731 
- 6.6.5 BUG_ON()和WARN_ON() 734 

----- 
# 《深入Linux内核架构与底层原理》
## 第1章总览
## 1.1简介
- 1.2Linux学习曲线和职业曲线
- 1.2.1给自己定级
- 1.2.2使用者
- 1.2.3开发者
- 1.3如何形成一个内核
- 1.3.1内核形成过程
- 1.3.2Exokernels和Anykernel
- 1.3.3内核为何使用C语言
## 第2章内核架构
- 2.1常见架构范式与核心系统
- 2.1.1Linux内核上下层通信方式
- 2.1.2横向系统和纵向系统
- 2.2基础功能元素
- 2.1模块支持
- 2.2.2模块编程可以使用的内核组件
- 2.3特殊硬件框架
- 2.4特殊软件机制
## 第3章内核数据结构
- 3.1链表与哈希表
- 3.1.1双向链表
- 3.1.2hlist
- 3.1.3ScatterList
- 3.1.4llist
- 3.2其他数据结构
- 3.2.1树
- 3.2.2FIFO文件
- 3.2.3位数组bitmap
## 第4章Linux系统的启动
- 4.1启动的硬件支持
- 4.1.1固件
- 4.1.2磁盘分区管理
- 4.2Bootloader和内核二进制
- 4.2.1Bootloader
- 4.2.2内核二进制
- 4.3Linux的启动原理
- 4.3.1Linux的最小系统制作和启动
- 4.3.2initrd文件系统
- 4.3.3EFI启动桩
- 4.3.4启动管理程序
- 4.3.5Linux内核启动顺序
## 第5章进程
- 5.1进程原理
- 5.1.1服务与进程
- 5.1.2资源与进程
- 5.1.3进程概念
- 5.1.4父子关系
- 5.1.5ptrace系统调用
- 5.2进程调度
- 5.2.1调度策略
- 5.2.2进程调度策略的配置
- 5.2.3公平问题
- 5.2.4内核线程的调度
- 5.3资源
- 5.3.1资源锁
- 5.3.2资源限制
- 5.3.3进程对系统内存的使用
- 5.4多进程与进程通信
- 5.4.1多进程模型
- 5.4.2用户进程间通信
- 5.4.3内核与用户空间的进程通信
- 5.4.4Netlink功能模块
- 5.4.5其他Netlink种类
- 5.4.6genetlink的使用
- 5.4.7inet_diag模块
- 5.4.8RTNETLINK
## 第6章Linux内核内存管理
- 6.1内存模型
- 6.1.1内存模型概览
- 6.1.2内存组织方式
- 6.2申请和释放内存
- 6.2.1高端内存
- 6.2.2设备内存映射
- 6.2.3启动时内存的申请和释放：bootmem
- 6.2.4Mempool
- 6.2.5CMA（连续内存分配器）
- 6.2.6伙伴算法
- 6.2.7slab
- 6.2.8用户端内存管理基础组件
- 6.3内存组件
- 6.3.1内存叫收算法（PFRA）
- 6.3.2其他内存功能组件
- 6.3.3内存压缩
- 6.3.4BDI（backing device info）
## 第7章安全
 7.1概览
- 7.2密码学
- 7.2.1密码学概览
- 7.2.2摘要
- 7.2.3加密
- 7.2.4认证
- 7.2.5数字签名
- 7.2.6秘钥交换
- 7.3Linux用户和权限系统
- 7.3.1系统启动时的权限
- 7.3.2系统启动后的权限
- 7.3.3内核中的用户和权限模型
- 7.3.4Linux安全体系
- 7.4网络安全
- 7.4.1netfilter概览
- 7.4.2Filter（LSF、BPF、eBPF）
- 7.5函数调用的调试
- 7.6内核调试
- 7.7PAM和Apparnlor
- 7.8内核安全
- 7.9常用安全工具和项目
## 第8章网络
- 8.1网络架构
- 8.2SOCket
- 8.2.1socket简介
- 8.2.2类型与接口
- 8.2.3Linux socket连接模型
- 8.3IP
- 8.3.1IP管理
- 8.3.2IP隧道
- 8.4TCP
- 8.4.1TCP存在的原因
- 8.4.2TCP的连接状态
- 8.4.3TCP拥塞控制
- 8.4.4TCP其他的功能特点
- 8.5网络服务质量与安全性
- 8.5.1TCP安全性
- 8.5.2QoS
- 8.5.3NAT
## 第9章总线与设备变动
- 9.1PCI
- 9.2USB
- 9.2.1USB概览
- 9.2.2USB子系统上层（USB设备驱动层）
- 9.2.3USB子系统的中层（USBcore）和下层
- 9.2.4Platform总线
- 9.3用户空间的设备管理
- 9.3.1设备变化通知用户端
- 9.3.2设备类型
- 9.3.3内核数据结构的面向用户组织KObject
- ……
## 第10章二进制
## 第11章存储
## 第12章虚拟化与云
## 第13章硬件专用子系统

------
# 《ARM嵌入式Linux系统开发详解》
## 第1篇Linux嵌入式开发基础篇 
## 第1章嵌入式系统入门 
- 1.1什么是嵌入式系统 
- 1.2嵌入式系统应用领域 
- 1.2.1家用电器和电子类产品 
- 1.2.2交通工具 
- 1.2.3公共电子设施 
- 1.3嵌入式系统发展 
- 1.3.1嵌入式微控制器 
- 132嵌入式微处理器 
- 1.3.3未来嵌入式系统发展的方向 
- 14典型的嵌入式系统组成 
## 第2章嵌入式软硬件系统 
- 2.1电路基本知识 
- 2.1.1什么是模拟电路 
- 2.1.2什么是数字电路 
- 2.1.3数制转换 
- 2.2计算机组成原理 
- 2.2.1计算机体系的发展 
- 2.2.2中央处理器 
- 2.2.3存储系统 
- 2.2.4总线系统 
- 2.2.5输入输出系统 
- 2.3软件基础知识 
- 2.3.1什么是软件 
- 2.3.2软件开发流程 
- 2.3.3常见的软件开发模型 
- 2.3.4计算机编程语言 
- 2.3.5数据结构 
- 24操作系统知识 
- 2.4.1什么是操作系统 
- 2.4.2操作系统的发展历史 
- 2.4.3操作系统由什么组成 
- 2.4.4几种操作系统的设计思路 
- 2.4.5操作系统分类 
## 第3章ARM处理器 
- 3.1微处理器和微控制器 
- 3.2ARM处理器介绍 
- 3.2.1ARM微处理器的应用领域 
- 3.2.2ARM的功能特点 
- 3.3ARM指令集 
- 3.3.1算术运算指令 
- 3.3.2逻辑运算指令 
- 3.3.3分支指令 
- 3.3.4数据传送指令 
- 3.4ARM的结构 
- 3.4.1ARM体系结构的命名方法 
- 3.4.2处理器系列划分 
- 3.4.3处理器工作模式 
- 3.4.4存储系统 
- 345寻址方式 
- 3.5ARM的功能选型 
- 3.5.1ARM的选型原则 
- 3.5.2几种常见的ARM核处理器选型参考 
## 第4章嵌入式Linux 
- 4.1常见的嵌入式操作系统 
- 4.1.1VxWorks 
- 4.1.2WindowsCE 
- 4.1.3PalmOS 
- 4.1.4Symbian 
- 4.2嵌入式Linux操作系统 
- 4.2.1什么是Linux 
- 4.2.2Linux与UNIX的不同——GPL版权协议介绍 
- 4.2.3Linux发行版 
- 4.2.4常见的嵌入式Linux系统 
## 第5章建立软件开发环境 
- 5.1独立的Linux系统 
- 5.1.1安装UbuntuLinux 
- 5.1.2怎样安装、卸载软件 
- 5.1.3怎样配置系统服务 
- 5.1.4安装主要的开发工具 
- 5.1.5安装其他的开发工具和文档 
- 5.2运行在Windows上的Linux系统 
- 5.2.1什么是Cygwin 
- 5.2.2如何安装Cygwin 
- 5.2.3安装开发环境 
- 5.3Linux常用工具 
- 5.3.1Linuxshell和常用命令 
- 5.3.2文本编辑工具vi 
- 5.3.3搜索工具find和grep 
- 5.3.4FTP工具 
- 5.3.5串口工具minicom 
- 5.4Windows常用工具 
- 5.4.1代码编辑管理工具SourceInsight 
- 5.4.2串口工具XShell 
- 5.5ARM集成开发环境ADS 
- 5.5.1ADS集成开发环境介绍 
- 5.5.2配置ADS调试环境 
- 5.5.3建立自己的工程 
## 第6章第一个Linux应用程序 
- 6.1向世界问好——Hello，World！ 
- 6.1.1用vi编辑源代码文件 
- 6.1.2用gcc编译程序 
- 6.1.3执行程序 
- 6.2程序背后做了什么 
- 6.2.1程序执行的过程 
- 6.2.2窥视程序执行中的秘密 
- 6.2.3动态库的作用 
- 6.3程序如何来的——编译的全部过程 
- 6.3.1编译源代码 
- 6.3.2连接目标文件到指定的库 
- 6.4更简单的办法——用Makefile管理工程 
- 6.4.1什么是Makefile 
- 6.4.2它是如何工作的 
- 6.4.3如何使用Makefile 
- 6.4.4好的源代码管理习惯  
- …… 
## 第2篇Linux嵌入式开发应用篇 
## 第7章Linux应用程序编程基础 
## 第8章开发多进程／线程程序 
## 第9章网络通信应用 
## 第10章串口通信编程 
## 第11章嵌入式GUI程序开发 
## 第12章软件项目管理 
## 第3篇Linux系统篇 
## 第13章ARM体系结构及开发实例 
## 第14章深入Bootloader 
## 第15章解析Linux内核 
## 第16章嵌入式Linux启动流程 
## 第17章Linux文件系统 
## 第18章建立交叉编译工具链 
## 第19章强大的命令系统BusyBox 
## 第20章Linux内核移植 
## 第21章内核和应用程序调试技术 
## 第4篇Linux嵌入式驱动开发篇 
## 第22章Linux设备驱动 
## 第23章网络设备驱动程序 
## 第24章Flash设备驱动 
## 第25章USB驱动开发

-------
# 《嵌入式Linux应用开发完全手册》
## 第1篇 嵌入式Linux开发环境构建篇
## 第1章 嵌入式Linux开发概述
## 第2章 嵌入式Linux开发环境构建
## 第3章 嵌入式编程基础知识
## 第4章 Windows、Linux环境下相关工具、命令的使用
## 第2篇 ARM9嵌入式系统基础实例篇
## 第5章 GPIO接口
## 第6章 存储器控制
## 第7章 内存管理单元MMU
## 第8章 NAND Flash控制器
## 第9章 中断体系结构
## 第10章 系统时钟和定时器
## 第11章 通用异步收发器UART
## 第12章 IIC接口
## 第13章 LCD控制器
## 第14章 ADC和触摸屏接口
## 第3篇 嵌入式Linux系统移植篇
## 第15章 移植U-Boot
## 第16章 移植Linux内核
## 第17章 构建Linux根文件系统
## 第18章 Linux内核调试技术
## 第4篇 嵌入式Linux设备驱动开发篇
## 第19章 字符设备驱动程序
## 第20章 Linux异常处理体系结构
## 第21章 扩展串口驱动程序移植
## 第22章 网卡驱动程序移植
## 第23章 IDE接口和SD卡驱动程序移植
## 第24章 LCD和USB驱动程序移植
## 第5篇 嵌入式Linux系统应用开发篇
## 第25章 嵌入式GUI开发
## 第26章 基于X的GUI开发
## 第27章 Linux应用程序调试技术

-------------
# 《Linux设备驱动程序》

----
# 《Linux设备驱动开发详解:基于最新的Linux4.0内核》
## 第1章 Linux设备驱动概述及开发环境构建 1 
- 1.1 设备驱动的作用 1 
- 1.2 无操作系统时的设备驱动 2 
- 1.3 有操作系统时的设备驱动 4 
- 1.4 Linux设备驱动 5 
- 1.4.1 设备的分类及特点 5 
- 1.4.2 Linux设备驱动与整个软硬件系统的关系 6 
- 1.4.3 Linux设备驱动的重点、难点 7 
- 1.5 Linux设备驱动的开发环境构建 8 
- 1.5.1 PC上的Linux环境 8 
- 1.5.2 QEMU实验平台 11 
- 1.5.3 源代码阅读和编辑 13 
- 1.6 设备驱动Hello World：LED驱动 15 
- 1.6.1 无操作系统时的LED驱动 15 
- 1.6.2 Linux下的LED驱动 15 
## 第2章 驱动设计的硬件基础 20 
- 2.1 处理器 20 
- 2.1.1 通用处理器 20 
- 2.1.2 数字信号处理器 22 
- 2.2 存储器 24 
- 2.3 接口与总线 28 
- 2.3.1 串口 28 
- 2.3.2 I2C 29 
- 2.3.3 SPI 30 
- 2.3.4 USB 31 
- 2.3.5 以太网接口 33 
- 2.3.6 PCI和PCI—E 34 
- 2.3.7 SD和SDIO 36 
- 2.4 CPLD和FPGA 37 
- 2.5 原理图分析 40 
- 2.6 硬件时序分析 42 
- 2.6.1 时序分析的概念 42 
- 2.6.2 典型的硬件时序 43 
- 2.7 芯片数据手册阅读方法 44 
- 2.8 仪器仪表使用 47 
- 2.8.1 万用表 47 
- 2.8.2 示波器 47 
- 2.8.3 逻辑分析仪 49 
## 第3章 Linux内核及内核编程 52 
- 3.1 Linux内核的发展与演变 52 
- 3.2 Linux 2.6后的内核特点 56 
- 3.3 Linux内核的组成 59 
- 3.3.1 Linux内核源代码的目录结构 59 
- 3.3.2 Linux内核的组成部分 60 
- 3.3.3 Linux内核空间与用户空间 64 
- 3.4 Linux内核的编译及加载 64 
- 3.4.1 Linux内核的编译 64 
- 3.4.2 Kconfig和Makefile 66 
- 3.4.3 Linux内核的引导 74 
- 3.5 Linux下的C编程特点 75 
- 3.5.1 Linux编码风格 75 
- 3.5.2 GNU C与ANSI C 78 
- 3.5.3 do { } while（0） 语句 83 
- 3.5.4 goto语句 85 
- 3.6 工具链 85 
- 3.7 实验室建设 88 
- 3.8 串口工具 89 
## 第4章 Linux内核模块 92 
- 4.1 Linux内核模块简介 92 
- 4.2 Linux内核模块程序结构 95 
- 4.3 模块加载函数 95 
- 4.4 模块卸载函数 97 
- 4.5 模块参数 97 
- 4.6 导出符号 99 
- 4.7 模块声明与描述 100 
- 4.8 模块的使用计数 100 
- 4.9 模块的编译 101 
- 4.10 使用模块“绕开”GPL 102 
## 第5章 Linux文件系统与设备文件 104 
- 5.1 Linux文件操作 104 
- 5.1.1 文件操作系统调用 104 
- 5.1.2 C库文件操作 108 
- 5.2 Linux文件系统 109 
- 5.2.1 Linux文件系统目录结构 109 
- 5.2.2 Linux文件系统与设备驱动 110 
- 5.3 devfs 114 
- 5.4 udev用户空间设备管理 116 
- 5.4.1 udev与devfs的区别 116 
- 5.4.2 sysfs文件系统与Linux设备模型 119 
- 5.4.3 udev的组成 128 
- 5.4.4 udev规则文件 129 
## 第6章 字符设备驱动 134 
- 6.1 Linux字符设备驱动结构 134 
- 6.1.1 cdev结构体 134 
- 6.1.2 分配和释放设备号 136 
- 6.1.3 f？ile_operations结构体 136 
- 6.1.4 Linux字符设备驱动的组成 138 
- 6.2 globalmem虚拟设备实例描述 142 
- 6.3 globalmem设备驱动 142 
- 6.3.1 头文件、宏及设备结构体 142 
- 6.3.2 加载与卸载设备驱动 143 
- 6.3.3 读写函数 144 
- 6.3.4 seek函数 146 
- 6.3.5 ioctl函数 146 
- 6.3.6 使用文件私有数据 148 
- 6.4 globalmem驱动在用户空间中的验证 156 
## 第7章 Linux设备驱动中的并发控制 158 
- 7.1 并发与竞态 158 
- 7.2 编译乱序和执行乱序 160 
- 7.3 中断屏蔽 165 
- 7.4 原子操作 166 
- 7.4.1 整型原子操作 167 
- 7.4.2 位原子操作 168 
- 7.5 自旋锁 169 
- 7.5.1 自旋锁的使用 169 
- 7.5.2 读写自旋锁 173 
- 7.5.3 顺序锁 174 
- 7.5.4 读—复制—更新 176 
- 7.6 信号量 181 
- 7.7 互斥体 183 
- 7.8 完成量 184 
- 7.9 增加并发控制后的globalmem的设备驱动 185 
## 第8章 Linux设备驱动中的阻塞与非阻塞I／O 189 
- 8.1 阻塞与非阻塞I／O 189 
- 8.1.1 等待队列 191 
- 8.1.2 支持阻塞操作的globalf？ifo设备驱动 194 
- 8.1.3 在用户空间验证globalf？ifo的读写 198 
- 8.2 轮询操作 198 
- 8.2.1 轮询的概念与作用 198 
- 8.2.2 应用程序中的轮询编程 199 
- 8.2.3 设备驱动中的轮询编程 201 
- 8.3 支持轮询操作的globalf ifo驱动 202 
- 8.3.1 在globalf ifo驱动中增加轮询操作 202 
- 8.3.2 在用户空间中验证globalf ifo设备的轮询 203 
## 第9章 Linux设备驱动中的异步通知与异步I／O 206 
- 9.1 异步通知的概念与作用 206 
- 9.2 Linux异步通知编程 207 
- 9.2.1 Linux信号 207 
- 9.2.2 信号的接收 208 
- 9.2.3 信号的释放 210 
- 9.3 支持异步通知的globalf ifo驱动 212 
- 9.3.1 在globalf ifo驱动中增加异步通知 212 
- 9.3.2 在用户空间中验证globalf ifo的异步通知 214 
- 9.4 Linux异步I／O 215 
- 9.4.1 AIO概念与GNU C库AIO 215 
- 9.4.2 Linux内核AIO与libaio 219 
- 9.4.3 AIO与设备驱动 222 
## 第10章 中断与时钟 224 
- 10.1 中断与定时器 224 
- 10.2 Linux中断处理程序架构 227 
- 10.3 Linux中断编程 228 
- 10.3.1 申请和释放中断 228 
- 10.3.2 使能和屏蔽中断 230 
- 10.3.3 底半部机制 230 
- 10.3.4 实例：GPIO按键的中断 235 
- 10.4 中断共享 237 
- 10.5 内核定时器 238 
- 10.5.1 内核定时器编程 238 
- 10.5.2 内核中延迟的工作delayed_work 242 
- 10.5.3 实例：秒字符设备 243 
- 10.6 内核延时 247 
- 10.6.1 短延迟 247 
- 10.6.2 长延迟 248 
- 10.6.3 睡着延迟 248 
## 第11章 内存与I／O访问 251 
- 11.1 CPU与内存、I／O 251 
- 11.1.1 内存空间与I／O空间 251 
- 11.1.2 内存管理单元 252 
- 11.2 Linux内存管理 256 
- 11.3 内存存取 261 
- 11.3.1 用户空间内存动态申请 261 
- 11.3.2 内核空间内存动态申请 262 
- 11.4 设备I／O端口和I／O内存的访问 267 
- 11.4.1 Linux I／O端口和I／O内存访问接口 267 
- 11.4.2 申请与释放设备的I／O端口和I／O内存 268 
- 11.4.3 设备I／O端口和I／O内存访问流程 269 
- 11.4.4 将设备地址映射到用户空间 270 
- 11.5 I／O内存静态映射 276 
- 11.6 DMA 277 
- 11.6.1 DMA与Cache一致性 278 
- 11.6.2 Linux下的DMA编程 279 
## 第12章 Linux设备驱动的软件架构思想 286 
- 12.1 Linux驱动的软件架构 286 
- 12.2 platform设备驱动 290 
- 12.2.1 platform总线、设备与驱动 290 
- 12.2.2 将globalf ifo作为platform设备 293 
- 12.2.3 platform设备资源和数据 295 
- 12.3 设备驱动的分层思想 299 
- 12.3.1 设备驱动核心层和例化 299 
- 12.3.2 输入设备驱动 301 
- 12.3.3 RTC设备驱动 306 
- 12.3.4 Framebuffer设备驱动 309 
- 12.3.5 终端设备驱动 311 
- 12.3.6 misc设备驱动 316 
- 12.3.7 驱动核心层 321 
- 12.4 主机驱动与外设驱动分离的设计思想 321 
- 12.4.1 主机驱动与外设驱动分离 321 
- 12.4.2 Linux SPI主机和设备驱动 322 
## 第13章 Linux块设备驱动 331 
## 第14章 Linux网络设备驱动 358 
## 第15章 Linux I2C核心、总线与设备驱动 387 
## 第16章 USB主机、设备与Gadget驱动 414 
## 第17章 I2C、SPI、USB驱动架构类比 459 
## 第19章 Linux电源管理的系统架构和驱动 494 
## 第20章 Linux芯片级移植及底层驱动 535 
## 第21章 Linux设备驱动的调试
