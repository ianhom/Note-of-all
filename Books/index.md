# 《Python网络编程攻略》
## 第1章 套接字、IPv4和简单的客户端／服务器编程1
- 1.1 简介1 
- 1.2 打印设备名和IPv4地址2 
- 1.3 获取远程设备的IP地址4 
- 1.4 将IPv4地址转换成不同的格式5 
- 1.5 通过指定的端口和协议找到服务名6 
- 1.6 主机字节序和网络字节序之间相互转换7 
- 1.7 设定并获取默认的套接字超时时间8 
- 1.8 优雅地处理套接字错误9 
- 1.9 修改套接字发送和接收的缓冲区大小12 
- 1.10 把套接字改成阻塞或非阻塞模式13 
- 1.11 重用套接字地址14 
- 1.12 从网络时间服务器获取并打印当前时间16 
- 1.13 编写一个SNTP客户端17 
- 1.14 编写一个简单的回显客户端／服务器应用18  
## 第2章 使用多路复用套接字I／O提升性能22 
- 2.1 简介22 
- 2.2 在套接字服务器程序中使用ForkingMixIn23 
- 2.3 在套接字服务器程序中使用ThreadingMixIn25 
- 2.4 使用select.select编写一个聊天室服务器28 
- 2.5 使用select.epoll多路复用Web服务器34 
- 2.6 使用并发库Diesel多路复用回显服务器37 
## 第3章 IPv6、Unix域套接字和网络接口40 
- 3.1 简介40 
- 3.2 把本地端口转发到远程主机41 
- 3.3 通过ICMP查验网络中的主机44 
- 3.4 等待远程网络服务上线48 
- 3.5 枚举设备中的接口51 
- 3.6 找出设备中某个接口的IP地址52 
- 3.7 探测设备中的接口是否开启53 
- 3.8 检测网络中未开启的设备55 
- 3.9 使用相连的套接字执行基本的进程间通信57 
- 3.10 使用Unix域套接字执行进程间通信58 
- 3.11 确认你使用的Python是否支持IPv6套接字61 
- 3.12 从IPv6地址中提取IPv6前缀63 
- 3.13 编写一个IPv6回显客户端／服务器64 
## 第4章 HTTP协议网络编程68 
- 4.1 简介68 
- 4.2 从HTTP服务器下载数据68 
- 4.3 在你的设备中伺服HTTP请求70 
- 4.4 访问网站后提取cookie信息72 
- 4.5 提交网页表单75 
- 4.6 通过代理服务器发送Web请求77 
- 4.7 使用HEAD请求检查网页是否存在78 
- 4.8 把客户端伪装成Mozilla Firefox79  
- 4.9 使用HTTP压缩节省Web请求消耗的带宽80 
- 4.10 编写一个支持断点续传功能的HTTP容错客户端82 
- 4.11 使用Python和OpenSSL编写一个简单的HTTPS服务器84 
## 第5章 电子邮件协议、FTP和CGI编程87 
- 5.1 简介87 
- 5.2 列出FTP远程服务器中的文件87 
- 5.3 把本地文件上传到远程FTP服务器中89 
- 5.4 把当前工作目录中的内容压缩成ZIP文件后通过电子邮件发送91 
- 5.5 通过POP3协议下载谷歌电子邮件94 
- 5.6 通过IMAP协议查收远程服务器中的电子邮件95 
- 5.7 通过Gmail的SMTP服务器发送带有附件的电子邮件97 
- 5.8 使用CGI为基于Python的Web服务器编写一个留言板 99  
## 第6章 屏幕抓取和其他实用程序103 
- 6.1 简介103 
- 6.2 使用谷歌地图API搜索公司地址103 
- 6.3 使用谷歌地图URL搜索地理坐标105 
- 6.4 搜索维基百科中的文章106 
- 6.5 使用谷歌搜索股价110 
- 6.6 搜索GitHub中的源代码仓库111 
- 6.7 读取BBC的新闻订阅源114 
- 6.8 爬取网页中的链接116 
## 第7章 跨设备编程119 
- 7.1 简介119 
- 7.2 使用telnet在远程主机中执行shell命令119 
- 7.3 通过SFTP把文件复制到远程设备中121 
- 7.4 打印远程设备的CPU信息123 
- 7.5 在远程主机中安装Python包126 
- 7.6 在远程主机中运行My

--------
# 《嵌入式网络那些事》
## 前言 
## 第1章 实验平台背后的故事 1 
- 1.1 嵌入式网络技术一统江湖 1 
- 1.1.1 嵌入式网络的发展现状 1 
- 1.1.2 嵌入式LwIP协议栈 4 
- 1.2 基于STM32的实验平台浅析 6 
- 1.2.1 STM32处理器的兴起 6 
- 1.2.2 实验平台简介 9 
- 1.2.3 网卡连接情况 11 
- 1.3 本书主要内容 12 
## 第2章 LwIP协议栈初体验 15 
- 2.1 庐山真面目之LwIP代码结构 15 
- 2.1.1 LwIP简介 15 
- 2.1.2 源代码结构 17 
- 2.2 怎样用SI阅读源代码 22 
- 2.3 千里之行从LwIP框架做起 27 
- 2.3.1 协议栈分层思想 27 
- 2.3.2 进程模型 30 
- 2.3.3 协议栈编程接口 31 
## 第3章 LwIP移植初探——无操作系统模拟层 35 
- 3.1 移植说明 35 
- 3.2 移植头文件 37 
- 3.3 网卡驱动编写 40 
- 3.4 安装系统时钟 47 
- 3.5 协议栈初始化 47 
- 3.6 查询接收数据包 49 
- 3.7 数据包中断接收 51 
- 3.8 如何定位Ping问题 53 
## 第4章 内核动力之源——内存管理 55 
- 4.1 内存管理背后的故事 55 
- 4.1.1 内存管理概述 55 
- 4.1.2 常见内存分配策略 57 
- 4.2 以不变应万变——动态内存池 59 
- 4.2.1 数据结构描述 59 
- 4.2.2 函数实现 65 
- 4.3 见招拆招——动态内存堆 67 
- 4.3.1 数据结构描述 67 
- 4.3.2 函数实现 69 
- 4.4 其他内存分配策略 74 
## 第5章 网络数据包——内核血液 78 
- 5.1 数据包管理的必要性 78 
- 5.1.1 LwIP的分层特点 78 
- 5.1.2 协议进程模型 80 
- 5.2 数据包管理原理大揭密 80 
- 5.2.1 数据包结构pbuf 81 
- 5.2.2 pbuf的类型 82 
- 5.2.3 数据包申请函数 85 
- 5.2.4 数据包释放函数 88 
- 5.2.5 其他数据包操作函数 90 
## 第6章 网络抽水机——网络接口管理 92 
- 6.1 引言 92 
- 6.2 接口管理的始与末 93 
- 6.2.1 数据结构 93 
- 6.2.2 函数实现 96 
- 6.3 特殊的网络接口——环回 99 
- 6.3.1 实现原理 99 
- 6.3.2 应用程序环回通信实战 102 
- 6.4 如何动态更改IP地址 109 
- 6.4.1 重要函数 109 
- 6.4.2 实战程序 110 
## 第7章 漫漫鹊桥路——ARP协议 113 
- 7.1 ARP协议之扫盲篇 113 
- 7.1.1 物理地址与网络地址 113 
- 7.1.2 ARP协议的本质 115 
- 7.2 关键数据结构 117 
- 7.2.1 ARP表 117 
- 7.2.2 ARP报文 121 
- 7.3 ARP之数据包引进来 126 
- 7.3.1 以太网数据包递交 126 
- 7.3.2 ARP数据包处理 129 
- 7.3.3 ARP攻击 131 
- 7.3.4 ARP缓存表的更新 132 
- 7.4 ARP之数据包走出去 137 
- 7.4.1 ARP层数据处理总流程 138 
- 7.4.2 广播包与多播包的发送 138 
- 7.4.3 单播包的发送 140 
## 第8章 互联网身份证——网际协议（IP） 144 
- 8.1 IP协议之扫盲班 144 
- 8.1.1 概述 144 
- 8.1.2 IP地址 145 
- 8.1.3 特殊IP地址 147 
- 8.1.4 子网划分与子网掩码 148 
- 8.1.5 网络地址转换（NAT） 150 
- 8.1.6 单播、多播与广播 151 
- 8.2 什么是IP数据报 153 
- 8.2.1 数据报组成结构 153 
- 8.2.2 数据结构 158 
- 8.3 IP数据报之走出去 159 
- 8.3.1 发送数据报 159 
- 8.3.2 数据报分片 162 
- 8.4 IP数据报之引进来 166 
- 8.4.1 数据报接收 166 
- 8.4.2 分片重装数据结构 171 
- 8.4.3 分片重装函数 174 
- 8.4.4 分片插入与检查 178 
## 第9章 互联网医生——ICMP协议 182 
- 9.1 ICMP扫盲班 182 
- 9.1.1 ICMP协议 182 
- 9.1.2 报文交付 183 
- 9.1.3 报文类型 184 
- 9.1.4 报文格式 185 
- 9.1.5 差错报文 185 
- 9.1.6 查询报文 188 
- 9.2 ICMP实现大起底 189 
- 9.2.1 数据结构 189 
- 9.2.2 发送差错报文 191 
- 9.2.3 ICMP报文的处理 192 
- 9.2.4 ping命令 196 
- 9.2.5 ICMP洪水 197 
- 9.3 如何发送Ping请求 198 
- 9.3.1 实现原理——raw_pcb 199 
- 9.3.2 发送ping请求 200 
- 9.3.3 测试结果 203 
## 第10章 Raw API无招胜有招之UDP篇 205 
- 10.1 UDP协议扫盲班 205 
- 10.1.1 传输层协议 205 
- 10.1.2 UDP协议 206 
- 10.1.3 端口号 207 
- 10.1.4 UDP报文的交付 208 
- 10.1.5 UDP报文格式 209 
- 10.1.6 UDP伪首部与校验和 210 
- 10.2 UDP数据结构详解 212 
- 10.2.1 报文首部结构 212 
- 10.2.2 控制块 212 
- 10.3 UDP RAW编程秘籍 216 
- 10.3.1 使用UDP编程 216 
- 10.3.2 新建控制块 216 
- 10.3.3 绑定控制块 217 
- 10.3.4 连接控制块 218 
- 10.3.5 其他控制块操作函数 219 
- 10.4 UDP RAW编程初体验 220 
- 10.4.1 UDP编程秘诀 220 
- 10.4.2 回送程序 221 
- 10.4.3 测试结果 222 
- 10.4.4 回调编程的缺陷 224 
- 10.5 内核报文处理细节 224 
- 10.5.1 报文的发送 224 
- 10.5.2 报文接收与递交 228 
- 10.6 挑战更复杂的UDP应用 231 
- 10.6.1 使用TFTP传送文件 231 
- 10.6.2 应用程序实现 234 
- 10.6.3 TFTP测试结果 242 
## 第11章 Raw API无招胜有招之TCP篇 244 
- 11.1 TCP协议大揭秘 244 
- 11.1.1 TCP的必要性 244 
- 11.1.2 TCP的特性 245 
- 11.1.3 连接的定义 247 
- 11.1.4 数据流编号 248 
- 11.1.5 滑动窗口 248 
- 11.2 TCP入门——报文 249 
- 11.2.1 报文格式 249 
- 11.2.2 TCP选项 251 
- 11.2.3 紧急数据 252 
- 11.2.4 强迫数据交互 253 
- 11.2.5 报文首部数据结构 253 
- 11.3 TCP基础——连接 254 
- 11.3.1 建立连接 254 
- 11.3.2 断开连接 255 
- 11.3.3 复位连接 256 
- 11.3.4 TCP状态转换图 257 
- 11.3.5 特殊的状态转换 259 
- 11.4 TCP核心——控制块 260 
- 11.4.1 控制块数据结构 260 
- 11.4.2 控制块链表 263 
- 11.4.3 接收窗口 264 
- 11.4.4 发送窗口 264 
- 11.5 TCP RAW编程秘诀 265 
- 11.5.1 控制块新建 265 
- 11.5.2 控制块绑定 267 
- 11.5.3 控制块侦听 267 
- 11.5.4 控制块连接 268 
- 11.5.5 发送数据 270 
- 11.5.6 关闭连接 270 
- 11.5.7 其他函数 272 
- 11.6 TCP RAW编程初体验 272 
- 11.6.1 TCP编程本质 272 
- 11.6.2 HTTP服务器 278 
- 11.6.3 打不死的客户端 280 
- 11.7 TCP输出处理细节放送 283 
- 11.7.1 报文段缓冲 283 
- 11.7.2 报文段构建 285 
- 11.7.3 报文段发送 287 
- 11.8 TCP输入处理细节放送 289 
- 11.8.1 TCP层函数调用流程 289 
- 11.8.2 报文输入 291 
- 11.8.3 TIME_WAIT状态的报文处理 294 
- 11.8.4 LISTEN状态的报文处理 294 
- 11.8.5 SYN攻击 296 
- 11.8.6 TCP状态机函数 297 
- 11.8.7 TCP数据输入 301 
- 11.9 可靠的传输服务 305 
- 11.9.1 超时重传与RTT估计 306 
- 11.9.2 慢启动与拥塞避免 311 
- 11.9.3 快速重传与快速恢复 314 
- 11.9.4 糊涂窗口与避免 316 
- 11.9.5 零窗口探查 319 
- 11.9.6 保活机制 321 
- 11.9.7 TCP定时器 322 
- 11.10 挑战更复杂的TCP应用 327 
- 11.10.1 Telnet服务器 327 
- 11.10.2 测试结果 333 
## 第12章 LwIP乾坤大挪移——操作系统模拟层 335 
- 12.1 模拟层是怎样炼成的 336 
- 12.1.1 移植综述 336 
- 12.1.2 添加文件 338 
- 12.1.3 修改头文件lwipopts.h 339 
- 12.1.4 头文件sys_arch.h 339 
- 12.1.5 全局变量与初始化 340 
- 12.1.6 信号量函数 341 
- 12.1.7 邮箱函数 343 
- 12.1.8 创建新进程 348 
- 12.1.9 修改内核初始化函数 349 
- 12.1.10 移植结果测试 350 
- 12.2 Sequential API牛刀小试 350 
- 12.2.1 回显服务器 351 
- 12.2.2 Web服务器 352 
- 12.2.3 操作系统下的raw API 355 
## 第13章 Sequential API大显身手 356 
- 13.1 探秘内核定时事件 356 
- 13.1.1 定时结构 356 
- 13.1.2 定时链表 357 
- 13.1.3 内核进程 359 
- 13.1.4 处理定时事件 361 
- 13.2 论消息机制的重要性 363 
- 13.2.1 消息结构 363 
- 13.2.2 数据包消息 364 
- 13.2.3 协议栈API实现 365 
- 13.2.4 API消息 367 
- 13.3 协议栈接口全搜罗 369 
- 13.3.1 用户数据缓冲netbuf 369 
- 13.3.2 如何操作数据缓冲 371 
- 13.3.3 连接结构netconn 373 
- 13.3.4 内核回调接口 375 
- 13.3.5 协议栈API秘籍 377 
- 13.4 Sequential API大会战 383 
- 13.4.1 网页控制设备 383 
- 13.4.2 UDP性能测试 386 
- 13.4.3 TCP性能测试 388 
- 13.4.4 并发服务器 390 
## 第14章 万剑归宗之Socket编程 395 
- 14.1 套接字接口来龙去脉 395 
- 14.1.1 如何实现Socket 395 
- 14.1.2 套接字函数秘籍 397 
- 14.2 Socket实战大串烧 401 
- 14.2.1 智能的TCP客户端 402 
- 14.2.2 UDP时间服务器 404 
- 14.2.3 Winsock客户端设计 406 
- 14.3 基于Select的并发服务器 408 
- 14.3.1 神奇的Select函数 409 
- 14.3.2 Select原理全解析 410 
- 14.3.3 Select实战——并发服务器 419 
## 第15章 LwIP工程实战——物联网关 424 
- 15.1 项目背景 424 
- 15.1.1 中央空调系统与温控器 424 
- 15.1.2 新需求的出现 427 
- 15.1.3 要做什么与如何去做 430 
- 15.2 智能网络温控器 431 
- 15.2.1 温控器实现方案 431 
- 15.2.2 Modbus TCP服务器 432 
- 15.3 物联网关设计 440 
- 15.3.1 物联网关实现方案 440 
- 15.3.2 网关服务器 441 
- 15.4 现场调试与测试 446 
- 15.4.1 温控器测试 446 
- 15.4.2 物联网关测试 447 
## 第16章 天下之术皆为我用—— LwIP高级篇 449 
- 16.1 外网访问之道——域名解析 449 
- 16.1.1 域名系统（DNS） 449 
- 16.1.2 DNS牛刀小试 450 
- 16.1.3 下载外网数据 453 
- 16.2 如何自动分配IP地址——DHCP 456 
- 16.2.1 DHCP大讲堂 456 
- 16.2.2 DHCP之实现详解 458 
- 16.2.3 是骡子是马——遛遛DHCP 460 
- 16.3 如何实现组播——Internet组管理 464 
- 16.3.1 IGMP协议大讲堂 464 
- 16.3.2 IGMP组播实践 465 
## 第17章 最后的战役 468 
- 17.1 如何配置协议栈 468 
- 17.1.1 内核配置文件opt.h 468 
- 17.1.2 如何提高TCP性能 471 
- 17.2 内核调试常用方法 472 
- 17.2.1 内核日志输出 472 
- 17.2.2 网络调试助手 474 
- 17.2.3 Wireshark抓包 475 
- 17.3 为了更好的明天 476 
- 17.3.1 常见移植问题 476 
- 17.3.2 常见应用问题 478 
- 17.4 故事结局 483 
## 参考文献 484
