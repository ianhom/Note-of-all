# 前言
- 从业嵌入式的8年也是不断学习的8年，也正是MCU（Micro-Controller Unit）开发蓬勃发展的时代。学习的过程中在前辈的指点、同事的帮助下进而积累了很多经验，感激之余亦觉应作出自己的贡献，就有了编写此书的想法。希望平日的点滴积累能帮助到各位嵌入式软件工程师。虽做不到传道受业，但努力为大家做到一定程度解惑。
- 书名受早年行业著作《[**MCU工程师炼成记**](https://www.amazon.cn/MCU%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%82%BC%E6%88%90%E8%AE%B0-%E6%88%91%E5%92%8CMSP430%E5%8D%95%E7%89%87%E6%9C%BA-%E4%B8%81%E6%AD%A6%E9%94%8B/dp/B00J7IH2TI/ref=cm_cr_arp_d_pdt_img_sims?ie=UTF8)》的启发，该书其中一位作者也是一直指导我的前辈，所以希望能有所传承，但重点放在嵌入式软件开发上，术业有所专攻。
- **To be continue**

# 目录
    1. 简介         
    2. C语言拾遗         
        2.1 C和指针         
        2.2 编译           
            2.2.1 预处理              
            2.2.2 编译            
            2.2.3 汇编    
            2.2.4 连接    
            2.2.5 库    
            2.2.6 编译器       
        2.3 内存结构          
        2.4 ....           
    3. 基本数据结构    
        3.1 链表        
            3.1.1 什么是链表                
            3.1.2 单向链表                
            3.1.3 双向链表        
            3.1.4 循环链表        
            3.1.5 链表的应用        
        3.2 队列     
        3.3 ....     
    4. 浅谈操作系统    
        4.1 软件框架    
        4.2 操作系统基本概念    
        4.3 ....    
    5. 编程能力扩展    
        5.1 模块化    
        5.2 面向对象    
        5.3 脚本语言    
        5.4 ....        
    6. 解忧嵌入式工程师      
        6.1 硬件还是软件？        
        6.2 ....    
                 
        
# 1. 简介
- 这不是一本教授编程语法的书，但可以帮助解开编程中的疑惑；
- 这也不是一本《从入门到精通》的工具书，但可以帮助提高编程功底；
- 这更不是一本《XX单片机开发教程》，但可以帮助理解嵌入式软件开发的本质。

- 本书结构如下：
    - C语言拾遗：着重讲解一下C语言中的关键概念，如指针、编译，为后面的内容夯实基础
    - 基本数据结构：深入探讨嵌入式领域中实用的数据结构
    - 浅谈操作系统：裸机编程到操作系统的转变
    - 编程能力扩展：编程语法之外的编程能力

- **To be continue**

# 2. C语言拾遗
- 在嵌入式领域，C语言是非常重要的主战武器。对C的掌握程度直接决定了对嵌入式相关知识的理解。正所谓好的开始是成功的一半，本书开遍先拾遗C语言中的一些关键概念，有助于理解后续章节。对于有较好C基础的同学可以粗略过一下即可。
- **To be continue**

## 2.1 C和指针
- **指针**
- 指针是C语言的一大特点，它使C语言变得非常强大，但也很危险，所以理解好C的指针对编写C程序有非常大作用。     
- 有很多人对指针的理解就是“地址”，确实在很多地方这样理解比较容易处理问题，但是指针和地址还是有一定的差别。指针包含两个信息：**地址**和**地址上的数据类型**。例如：
```c
    int  *pa = (int *)0;
    char *pb = (char *)0;
```
- 上例中pa和pb的值都是0，都指向地址为0的空间，但是pa+1的值和pb+1的值就不一样，前者因为是int类型，所以+1后指向地址为4的空间；而后者类型为char，所以+1后指向地址为1的空间。如果把指针的概念简单理解为地址，就不能说明上述的差别。     
   
- **To be continue**



## 2.2 编译
用习惯IDE的同学对编译的理解就是一个按钮，而实际上这个按钮的背后有很多细节，可以分为“预处理、编译、汇编、链接”四个阶段    
### 2.2.1 预处理     
在预处理阶段，将对C源码进行一次替换处理，形成最终的“源文件”。与预处理阶段相关的操作有#define，#include，#if,#ifdef等。下面举一个简单的例子：    
头文件Head.h
```c
#define A 20
#define B 10
#define OPERATION_ADD 
```    
源文件main.c
```c
#include "Head.h"
int main(void)
{
#ifdef OPERATION_ADD
    int c = A + B;
#else
    int c = A - B;
#endif
    return c;
}
```
在预处理中先对main.c源文件进行include
```c
#define A 20
#define B 10
#define OPERATION_ADD 
int main(void)
{
#ifdef OPERATION_ADD
    int c = A + B;
#else
    int c = A - B;
#endif
    return c;
}
```
然后对main.c源文件进行条件编译
```c
#define A 20
#define B 10

int main(void)
{
    int c = A + B;
    return c;
}
```
最后再对main.c源文件进行宏定义替换，我们就获得了真正的用于后续编译的源文件了。
```c
int main(void)
{
    int c = 20 + 10;
    return c;
}
```
### 2.2.2 编译
这里的编译不是我们平常理解的宏观定义（完成的预处理、编译、汇编、链接），而是更明确的“由C转换会汇编”的过程。这里几乎所有的操作都有编译器完成，由编译器决定如何将源码的c语句转换成汇编指令。当然程序员对转换的结果有一定程度的控制，这时就需要关注如const，volatile，static等修饰词，同时还有编译器优化等级和偏向这些要素来影响最终的汇编指令。经过编译器的的编译处理，我们上述的源代码将会转换成如下的汇编指令。    
```asm
main:
        sub     sp, sp, #16
        mov     w0, 30
        str     w0, [sp, 12]
        ldr     w0, [sp, 12]
        add     sp, sp, 16
        ret
```

### 2.2.3 汇编
经过上面的编译处理，C语言已经变成更为底层的汇编语句了，但是汇编代码不是最终执行的机器代码，众所周知机器只知道0和1，所以我们还需要对人类依旧可读的汇编语句进行处理转换成机器码，这个操作就叫汇编。    

### 2.2.4 链接
这个时候，几乎所有的代码基都转换成了机器码，但这些机器码还没有地址。所以需要链接器Linker来根据芯片的资源和代码中指定的地址或分区来为各个汇编好的机器码分配地址。当每个函数都有入口地址后，代码中的函数调用也就可以填写对应的地址来实现调用，文件之间的关联。        
链接的过程是根据链接脚本进行的（在keil中是sct，IAR中是icf），在链接脚本中写明了地址资源的使用规则，堆栈大小/位置，各个段/区域的划分。

### 2.2.5库
库是某些源文件，经过预处理、编译和汇编之后的文件集合，在库中已经无法看到C源码的具体实现，但依旧可以和其他C源码一同开发，在链接的时候融合成一个hex或bin。

- **To be continue**


### 2.2.6 编译器
- **To be continue**


## 2.3 内存结构
- 如果用一句话总结C语言的特点，那就是操作内存的编程语言，所以了解内存中的各种结构，可以更好理解C语言。
- 在MCU开发中，内存的使用十分关键，同时也是很多初学者容易忽略的知识点。
- 这里的内存我们指的是MCU中的RAM资源，大致可以分为：全局/静态存储区、堆和栈
### 2.3.1 全局/静态存储区
- 全局变量（gobal）是指作用域为全局的变量，其变量生命周期为全周期（直到所有程序完全运行结束）
- 静态变量（static）同全局变量，其生命周期为全周期，其作用域限定于定义的位置，若变量定义在函数内，则作用域在函数内，若在函数外，作用域为该源文件定义之后的所有位置。
- 不论是全局变量还是静态变量，其编译后的地址是固定的，可以从map文件中找到明确的地址。而栈和堆中的某个变量地址是不固定的。栈是在运行过程中由MCU自动分配的，而堆则是在运行过程中由程序员编写的程序来分配的。

### 2.3.2 栈
- 栈(stack)经常被称为堆栈，这里需要说明一下堆和栈其实是两个概念。栈是一种先入后出的结构，在程序运行时用于储存局部变量和函数上下文。
- 栈是对一段RAM空间的称呼，POP，PUSH就是针对栈的操作，由SP（stack pointor）来指示栈顶，由此来维护栈。
- 调用函数时，将会把当前函数的通用寄存器值和局部变量压入栈中，函数返回时，将上述内容从栈中弹出。
- 栈的生长方向一般是从高地址向低地址。    
- 通常所说的堆栈溢出，是指栈被push了超过其容量，最后push的内容覆盖了其它区域（如全局变量区）或无实际物理内存可用而造成的错误。         
 
### 2.3.3 堆
- 堆(Heap)在裸奔的单片机开发中很少用到，动态分配来的内存来自于堆。所谓的动态分配在C语言中就是使用malloc和free这类内存申请和释放函数来实现内存的动态地利用。这里的动态是指内存是在程序运行时，根据需要来进行申请的，其申请到的位置也不固定。
- 堆可以说没有生长方向这个概念，完全取决于malloc的具体实现。
- 在没有MMU（内存管理单元）的平台上，频繁的使用堆会造成碎片，例如申请了10个32字节的内存块，但间隔释放掉5个，此时虽然有5\*32字节的空间，但任然无法申请一个64字节的内存块出来，因为堆中内存都是碎片化存在的。

- **To be continue**

## 2.4 ....
- **To be continue**

# 3. 基本数据结构
- **To be continue**

## 3.1 链表
- 链表对于学纯软件的工程师而言是个非常简单的概念，但对于嵌入式软件工程师，因为面对都是资源受限的MCU的平台，难得有机会使用这样“高大上”的数据结构，所以会觉得陌生。但随着MCU的发展，主频和储存都在不断扩大，嵌软工程师们也开始不断尝试更复杂的数据结构或软件模型。链表就是一个最典型的需要了解的数据结构，因为由它展开的应用非常多，也非常实用。
- 链表由节点组成，每个节点中有两类成员，一个是有效数据（单个、多个数据或结构体），另一个是指向下一个节点的指针变量。
- **To be continue**

## 3.2 队列
- 队列是一种简单但很实用的数据结构。
### 3.2.1 队列基本原理
- **To be continue**

### 3.2.1 队列的应用 ———— 缓存
- 队列是一种先入先出（FIFO - First In First Out）的数据结构。在写通讯类应用的时候，经常会遇到一种情况，就是接收到一条报文，还没有来得及处理又来了一条报文。对于这种“生产速度”瞬时大于“消费速度”的情形，缓存是最常见的方法。
首先我们来定义一个简单的数组型的队列缓存    
```c
typedef struct _BUFFER
{
    uint8  *pu8Data;        /* Pointer of buffer data     */
    uint32  u32DataLen;     /* The bytes of per data      */
    uint32  u32DataCntMax;  /* The count of datas         */
    uint32  u32DataCntCur;  /* Current count of datas     */
    uint32  u32DataHead;    /* The position of first data */
}
```
- 一般的队列都有头位置和尾位置，头位置是最早进入队列的数据所在的位置，尾位置是下一个数据即将放入的位置，所以通过尾位置减去头位置就可以知道有多少个数据。当然这里还有一个例外，就是头尾位置相同时，可以表示队列为空，或表示队列为满。为了处理这样的误解，我们在队列的数据结构中增加一个计数器用于统计目前有多少个有效数据。每次压入准备压入新数据时，先行比较当前有效数据是否已经达到最大数，这样既可以识别队列是否为满。而头位置、尾位置和如队列的计数三者的关系本身就是知其二可得第三，所以这里设计只有头位置和计数，尾位置通过头位置+计数可获得。

----
- **To be continue**

## 3.3 ...
- **To be continue**

# 4. 浅谈操作系统
- 从事嵌入式软件开发的同学，基本都绕不开操作系统这个领域，即使工作中没有使用到，也会补充相关知识。
- **To be continue**

## 4.1 软件框架
- 嵌入式软件框架可以从实时性的角度来看软件框架的演变。    

- **To be continue**

## 4.2 操作系统基本概念
- **To be continue**

## 4.3 ...
- **To be continue**


# 5. 编程能力扩展
- 编程不是说搞清楚编程语言语法就能胜任的，语法只是使用编程语言的规范，真正起作用的是语法背后的思想，也是嵌入式软件工程师需要不断增加的内功。
- **To be continue**

## 5.1 模块化
- 作为嵌入式软件工程师，大部分时间相处的还是面向过程的C语言，但随着代码越来越复杂，需要描述的过程也会越来越多，若组织不好，工程师对代码的掌控就会渐渐失控。这时就需要更合理的组织方式来编程。
- **To be continue**

## 5.2 面向对象
- 面向对象是高级语言的一个重要特性，但面向过程的C语言一样也可以使用面向对象的思想来编程。
- **To be continue**

## 5.3 脚本语言
- 想了解脚本语言，首先要了解一下编译语言。
- 编译型语言是编写的语言到目标硬件上运行的代码之间需要进行一个转换过程，这个过程叫做编译。
- **To be continue**

## 5.4 ...
- **To be continue**
 
## 6 解忧嵌入式工程师
### 6.1 硬件还是软件？
- 对于很多从事嵌入式领域的同学而言，绝大多数人都遇到过这样的问题，是做硬件方向还是软件方向？对于职场新人，这似乎是个关乎未来的问题，即使对有几年工作经验的工程师，在这个问题上也会摇摆不定。但一般而言，最终的决定也就三类：硬件/软件/软硬兼修。
- 坚持硬件：从嵌入式从业人员的专业分布来看，绝大多数都是有硬件基础的
- 选择软件：对很多人而言，从大学获取的嵌入式软件知识基本只有C语言课程，剩下的基本都是从开发板，网络分享习得。
- 挑战双修：有的是不愿放弃一方，有的是能力确实不凡，有的却是被逼无奈，确实有很多工程师选择了软硬双修的道路。


未完待续。。。。    
---

欢迎关注我的微信公众号：**墨意MOE**    
![](../Pic/Misc/qrcode_for_gh_a64f54357afb_258.jpg)
